{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-03-18T00:14:44.004853+00:00",
  "repo": "mengelbart/rtp-over-quic-draft",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "SDP",
      "description": "",
      "color": "528EC7"
    },
    {
      "name": "NextDoc",
      "description": "Potential additions in a next-generation document",
      "color": "bfdadc"
    },
    {
      "name": "NextInterim",
      "description": "Targeting PR for next interim meeting",
      "color": "52B96A"
    },
    {
      "name": "NotJustRTP",
      "description": "Issue is not specific to RTP over QUIC",
      "color": "bfdadc"
    },
    {
      "name": "IETF118",
      "description": "Targeting PR by IETF 118",
      "color": "bfd4f2"
    },
    {
      "name": "Review outside AVTCORE needed",
      "description": "Issue relies on expertise outside WG core competence",
      "color": "5319e7"
    },
    {
      "name": "Not Yet",
      "description": "Text would depend on implementation/deployment experience",
      "color": "fbca04"
    },
    {
      "name": "external doc",
      "description": "Can likely be solved in another document",
      "color": "c2e0c6"
    },
    {
      "name": "Discussion required",
      "description": "Need to know what WG thinks before applying PR",
      "color": "1d76db"
    },
    {
      "name": "Current Focus",
      "description": "Authors working on this now/soon",
      "color": "d4c5f9"
    },
    {
      "name": "IETF119",
      "description": "Targeting PR by IETF 119",
      "color": "5319e7"
    },
    {
      "name": "FIN-WAIT",
      "description": "In the process of closing, for various reasons",
      "color": "fef2c0"
    },
    {
      "name": "IETF120",
      "description": "Targeting PR by IETF 120",
      "color": "fef2c0"
    }
  ],
  "issues": [
    {
      "number": 11,
      "id": "I_kwDOFUmh7s5KFI8X",
      "title": "RTCP and delay based CC in QUIC",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/11",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[Section 6.1](https://datatracker.ietf.org/doc/html/draft-engelbart-rtp-over-quic#section-6.1) currently says that QUIC MUST use a timestamp extension to implement a delay-based congestion controller. Technically, the timestamps could also be implemented in RTCP using [RFC 8888](https://www.rfc-editor.org/rfc/rfc8888.html), but that would mean, that the application has to give timestamps back to the QUIC layer via some API. I am not sure if this is useful or if it would, for example, suffer from timing problems given that the arrival timestamp feedback would pass through the application layer before reaching the congestion controller at the transport layer.\r\n\r\nMaybe the document should give some guidance on what to do if no QUIC ack timestamps are available, e.g., \"RTCP MAY be used as a replacement\" or \"RTCP SHOULD NOT be used and instead CC option 2 (Section 6.2) SHOULD be used\".\r\n\r\nSee also the Editor's note in Section 6.1",
      "createdAt": "2022-05-20T09:14:13Z",
      "updatedAt": "2022-09-12T13:46:36Z",
      "closedAt": "2022-09-12T13:46:36Z",
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOFUmh7s5MlxXl",
      "title": "State what endpoints should do if the QUIC datagram extension is not enabled",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/13",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "question",
        "SDP",
        "NotJustRTP",
        "Current Focus"
      ],
      "body": "The RTP over QUIC puts a hard requirement on endpoints advertising their support for the QUIC datagram extension.\r\n\r\nIf endpoints use ALPN to select RTP over QUIC, but the QUIC transport parameters do not contain a `max_datagram_frame_size`, it is not clear what should happen. One approach would be to fail the connection at the point this is detected, such as rejcting the connection handshake. \r\n\r\nNot stating an expected way to handle this could lead to some interop problems.",
      "createdAt": "2022-06-26T16:29:35Z",
      "updatedAt": "2024-02-11T01:55:36Z",
      "closedAt": "2023-10-23T14:27:51Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Datagram support in the QUIC implementation is only required if RTP over QUIC datagrams is required. If datagrams are not supported, endpoints can still use QUIC streams. Would it be helpful to add something like \"endpoints MUST not use datagrams unless support was indicated via `max_datagram_frame_size` by both endpoints\"?",
          "createdAt": "2022-06-27T10:32:05Z",
          "updatedAt": "2022-06-27T10:32:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "So I might be misunderstanding (and if so, let me know) but I don't think that requirement quite captures what your goals would be. When your peer doesn't support receiving QUIC datagrams you *can't* send them by definition of QUIC.\r\n\r\nThe quandry RTP over QUIC has is offering two ways to carry application data with little guidance on how applications would use these features. For example, if the client *only* wants to send datagrams and the server doesn't state it supports the QUIC datagram extension, what happens?\r\n\r\nEqually and oppositely, imagine a client only wants to use streams, and the server only wants to receive datagrams - so provides zero credits for creating streams. What happens?\r\n\r\nYou suggest QUIC streams can be used as a fallback from datagrams, but I think that highlights a design assumption in the specification, which could benefit from being made explicit. I'm not sure everybody is on board with that design if it isn't written down.\r\n\r\nSince you have two ways to carry data, and those capabilities are advertised unilaterally, you have a matrix of combinations. You might want to think about codifying these, so that applications can communicate their intent early. For instance, defining an RTP-over-QUIC transport parameter or a few ALPNs, to help negotiate the capabilities at the start.",
          "createdAt": "2022-06-27T10:47:00Z",
          "updatedAt": "2022-06-27T10:47:00Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think I misunderstood the issue. You're right, my suggestion doesn't make much sense, since using datagrams is already impossible when it is not supported.\r\n\r\nMaybe our assumption is, that since peers have to negotiate the session out of band, we expect them to negotiate only what their QUIC implementations support and then adhere to what they negotiated. But that probably doesn't really prevent the situations you describe.\r\n\r\nI think we might want to add some explanation about what we expect from the external signalling and then also add a transport parameter or different ALPNs as you suggested.\r\n\r\nI am thinking about how to implement this in the draft, but I am not (yet) sure if I understand all the implications. For example, the situation you describe, where a server provides zero credits for streams, wouldn't that still be possible, even with the correct signalling and is there anything we could do about it?",
          "createdAt": "2022-07-01T11:50:41Z",
          "updatedAt": "2022-07-01T11:50:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I'm not an RTP expert so take my comments with a pinch of salt. But any time I hear that a signalling mechanism puts some expectations on a loosely coupled transport, I get a bit nervy. This is primarily because applications don't always have as tight a coupling (or control) over their transport layer as they think they might like. HTTP/3 has a bit of this now, where multi-cloud or multi-CDN deployments can invalidate prior advertisements.\r\n\r\nDesigning some robustness into handling mismatches can help spot them earlier. Transport parameters or ALPNs have different tradeoffs. I wouldn't rush into picking one without understanding your problem space. So this issue might need some time to mature.\r\n\r\nYou're right about zero credits, that could always happen. HTTP/3 recommends at least 100 concurrent bidirectional streams at any time https://www.rfc-editor.org/rfc/rfc9114.html#section-6.1-2. Section 6.1 and 6.2 more broadly discuss considerations for flow control and unidirectional streams. I'd suggest other application mappings think of similar guidance. ",
          "createdAt": "2022-07-02T23:55:33Z",
          "updatedAt": "2022-07-02T23:55:33Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion with @joerg-ott and @mengelbart, I think this comment from @LPardue is an excellent place to start ... \r\n\r\n> You're right about zero credits, that could always happen. HTTP/3 recommends at least 100 concurrent bidirectional streams at any time https://www.rfc-editor.org/rfc/rfc9114.html#section-6.1-2. Section 6.1 and 6.2 more broadly discuss considerations for flow control and unidirectional streams. I'd suggest other application mappings think of similar guidance.\r\n\r\nWhat I'm thinking, is that we can reasonably say \r\n1. If both sides don't support datagrams/provides zero credits for datagrams, you won't be using datagrams (duh), \r\n2. So you're going to be using streams, and we can make suggestions that will help this \"suck less\". \r\n\r\nI can propose text for this, at least as a starting point. I'm not tagging the issue as a pre-IETF 116 priority for now. \r\n\r\nDoes that all make sense?",
          "createdAt": "2023-01-13T16:43:02Z",
          "updatedAt": "2023-01-13T16:46:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Issue #76 adding error codes will help with this one. ",
          "createdAt": "2023-05-17T16:37:15Z",
          "updatedAt": "2023-05-17T16:37:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Error codes were added in #91, including an [explanation for handling the absence of datagram support](https://github.com/mengelbart/rtp-over-quic-draft/pull/91/files#diff-88df85545ee4dd07f1027eb4174149926d2df360b5dff6dd0c8f80dd802b2e26R631).\r\n\r\nThere will be more changes to the IANA considerations for error codes (#140), but I suggest we close this issue already. We still have #76 tracking the error codes more generally.",
          "createdAt": "2023-10-11T12:52:31Z",
          "updatedAt": "2023-10-11T12:52:31Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @LPardue - so, the text [for handling the absence of datagram support](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-quic-datagrams), first paragraph: \r\n\r\n> Senders can also transmit RTP packets in QUIC datagrams. QUIC datagrams are an extension to QUIC described in [RFC9221]. QUIC datagrams can only be used if the use of the extension was successfully negotiated during the QUIC handshake. **If the use of an extension was signaled using a signaling protocol, but the extension was not negotiated during the QUIC handshake, a peer MAY close the connection with the ROQ_EXPECTATION_UNMET error code.**\r\n\r\nhandles the case where I told you (via signaling) that I will be sending you QUIC datagrams, but when we do our QUIC handshake, for whatever reason, we fail to negotiate the datagram extension. \r\n\r\nI chatted with several MoQ folks during the Hackathon at IETF 117, and the consensus was that \r\n\r\n- people know what an implementation should do when the implementation receives a frame type it has never seen or heard of before (\"a grommet frame\") - return a connection error of type FRAME_ENCODING_ERROR , as described in [Section 12.4 of RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000#name-frames-and-frame-types), but \r\n- people don't agree on what implementations should do when the implementation receives a frame type that it understands, **except** that the frame type is defined for a QUIC extension that has not been negotiated (\"a datagram frame\") - some implementations treat the known but unnegotiated frame **as if it were unknown**, and other implementations might do \"something else\". \r\n\r\nSo, my question here, is - is it helpful for us to say anything about this inconsistency in RoQ, or should I be doing something else?\r\n\r\nOne possibility would be a short draft targeted at the QUIC WG, updating RFC 9000, that at least explains the issue, and could reasonably caution application developers about the possibility that an implementation might surprise them, but I'm sure there are other, possibly smarter, possibilities. ",
          "createdAt": "2023-10-18T20:12:34Z",
          "updatedAt": "2023-10-18T20:12:34Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "A LONG time ago, @LPardue said (above), \r\n\r\n> You're right about zero credits, that could always happen. HTTP/3 recommends at least 100 concurrent bidirectional streams at any time https://www.rfc-editor.org/rfc/rfc9114.html#section-6.1-2. Section 6.1 and 6.2 more broadly discuss considerations for flow control and unidirectional streams. I'd suggest other application mappings think of similar guidance.\r\n\r\nThat's gotten a bit lost, up until now, and it doesn't have anything to do with datagrams, so I'll create a separate issue for it. (#142 ) \r\n\r\n",
          "createdAt": "2023-10-18T20:28:17Z",
          "updatedAt": "2023-10-18T20:44:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> people don't agree on what implementations should do when the implementation receives a frame type that it understands, except that the frame type is defined for a QUIC extension that has not been negotiated (\"a datagram frame\") - some implementations treat the known but unnegotiated frame as if it were unknown, and other implementations might do \"something else\".\r\n\r\nI think [RFC 9221](https://www.rfc-editor.org/rfc/rfc9221.html#name-transport-parameter) is quite clear about this:\r\n\r\n> An endpoint that receives a DATAGRAM frame when it has not indicated support via the transport parameter MUST terminate the connection with an error of type PROTOCOL_VIOLATION.\r\n\r\nI don't know if it is an issue that the error codes are different. One could possibly use this to learn about the implementation of the other endpoint: If you get a PROTOCOL_VIOLATION, the endpoint seems to be using an implementation that supports the datagram extension. If you get a FRAME_ENCODING_ERROR, the implementation does not seem to know datagrams. But I don't think RoQ is the right place to discuss this.",
          "createdAt": "2023-10-19T07:20:22Z",
          "updatedAt": "2023-10-19T07:20:22Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOFUmh7s5Mlx2F",
      "title": "What stream types are used?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/14",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "QUIC provides 4 stream types, the spec seems to overlook stating if there are any requirements on the use of these streams. An application needs to know the right type to pick for interop.\r\n\r\nIn the simplest case, I can imagine that a single RTP packet is sent on a unidirectional stream, which is then closed. But perhaps you picture a bidirectional stream being used to exchange a pair of packets?",
      "createdAt": "2022-06-26T16:37:40Z",
      "updatedAt": "2022-09-23T07:18:16Z",
      "closedAt": "2022-09-23T07:18:16Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I agree, we should clarify that in the spec. I also realized that we don't state explicitly, that a stream MUST be closed immediately after the RTP packet is completely sent, otherwise streams don't work as implicit framing. I think we just assumed unidirectional streams because we expect senders to close streams after sending a packet. I think technically it might be possible to use bidirectional streams, too, but since there is no synchronous relationship between sent and received RTP/RTCP packets, it is probably easier to use unidirectional streams.\r\n\r\nI just opened #17 for this.",
          "createdAt": "2022-06-27T13:49:56Z",
          "updatedAt": "2022-06-27T13:49:56Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOFUmh7s5Mlx9R",
      "title": "Missing considerations about stream concurrecy",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/15",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When RTP packets are sent on streams, the spec only allows one packet per stream send side. This immediately limits the number of concurrent packets to be bound by the number of concurrent streams. \r\n\r\nI don't know which stream types you picture using (see #14) but that is tangential. Whatever types are used, the spec should give some consideration to the minumum and maximum number of concurrent streams for RTP over QUIC. Applications that fail to provide enough concurrency credit can cause deadlocks or timeouts.",
      "createdAt": "2022-06-26T16:39:53Z",
      "updatedAt": "2022-10-24T14:28:42Z",
      "closedAt": "2022-10-24T14:28:42Z",
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOFUmh7s5MlyFM",
      "title": "Does RTP over datagram retransmission happen on the same flow ID?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/16",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "See https://www.ietf.org/archive/id/draft-engelbart-rtp-over-quic-04.html#section-6.2\r\n\r\nIt would seem to be sensible to recommend retransmitting the RTP packet on the same datagram flow ID but I'm not an expert on RTP stuff.",
      "createdAt": "2022-06-26T16:42:12Z",
      "updatedAt": "2022-09-12T13:54:24Z",
      "closedAt": "2022-09-12T13:54:24Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think it would depend on how the RTP implementation is doing retransmissions. RFC 4588 allows retransmissions either in the same session with a different SSRC or in a separate session. If different flow IDs are required for different sessions, as is the case in the current draft, then that would also be the case for retransmissions in different sessions, but not for retransmissions that happen in the same session.",
          "createdAt": "2022-06-27T10:55:58Z",
          "updatedAt": "2022-06-27T10:55:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "That sounds reasonable. Since it sounds like there are some implementation decisions to make, It might be helpful to note that this type of retransmission behaviour is possible, and what the implications are for both stream-based or datagram-based retransmissions. ",
          "createdAt": "2022-06-27T11:07:40Z",
          "updatedAt": "2022-06-27T11:07:40Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOFUmh7s5PDxu-",
      "title": "Section 8: Bandwidth sharing",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/20",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"*TODO:* Add considerations for bandwidth shares when a QUIC connection is shared between RTP and non-RTP streams?\"",
      "createdAt": "2022-08-02T20:54:03Z",
      "updatedAt": "2022-09-12T13:45:29Z",
      "closedAt": "2022-09-12T13:45:29Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "This was done by adding [section 8.3](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#name-shared-quic-connections) but I forgot to remove the TODO. I will create a PR.",
          "createdAt": "2022-08-03T07:46:57Z",
          "updatedAt": "2022-08-03T07:46:57Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "I_kwDOFUmh7s5PDzWj",
      "title": "Section 8.1: Congestion control recommendations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/21",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"  If congestion control is to be applied at the transport layer, it is\r\n   RECOMMENDED to configure the QUIC Implementation to use a delay-based\r\n   real-time congestion control algorithm instead of a loss-based\r\n   algorithm.  The currently available delay-based congestion control\r\n   algorithms depend on detailed arrival time feedback to estimate the\r\n   current one-way delay between sender and receiver. \"\r\n\r\n[BA] Can we make this a bit more specific? \r\n\r\n1. By \"delay-based congestion control algorithms\" are you referring to the algorithms mentioned in RFC 8888 Section 1?\r\n2. Would BBRv2 qualify?\r\n3. Mac OS X 16 includes support for L4S and scalable congestion control.  Would this qualify? \r\nSee: https://developer.apple.com/videos/play/wwdc2022/10078/\r\n\r\n",
      "createdAt": "2022-08-02T21:02:07Z",
      "updatedAt": "2022-10-24T14:41:47Z",
      "closedAt": "2022-10-24T14:41:47Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> [BA] Can we make this a bit more specific?\r\n> \r\n>     1. By \"delay-based congestion control algorithms\" are you referring to the algorithms mentioned in RFC 8888 Section 1?\r\n\r\nI think that was the intention when we wrote this paragraph. When thinking about this again now, I think it may be better to express this recommendation by explaining the application's requirements rather than by the congestion signals used by the employed algorithm or even listing specific ones. If we do that, it would also make sense to relax the following sentences:\r\n\r\n> The currently available delay-based congestion control algorithms depend on detailed arrival time feedback to estimate the current one-way delay between sender and receiver. Since QUIC does not provide arrival timestamps in its acknowledgments, the QUIC implementations of the sender and receiver MUST use an extension to add this information to QUICs acknowledgment frames\"\r\n\r\nIf we don't specify how the algorithms should work internally, it also doesn't make sense to require the use of a timestamp extension to provide one-way delay measurements.\r\n\r\n>     2. Would BBRv2 qualify?\r\n> \r\n>     3. Mac OS X 16 includes support for L4S and scalable congestion control.  Would this qualify?\r\n>        See: https://developer.apple.com/videos/play/wwdc2022/10078/\r\n\r\nWould it be specific enough to express a need for a congestion controller that ensures that RTP/RTCP packets are transmitted at low latencies? I think that would exclude loss-based algorithms and may exclude BBRv1 due to probing. I don't know if BBRv2 would qualify and I think L4S would.",
          "createdAt": "2022-08-03T08:48:17Z",
          "updatedAt": "2022-08-03T08:49:12Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I like the idea of specifying the general requirement (e.g. low-latency).  Separately, it would be worth understanding whether QUIC cc algorithms meet that requirement (e.g. whether BBRv2 is usable or not, whether iOS 16 L4S is helpful, etc.). ",
          "createdAt": "2022-08-03T14:35:59Z",
          "updatedAt": "2022-08-03T14:35:59Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I opened #36. I agree that it would be worth understanding which algorithms meet the requirement, but since I can currently not answer that for algorithms like BBRv2 or L4S, I don't want to put my assumptions in the document.",
          "createdAt": "2022-09-12T15:43:59Z",
          "updatedAt": "2022-09-12T15:43:59Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOFUmh7s5PD1SK",
      "title": "Section 8.1: QUIC connection sharing with non-RTP streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/22",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "      *Editor's note:* How can a QUIC connection be shared with non-RTP\r\n      streams, when SCReAM/NADA/GCC is used as congestion controller?\r\n      Can these algorithms be adapted to allow different streams\r\n      including non-real-time streams?  Do they even have to be adapted\r\n      or _should_ this just work?\r\n\r\n[BA] When a file is being transferred within an audio/video chat session, it is typically desired for the file transfer not to interfere with media. To accomplish this, the file transfer is subjected to the same low-latency cc algorithm and also, the bandwidth allocated to the transfer may be restricted. Subjecting the transfer to unified congestion control means that it will take longer that it would if it were on a separate connection competing with the A/V traffic, but that's the desired outcome.",
      "createdAt": "2022-08-02T21:11:41Z",
      "updatedAt": "2022-09-12T13:51:07Z",
      "closedAt": "2022-09-12T13:51:06Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "That makes sense, I think we can delete the note.",
          "createdAt": "2022-08-04T17:06:09Z",
          "updatedAt": "2022-08-04T17:06:09Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "I_kwDOFUmh7s5PD1jA",
      "title": "Section 8.1: Timestamp extension requirement",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/23",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "      *Editor's note:* An alternative to the hard requirement to use a\r\n      timestamp extension could be to use RTCP, but that would mean,\r\n      that an application has to negotiate RTCP congestion control\r\n      feedback which would then have to be passed to the QUIC congestion\r\n      controller.",
      "createdAt": "2022-08-02T21:13:06Z",
      "updatedAt": "2022-09-12T13:46:36Z",
      "closedAt": "2022-09-12T13:46:36Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "See also #11 \r\n\r\n[Section 7](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#name-rtcp) explains in detail how information from the QUIC layer can be used to replace RTCP. This is the opposite: we want to use information from RTCP at the QUIC layer. I don't think is useful to add text for this to the document for the following reasons:\r\n\r\n- The QUIC congestion controller would depend on the information that is only present at the application layer. If we want to use RTCP (e.g., because timestamps are not available), we can still have congestion control at the application layer as explained in [section 8.2](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#section-8.2). If there's no API to disable/manage the QUIC congestion controller, there will likely be no API to pass feedback to it either.\r\n- It would be unclear how the QUIC congestion controller should treat non-RTP data for which we still don't have arrival times.\r\n\r\nShould we add an explanation for these problems or just delete the note?",
          "createdAt": "2022-08-03T09:04:36Z",
          "updatedAt": "2022-08-03T09:04:36Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I'd delete the note. ",
          "createdAt": "2022-08-03T14:20:15Z",
          "updatedAt": "2022-08-03T14:20:15Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "I_kwDOFUmh7s5PD41X",
      "title": "Section 6: Multiplexing of non-RTP/RTCP data streams and datagrams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/24",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "\"  For multiplexing different RTP and other data streams on the same\r\n   QUIC connection, each RTP/RTCP packet is prefixed with a flow\r\n   identifier.  A flow identifier is a QUIC variable-length integer\r\n   which must be unique per stream...\r\n\r\n   Differentiating RTP/RTCP packets of different RTP sessions from non-\r\n   RTP/RTCP datagrams is the responsibility of the application by means\r\n   of appropriate use of flow identifiers and the corresponding\r\n   signaling.\"\r\n\r\n[BA] This text is a bit vague with respect to setup of non-RTP/RTCP data streams and datagrams.\r\n\r\nAs an example, in WebRTC it is possible to [create additional data channels without signaling](https://w3c.github.io/webrtc-pc/#rtcdatachannel). \r\n\r\nHow would equivalent functionality be supported in RTP over QUIC? For example, one might assume that the desire to exchange data is negotiated, but once done, that a non-RTP/RTCP data stream or datagrams could then be received.  How are these non-RTP/RTCP data streams or datagrams distinguished from RTP/RTCP?  Do we examine the first octet as per RFC 7983bis or is some other multiplexing mechanism used? ",
      "createdAt": "2022-08-02T21:30:21Z",
      "updatedAt": "2023-01-18T16:22:10Z",
      "closedAt": "2023-01-18T16:22:09Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Initially, the idea was to require the flow identifier in every datagram sent on the QUIC connection, allowing the receiver to demultiplex based on the flow identifier. However, that may require some signaling to map flow identifiers to protocols, and as you rightly point out, it may be desired to open new channels without additional signaling, and the flow identifier could also conflict with other protocol mappings to QUIC streams/datagrams.\r\n\r\nI think this is also related to #31. Depending on what ALPN we define in this document and which combinations of protocols this ALPN includes, we may have different multiplexing requirements.\r\n\r\nThe easiest case would probably be an ALPN like \"rtp-quic\" that identifies RTP over QUIC without multiplexing additional non-RTP/RTCP protocols. In that case, we could rely on traditional multiplexing mechanisms for RTP/RTCP, such as RFC 5761 for multiplexing RTP and RTCP or RFC 8860 for sending multiple types of media in a single RTP session. However, I think both RFCs have some limitations that a flow identifier could potentially solve at the cost of some bytes.\r\n\r\nMultiplexing RTP/RTCP and other protocols will be more complicated. One solution could be RFC 7983bis. RFC 7983bis may not work if RTP/RTCP packets are prepended with a flow identifier, which may be solved by prepending the flow identifier with another byte that takes a value that does not yet match any other protocol in RFC 7983bis. But I am not sure if RFC 7983bis is what we need here, given that something like data channels could run directly in QUIC and would not necessarily need to be encapsulated in SCTP/DTLS over QUIC.\r\n\r\nIf we leave multiplexing of multiple protocols to future documents with a separate ALPN in #31, we could also leave the specifics of how the multiplexing works to those documents. In that case, it might be valuable to add a *Multiplexing Guidelines* section to this document.",
          "createdAt": "2022-09-19T14:39:56Z",
          "updatedAt": "2022-09-19T14:39:56Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Resolved in #54 ",
          "createdAt": "2023-01-18T16:22:09Z",
          "updatedAt": "2023-01-18T16:22:09Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "I_kwDOFUmh7s5PD5ch",
      "title": "Section 6.1: RTP topologies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/25",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "      *Editor's Note:* Note, however, that using a single frame per\r\n      stream in a single RTP packet may cause interworking issues when a\r\n      translator wants to forward packets received via RTP-over-QUIC to\r\n      an endpoint as UDP packets because the received ADUs may exceed\r\n      the MTU size or even maximum UDP packet size.\r\n\r\n[BA] This (and other aspects, such as lack of multicast support) has implications for the [supportable RTP topologies](https://datatracker.ietf.org/doc/html/rfc7667). There is also the issue of RTCP interworking. Are there specific topologies that are not supported for use with RTP over QUIC? ",
      "createdAt": "2022-08-02T21:33:54Z",
      "updatedAt": "2022-10-24T15:26:29Z",
      "closedAt": "2022-10-24T15:26:29Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "The introduction currently limits RTP over QUIC to unicast topologies:\r\n\r\n> The scope of this document is limited to unicast RTP/RTCP.\r\n\r\nWe may need to re-evaluate multicast topologies if [QUIC multicast](https://datatracker.ietf.org/doc/draft-jholland-quic-multicast/) becomes available.\r\n\r\nI think most of the non-multicast topologies should be supportable with a few constraints. Whenever a middlebox like a translator needs access to the RTP packet, the QUIC connection must be terminated at the middlebox. I think RTP over QUIC can also support the case described in the note if the translator can rewrite the RTP packets to smaller ones.\r\n\r\nShould we add a new section to explain these limitations?",
          "createdAt": "2022-09-20T08:13:18Z",
          "updatedAt": "2022-09-20T08:13:18Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Adding a section to explain the limitations would make sense. \r\n\r\nHaving a middlebox packetizing frames is complex, because RTP packetization is codec-specific.  Some MANEs do this today (e.g. in order to adjust to MTU differences), but typically those MANEs only support a single codec. ",
          "createdAt": "2022-09-20T18:56:41Z",
          "updatedAt": "2022-09-20T18:56:41Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOFUmh7s5PD7AB",
      "title": "Section 9.2: Disabling QUIC Congestion Control",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/26",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "   *  _Disable Congestion Controller_: If congestion control is to be\r\n      implemented at the application layer as described in Section 8.2,\r\n      and the application layer is trusted to apply adequate congestion\r\n      control, it is RECOMMENDED to allow the application to disable QUIC\r\n      layer congestion control entirely.\r\n\r\n[BA] In terms of the overall requirements, you might cite RFC 9002 Section 7, which says: \r\n\r\n\"If a sender uses a different controller than that specified in this\r\n   document, the chosen controller MUST conform to the congestion\r\n   control guidelines specified in [Section 3.1 of [RFC8085]](https://datatracker.ietf.org/doc/html/rfc8085#section-3.1).\"",
      "createdAt": "2022-08-02T21:42:31Z",
      "updatedAt": "2022-09-23T07:19:09Z",
      "closedAt": "2022-09-23T07:19:09Z",
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOFUmh7s5PD77e",
      "title": "Section 9.2: Choosing an appropriate congestion control algorithm",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/27",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"   *  _Select Congestion Controller_: If congestion control is to be\r\n      implemented at the QUIC connection layer as described in\r\n      Section 8.1, the application must be able to choose an appropriate\r\n      congestion control algorithm.\"\r\n\r\n[BA] Is the need to choose an appropriate algorithm, or to be able to provide information on what characteristics are desired? \r\nRelated: https://github.com/w3c/webtransport/issues/365",
      "createdAt": "2022-08-02T21:47:52Z",
      "updatedAt": "2022-10-24T15:00:35Z",
      "closedAt": "2022-10-24T15:00:35Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "If we decide to state the characteristics in section 8.1 instead of specific algorithms, as discussed in #21 and #36, I think we can leave it to the implementation to decide what the concrete API should look like. I think some QUIC implementations allow choosing between algorithms, but I could also imagine an implementation that lets the application provide information that the QUIC implementation can use to make a decision. Maybe we can change the wording to something like this:\r\n\r\n```\r\nIf congestion control is to be implemented at the QUIC connection (layer as\r\ndescribed in Section 8.1), the QUIC implementation SHOULD expose an API to\r\nconfigure the congestion control algorithm.\r\n```",
          "createdAt": "2022-09-12T16:10:54Z",
          "updatedAt": "2022-09-12T16:10:54Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "In WebTransport, the approach taken has been to provide a \"hint\" to the QUIC stack which would allow it to select an appropriate congestion control algorithm.  There is no implementation of this yet.  That approach was selected over more detailed configuration of the congestion control algorithm. ",
          "createdAt": "2022-09-20T18:52:31Z",
          "updatedAt": "2022-09-20T18:52:31Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think that makes sense for WebTransport, but I am not sure we need to be specific about this here. For example, a QUIC implementation that only offers a low latency congestion controller would be fine, even if it does not provide any configuration options to the application. It may be more useful not to phrase this as what the application can control, but rather as how the QUIC implementation must do congestion control.",
          "createdAt": "2022-09-29T10:44:11Z",
          "updatedAt": "2022-09-29T10:44:11Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOFUmh7s5PImlZ",
      "title": "SFrame/SPacket",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/29",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "question",
        "wontfix",
        "NotJustRTP",
        "external doc"
      ],
      "body": "The spec does not currently describe how [SFrame](https://datatracker.ietf.org/doc/draft-ietf-sframe-enc/) is supported in RTP over QUIC, or what an RTP translator should do. One way to address this would be to add a section that would deal with the issues that come up when implementing [SFrame](https://datatracker.ietf.org/doc/draft-ietf-sframe-enc/) in RTP over QUIC.",
      "createdAt": "2022-08-03T18:56:51Z",
      "updatedAt": "2023-10-16T14:37:33Z",
      "closedAt": "2023-10-16T14:37:33Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I may be missing some background on SFrame/SPacket, but as far as I understand the document you linked, SFrame tries to be independent of the underlying transport, so I don't understand why the RTP over QUIC document should cover its usage. Could you explain why SFrame should only be used with QUIC streams and SPacket only in QUIC datagrams?",
          "createdAt": "2022-09-19T10:41:40Z",
          "updatedAt": "2022-09-19T10:41:40Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "SFrame encrypts an entire frame, making it opaque.\r\n\r\nThis creates problems for an RTP translator.  Since the RTP translator cannot know what is inside the SFrame (since it typically will not have access to the encryption key), it cannot re-packetize the SFrame in a codec-specific way.  This problem can arise if the SFrame is transported using RTP over a reliable QUIC stream and it is desired to translate to RTP over UDP.",
          "createdAt": "2022-09-20T18:48:53Z",
          "updatedAt": "2022-11-07T01:28:30Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> if the SFrame doesn't need to be packetized (e.g. it is put into a QUIC stream) this is not an issue.\r\n\r\nThe frame would still be packetized in RTP packets in both QUIC datagrams and streams. The RTP packet size in a QUIC stream may be much larger (containing the entire frame instead of just one fragment), and each stream can only be used for one RTP packet.\r\n\r\nIf I understand it correctly, RTP over QUIC (Datagrams and Streams) would have the same support (and issues) for SFrame/SPacket as RTP over UDP?",
          "createdAt": "2022-09-21T11:37:55Z",
          "updatedAt": "2022-09-21T11:37:55Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "There are issues with the implementation of RTP translation between RTP over QUIC and RTP/UDP, regardless of whether RTP over QUIC uses QUIC reliable streams or datagrams: \r\n\r\n1. When RTP over QUIC is transported in a QUIC reliable stream, the MTU size is much larger than the RTP over UDP MTU.  So the RTP/QUIC payload needs to be re-packetized to be sent over RTP/UDP. \r\n\r\n2. When RTP/UDP is translated to RTP over QUIC datagrams, there can also be a re-packetization issue. If the UDP MTU is larger than the QUIC datagram MTU, then re-packetization would be required or else oversize RTP over QUIC datagrams would be fragmented. \r\n\r\nSFrame complicates these issues further since the RTP payloads are opaque, and are thus not amenable to codec-specific re-packetization. ",
          "createdAt": "2022-11-07T01:33:25Z",
          "updatedAt": "2022-11-07T01:34:43Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Related: https://github.com/pthatcher/sframe-over-rtp-over-quic-draft/blob/main/draft-pthatcher-sframe-over-rtp-over-quic.txt",
          "createdAt": "2022-11-07T01:38:12Z",
          "updatedAt": "2022-11-07T01:38:12Z"
        },
        {
          "author": "pthatcher",
          "authorAssociation": "NONE",
          "body": "I tried to explain the issue in the draft I wrote to solve this. \r\n\r\nThe gist is that the problem is when a translator has larger RTP packets on one side smaller RTP packets on the other.   QUIC streams allow for very large RTP packets, and the translator has to deal with that.  The RTP-over-QUIC document says that the solution is to use \"codec-specific packetization\", but when SFrame encrypts the codec, it effectively becomes the codec, so you need, basically, an SFrame-specific way to repacketize a large RTP packet containing SFrame into smaller RTP packets containing SFrame.   SPacket doesn't help because we're talking about large RTP packets, and SPackets will still have the same problem.  \r\n\r\nSo what I wrote in the draft Bernard just linked to is a mechanism to repacketize a large RTP packet containing SFrame (or SPacket; that works too) into smaller RTP packets containing SFrame (or SPacket).\r\n\r\nIt also discusses and supports the other direction: turning many smaller RTP packets back into one large RTP packet (translating the other way).",
          "createdAt": "2022-11-07T14:43:17Z",
          "updatedAt": "2022-11-07T14:43:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @pthatcher, @mengelbart and I think this question is being handled as generic for RTP, not for RTP-over-QUIC, and the relevant Githubs (draft-pthatcher-sframe-over-rtp-over-quic and draft-codec-agnostic-rtp-payload-format) are where this will be worked out. Is that also your understanding? ",
          "createdAt": "2023-03-09T16:42:28Z",
          "updatedAt": "2023-03-09T16:42:28Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @SpencerDawkins have reflected on this issue several times, and we are thinking \r\n\r\n- there's not much we can say in the RoQ draft that is specific to RoQ - whatever one does with RTP in SFrames would be the same with RTP over QUIC in SFrames\r\n- we would love to be able to repacketize SFrames (especially if there is a problem with PMTU size), but that's not RoQ-specific, either\r\n- RoQ does include a length field, so that an endpoint can do something about that, if it needs to. \r\n\r\nWe're happy to listen to reason, and closed issues can be reopened in GitHub, but we're closing this one, for now. ",
          "createdAt": "2023-10-16T14:37:06Z",
          "updatedAt": "2023-10-16T14:37:06Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOFUmh7s5PLdfS",
      "title": "ALPN for sharing a connection between RTP/RTCP and other protocols",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/31",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "SDP"
      ],
      "body": "One of the advantages of RTP over QUIC is the possibility to multiplex different protocols on the same connection. A simple use case for this is to share a single QUIC connection between a media session using RTP and some non-RTP data transfer, similar to WebRTC Data Channels. *draft-ietf-avtcore-rtp-over-quic* specifies a minimal application usage of QUIC for RTP. The draft defines an ALPN token (\u201crtp-mux-quic\u201d) because QUIC requires the usage of a mechanism to agree on an application layer protocol, and ALPN is the currently specified way of doing this using TLS. Other application usages of QUIC will have to define their own ALPN token, which implies that they must use a different QUIC connection from RTP over QUIC.\r\n\r\nWe currently see two possible ways to allow usage of RTP and other protocols multiplexed on the same QUIC connection:\r\n\r\n* Define a generic ALPN (e.g. \u201crtp-mux-sdp\u201d), which indicates that the application protocols to be carried in this connection are to be negotiated out of band (SDP). The problem with this approach is that we cannot define the actual multiplexing of the two protocols.\r\n* Explicitly state in the RTP over QUIC draft that future documents are allowed to define new ALPNs that identify protocols for multiplexing RTP over QUIC with other protocols. For example, an ALPN \u201crtp-mux-h3\u201d could be defined in a document that defines how RTP and HTTP/3 can be multiplexed in one QUIC connection. This document could reference the RTP over QUIC document but would have to explain how to multiplex the different protocols.\r\n\r\nOf course, these two options are not mutually exclusive.",
      "createdAt": "2022-08-04T10:20:26Z",
      "updatedAt": "2023-01-18T16:24:02Z",
      "closedAt": "2023-01-18T16:24:01Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "For an example of how this can be handled, see [RFC 8833](https://www.rfc-editor.org/rfc/rfc8833.html), which defines the ALPN registration for WebRTC.  The document defines two ALPNs, each of which supports multiplexing of both data and media. At no point does the document mention SDP. Looking at that document, something simple like \"rtp-mux-quic\" might be fine.\r\n\r\nMultiplexing of RTP-over-QUIC and HTTP/3 would be quite a complex exercise, because this would pull in interactions with HTTP/3 pooling, where multiple applications can interact.  As you've noted, RTP-over-QUIC has unique congestion control requirements which QUIC implementations used with HTTP/3 might not comply with (e.g. BBRv1). ",
          "createdAt": "2022-08-05T18:35:06Z",
          "updatedAt": "2022-08-05T18:35:06Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think RFC 8833 would be an example of the second option, where a separate document defines an ALPN for multiplexing two protocols. I agree HTTP/3 might be very complex and there are better examples that may be easier to define and possibly more useful. I assume we still need an ALPN in the RTP over QUIC document (e.g., \"rtp-quic\"), that can be used to exclusively send RTP and some other document could define an ALPN \"rtp-mux-quic\", for multiplexing RTP and something like data channels.",
          "createdAt": "2022-08-06T22:05:34Z",
          "updatedAt": "2022-08-06T22:05:34Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Not sure you'd need multiple ALPNs here. As an example, applications using WebTransport do not need a separate ALPN for each use case.  Similarly, WebRTC was able to use a single ALPN for both data and media by leveraging RFC 7983. ",
          "createdAt": "2022-09-20T18:40:52Z",
          "updatedAt": "2022-09-20T18:40:52Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think leveraging RFC 7983bis could work, but I am not sure it is what we need. WebRTC uses DTLS/SCTP for data, both of which *I think* we do not need on top of QUIC. But that leaves the question of what protocol will be used on top of QUIC to carry data instead. That's why I thought we could just define one ALPN (\"rtp-quic\") now and maybe later add one or more ALPNs for multiplexing RTP/RTCP and some other (data) protocols on top of QUIC. We could then also define the actual multiplexing similar to RFC 7983.\r\n\r\nI don't think we want to assign an ALPN now that allows multiplexing RTP/RTCP and any other unspecified protocol in the future because it would be unclear how to do the multiplexing.",
          "createdAt": "2022-09-21T08:44:12Z",
          "updatedAt": "2022-09-21T08:44:12Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "#54 solves the multiplexing issue using flow identifiers, which works with the ALPN currently defined in the document.",
          "createdAt": "2023-01-18T16:24:01Z",
          "updatedAt": "2023-01-18T16:24:01Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "I_kwDOFUmh7s5RqgMO",
      "title": "Add current bandwidth estimation to API considerations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/35",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "[Section 8.1](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#section-8.1) explains:\r\n\r\n> If congestion control is done by the QUIC implementation, the application needs a mechanism to query the currently available bandwidth to adapt media codec configurations. The employed congestion controller of the QUIC connection SHOULD expose such an API to the application.\r\n\r\nbut the API considerations in [Section 9.1](https://www.ietf.org/archive/id/draft-ietf-avtcore-rtp-over-quic-00.html#section-9.1) do not include such an API.",
      "createdAt": "2022-09-12T15:25:38Z",
      "updatedAt": "2022-09-22T08:50:13Z",
      "closedAt": "2022-09-22T08:50:13Z",
      "comments": []
    },
    {
      "number": 39,
      "id": "I_kwDOFUmh7s5SPx3a",
      "title": "Length field",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/39",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "      *Editor's Note:* We considered adding a framing like the one\r\n      described in [RFC4571] to send multiple RTP packets on one stream,\r\n      but we don't think it is worth the additional overhead only to\r\n      reduce the number of streams.  Moreover, putting multiple ADUs\r\n      into a single stream would also require defining policies when to\r\n      use the same (and which) stream and when to open a new one.\r\n\r\n[BA] The Length field isn't just for sending multiple RTP packets on one stream.  If the sender implements partial reliability, it may set a timer and then send a RESET_STREAM frame if the timer expires, in order to ensure against excessive retransmissions.  In that case, the receiver may only receive a portion of the frame, and the length field can enable it to determine that the frame was not completely received and should be discarded.  Also, the length field can be useful in memory allocation (e.g. a buffer can be allocated based on the expected length). \r\n\r\nI would also note that the 16-bit length defined in RFC 4571 was designed to be large enough to cover RTP packets, not entire frames sent in RTP over QUIC streams.  So if a length field is to be used in RTP over QUIC, it would either need to be larger (e.g. 32 bits) or if kept at 16 bits, could be used to denote the length in units of 4 octets.  ",
      "createdAt": "2022-09-20T19:04:35Z",
      "updatedAt": "2022-10-24T15:16:14Z",
      "closedAt": "2022-10-24T15:16:14Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "RESET_STREAM frames contain the final size of the stream, so the receiver can determine if the frame was completely received or not. But a length field may be helpful for the receiver to calculate how much data is still missing and to determine whether it is worth waiting longer before sending a STOP_SENDING frame.\r\n\r\nAn alternative for the 16-bit length field could also be to use a [variable-length integer](https://www.rfc-editor.org/rfc/rfc9000.html#section-16) as we did for the flow ID.",
          "createdAt": "2022-09-21T07:52:48Z",
          "updatedAt": "2022-09-21T07:52:48Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I just realized that the final size contained in a RESET_STREAM frame is not the size of the frame, but the\r\n\r\n> amount of flow control credit that is consumed by a stream\r\n\r\n[Section 4.5 of RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html#section-4.5), so the receiver cannot use it to determine if a frame was completely received or not.\r\n\r\nSorry for the confusion.",
          "createdAt": "2022-09-23T08:25:49Z",
          "updatedAt": "2022-09-23T08:25:49Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I added the length field in #43 ",
          "createdAt": "2022-10-24T15:16:14Z",
          "updatedAt": "2022-10-24T15:16:14Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "I_kwDOFUmh7s5Sdo7k",
      "title": "Consider allowing mixing of QUIC streams and datagrams within RTP sessions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/41",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "> This specification defines two ways of carrying RTP packets in QUIC: 1) using reliable QUIC streams and 2) using unreliable QUIC DATAGRAMs. Every RTP session MUST choose exactly one way of carrying RTP and RTCP packets, different RTP sessions MAY choose different ways\r\n\r\nThe restriction to choosing exactly one way of carrying packets was added to avoid any unexpected outcomes of sending some RTP packets reliably on QUIC streams and others unreliably in QUIC datagrams.\r\n\r\nIt may however be desired to allow mixing streams and datagrams to implement partial reliability. For example, a sender may want to send I-frames of a video stream in QUIC streams to ensure reliable delivery, while sending P-frames in datagrams. Another scenario might be to send base layers of a stream using scalable video in QUIC streams and any additional layers in QUIC datagrams.",
      "createdAt": "2022-09-23T09:02:45Z",
      "updatedAt": "2022-10-24T14:30:04Z",
      "closedAt": "2022-10-24T14:30:04Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "As you mention, there are several use cases for using both QUIC streams and datagrams. \r\n\r\nWith SVC, base layer packets may represent a minority of the packets sent (as little as 25 percent with L1T3).  Since the base layer packets depend on each other, and losing one may prevent decoding of subsequent frames at all layers, losing a base layer frame has a high cost (e.g. keyframe generation).  \r\n\r\nTo avoid this cost, it may be necessary to set partial reliability timers considerably higher for base layer frames than for \"discardable\" extension layers.  In such a situation, sending base layer frames via frame/stream may not be that different from sending base layer frames over a single unidirectional stream. \r\n",
          "createdAt": "2022-10-04T03:04:34Z",
          "updatedAt": "2022-10-04T03:04:34Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I will bring this up in the meeting today. My general impression is that it is something that we should support. We were hesitant about this in the beginning because we were unsure of the potential problems this could bring up. When experimenting with this setup I ran into a synchronization issue where P-frames arrived before the first I-frame because the implementation prioritized sending datagrams first. This is solvable by having a jitter buffer wait for the first I-frame before passing anything to a decoder, but there may be other problems we haven't thought of yet.\r\n\r\n> To avoid this cost, it may be necessary to set partial reliability timers considerably higher for base layer frames than for \"discardable\" extension layers. In such a situation, sending base layer frames via frame/stream may not be that different from sending base layer frames over a single unidirectional stream.\r\n\r\nI think allowing multiple frames/ADUs per frame may be a follow-up discussion of #39?",
          "createdAt": "2022-10-04T08:43:29Z",
          "updatedAt": "2022-10-04T08:43:29Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "I_kwDOFUmh7s5TPau_",
      "title": "Interoperability between RTP over QUIC streams and plain RTP",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/42",
      "state": "CLOSED",
      "author": "murillo128",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "If I understood the draft correctly, basically when sending a frame with RTP over QUIC using streams, it will be \"packetized\" considering the MTU being infinite, that is, the whole frame would be sent as payload of the RTP packet (while still adhering to RTP packetization rules, I assume).\r\n\r\nThis would cause issues when trying to do a gateway that bridges between \"normal\" RTP and the QUIC stream version, as it will have to packetize/depacketize the whole frame again.\r\n\r\nOne potential solution is to still generate multiple RTP packets per frame and send them using RFC4571 over a single QUIC stream:\r\n\r\n```\r\n|len 1|RTP Packet1|len 2|RTP Packet2|...|len n|RTP PacketN|\r\n```\r\n\r\nThis would solve the interoperability issues, although will have a higher bandwdith overhead. ",
      "createdAt": "2022-10-04T16:30:12Z",
      "updatedAt": "2022-10-26T05:14:12Z",
      "closedAt": "2022-10-24T15:35:27Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I believe there are two sets of interop issues: \r\n\r\n1. - Interop between RTP over QUIC datagrams and RTP over UDP\r\n2. - Interop between RTP over QUIC frame/stream transport and RTP over UDP\r\n\r\nMTU issues can arise in either case. For example, RTP over QUIC datagrams may have a smaller MTU than RTP over UDP so RTP/UDP packets might need to be repacketized into multiple RTP/QUIC datagrams. \r\n\r\nTo enable a translator to operate without repacketization (which could require codec-specific knowledge), the RTP/UDP MTU needs to be set smaller, so as to allow the translated RTP/QUIC datagrams to stay within the MTU. \r\n\r\nSimilarly, RTP/QUIC stream transport could be configured with a non-infinite MTU, so as to allow a translator to translate to RTP/UDP without repacketizing.",
          "createdAt": "2022-10-15T22:35:16Z",
          "updatedAt": "2022-10-15T22:35:16Z"
        },
        {
          "author": "murillo128",
          "authorAssociation": "NONE",
          "body": "What is QUIC datagram overhead? i doubt #1 will ever be an issue in real life, while i doubt that QUIC over stream will be configured for non-infinite MTU as it defeat the whole pourpose of using streams.",
          "createdAt": "2022-10-15T23:50:26Z",
          "updatedAt": "2022-10-15T23:50:26Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "The RTP Topologies section is there to describe topologies, issues and potential solutions.  The topologies include use cases such as conferencing where the SFU and browser clients could be designed to work together. \r\n\r\nIn a use case where the conferencing server wants to support both RTP over QUIC and RTP/UDP clients, how can this be accomplished? In such a use case, the topology section needs to think about not only what a client should send, but also what it would need to be able to receive. \r\n\r\nIf the conferencing server is an SFU and is willing to parse the payload, it can re-packetize from RTP over QUIC streams to RTP/UDP.  But it may not want to do this.  For example, if the SFU wants to support multiple codecs (e.g. VP8, VP9, H.264, AV1) it might want to handle forwarding in a generic way rather than include code to parse each codec. \r\n\r\nTo be able to enable the SFU to do generic forwarding, the client can either configure a non-infinite MTU for RTP over QUIC streams or can send RTP over QUIC datagrams. Clients that only support RTP/UDP (e.g. browsers that only support WebRTC) could be handled by translating to RTP over QUIC streams if the alternative (RTP over QUIC datagrams) would result in fragmentation. ",
          "createdAt": "2022-10-16T00:37:32Z",
          "updatedAt": "2022-10-16T00:37:32Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I opened #43 to add a length field and allow multiple RTP packets per stream as you suggested, @murillo128.\r\n\r\nOne feature I removed by doing this is the ability of a receiver to request to cancel a stream by sending a `STOP_SENDING` frame, if the receiver knows that a packet is no longer needed. This doesn't work, if there are other packets following on the same stream and the receiver does not know if those are still required. We could add it back if we still require senders to open new streams for each ADU, but since they might be fragmented into multiple RTP packets, I am not sure if it is worth keeping this restriction only to enable receivers to cancel streams.\r\n\r\nWhat do you think about this?\r\n\r\n\r\n@aboba I agree that RTP over QUIC Datagrams and RTP over UDP may still lead to interop issues, but I don't know if there is anything we can do about it except to document it in the topology section?",
          "createdAt": "2022-10-17T10:40:34Z",
          "updatedAt": "2022-10-17T10:40:34Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I merged #43, which adds the length field and allows multiple packets per stream, and added an issue for the `STOP_SENDING` frame problem (#45). I also documented the second MTU interop issue in the new topology section. Closing this issue for now, but feel free to reopen or create new issues if I missed something.",
          "createdAt": "2022-10-24T15:35:27Z",
          "updatedAt": "2022-10-24T15:35:27Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I think that the important thing is to be clear about what topologies are tractable and which are more difficult.  Conferencing servers are quite different from generic translators; the former often have the codec-specific knowledge to re-packetize, whereas translators do not.  ",
          "createdAt": "2022-10-26T05:14:12Z",
          "updatedAt": "2022-10-26T05:14:12Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOFUmh7s5Usx1W",
      "title": "Receiver can't request stream cancellation vie STOP_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/45",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim",
        "NotJustRTP"
      ],
      "body": "In #43 we added a length field to RTP packets that are sent over QUIC streams and allowed multiple packets per stream. Until now, it was possible for a receiver to request cancellation of a stream, if a packet is not needed anymore, e.g., because a deadline has passed. \r\n\r\nNow, since the receiver does not know how many packets to expect on a stream, it cannot know if it is safe to request cancellation, because the following packets may still be relevant.\r\n\r\nOne possible solution is to go back to one Application Data Unit (ADU) (e.g., one media frame) per stream, while still allowing this ADU to be fragmented into multiple RTP packets. ",
      "createdAt": "2022-10-24T15:32:06Z",
      "updatedAt": "2023-05-18T09:02:53Z",
      "closedAt": "2023-05-18T09:02:53Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "We need to be careful about ascribing meaning to STOP_SENDING since the interpretation could differ depending on what is being sent on the stream. If a new stream is sent for each frame, then STOP_SENDING would imply cancelling reception of one and only one frame. But if  SVC layers are sent on different streams, does a STOP_SENDING imply cancelling the sending of the layer sent on that stream?  Or if all frames are sent on a single stream, does STOP_SENDING mean that it is desired for the sender to pause sending that stream?\r\n\r\nUsing RTCP messages might be less ambiguous. ",
          "createdAt": "2023-02-23T23:13:46Z",
          "updatedAt": "2023-04-14T15:56:02Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "That is an interesting feature that I didn't think about before. Does it require some signaling to tell the receiver what layers are sent on which stream? How would a sender know when to restart sending the higher layer(s)?\r\n\r\nWhen we discussed this problem in London, there was a tendency to require the sender to close a stream after exactly one ADU. But it is unclear what an ADU is in different payload formats. For some audio codecs, that could lead to streams being closed after each frame containing only a few ms of data. That would then lead to a very large number of new streams. Too many streams could be a problem itself (see also #49), but it may also be unnecessary to transmit each of these audio frames independently.",
          "createdAt": "2023-02-24T09:22:02Z",
          "updatedAt": "2023-02-24T09:22:02Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "The receiver would need to know that the layers were segregated by stream. This could occur because the receiver requested a layer or because the sender set it up that way. If the receiver is getting one-way delay info, it could ask for more layers if the delay was stable and close to the transmission line, indicating low queuing and loss. But without probing, neither sender nor receiver can estimate the bottleneck bandwidth if the rate is well below that. So requesting more layers could result in increasing delays, indicating queue buildup.",
          "createdAt": "2023-02-24T15:06:51Z",
          "updatedAt": "2023-02-24T15:06:51Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "This issue was discussed at IETF116, bringing up more details about the problem. We can drop the text around having `STOP_SENDING` as a feature that can be used to cancel a certain frame or even an SVC layer. However, we should add considerations about how a sender should react to an incoming `STOP_SENDING` frame. `STOP_SENDING` does not include an offset, so if the sender sent more than one media frame on that stream, it does not know which media frame the receiver intended to cancel. Receiving `STOP_SENDING` should not be treated as a request to retransmit any frames, there are RTCP messages for this already. I think the correct way to handle this would be to continue sending new media frames on new QUIC streams but without resending any media frame that was previously transmitted on the stream that received `STOP_SENDING`.\r\n\r\n@LPardue brought up the `CANCEL_PUSH` frame of HTTP/3, which solves a somewhat similar problem in HTTP/3. I am not sure how this could be mapped to RTP since we don't define any control messages so far, and I am not aware of any RTCP messages that could be used instead.\r\n\r\n@martinthomson recently submitted a new [draft for an `ENOUGH` frame](https://datatracker.ietf.org/doc/draft-thomson-quic-enough/) that adds an offset to `STOP_SENDING`. `ENOUGH` could inform the sender at which offset a receiver wants to cancel the stream. This would let the sender know which media frames to retransmit and which parts can be dropped. It would also indicate where to continue sending media on new QUIC streams.\r\n\r\nThe considerations about `STOP_SENDING` should also include an error code (see #76).",
          "createdAt": "2023-04-14T10:25:42Z",
          "updatedAt": "2023-04-14T10:25:42Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Clarifications to STOP_SENDING or RESET_STREAM can be helpful in guiding sender behavior.  But we also need to be clear what RTCP messages can be implied from QUIC semantics and which cannot.",
          "createdAt": "2023-04-14T16:13:43Z",
          "updatedAt": "2023-04-14T16:13:43Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "I_kwDOFUmh7s5ZNaHu",
      "title": "Provide detailed list of supported unicast topologies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/47",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Section 4.1 is an excellent start. I'd like to see a detailed list of supported RFC 7667 topologies in this draft, along with any additional considerations (the size mismatch between QUIC-RTP and UDP-RTP that's already described is a great example of what I'm thinking about).\r\n\r\nFeel free to assign this to me, of course. :wink:",
      "createdAt": "2022-12-14T13:59:05Z",
      "updatedAt": "2023-04-27T06:26:05Z",
      "closedAt": "2023-04-27T06:26:05Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed with @mengelbart and @joerg-ott, this might morph into enough informational guidance about how to use QUIC-RTP to justify splitting it into a separate document, which might or might not update RFC 7667, but that would be a call for @aboba and @JonathanLennox.",
          "createdAt": "2022-12-14T16:01:48Z",
          "updatedAt": "2022-12-14T16:01:48Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> As discussed with @mengelbart and @joerg-ott, this might morph into enough informational guidance about how to use QUIC-RTP to justify splitting it into a separate document, which might or might not update RFC 7667, but that would be a call for @aboba and @JonathanLennox.\r\n\r\nAnd, just like magic, the MUST required for using secure AVP profiles for non-RTP-over-QUIC paths interconnected to RTP-over-QUIC paths popped up. This is no longer informational guidance ... ",
          "createdAt": "2023-03-27T07:41:24Z",
          "updatedAt": "2023-03-27T07:41:24Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "I_kwDOFUmh7s5ZOZj5",
      "title": "Add any other relevant details about what QUIC feedback can replace AVP/AVPF feedback",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/48",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "SDP"
      ],
      "body": "This probably has impacts on SDP, depending on whether one QUIC/RTP endpoint needs to tell the other QUIC/RTP endpoint what feedback to send. ",
      "createdAt": "2022-12-14T16:06:13Z",
      "updatedAt": "2023-04-27T07:19:50Z",
      "closedAt": "2023-04-27T07:05:41Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "RTCP messages to consider include messages defined in RFCs 4585, 5104, 8888 and draft-ietf-avtcore-rtcp-green-metadata.",
          "createdAt": "2023-04-14T18:01:53Z",
          "updatedAt": "2023-04-14T18:01:53Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think 4585, 5104, and 8888 should all be included now, and I created a new issue to track draft-ietf-avtcore-rtcp-green-metadata: #79 ",
          "createdAt": "2023-04-27T07:19:50Z",
          "updatedAt": "2023-04-27T07:19:50Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "I_kwDOFUmh7s5ZOgZC",
      "title": "MAX_STREAMS and frame/stream transport",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/49",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NotJustRTP"
      ],
      "body": "A recent post on the MoQ list relates to the interaction of MAX_STREAMS and frame/stream transport:\r\nhttps://mailarchive.ietf.org/arch/msg/moq/hecXJfwaysqbyp85ZUwAT9I5CM0/\r\n\r\nLooking at the thread and after having done some experiments, there do appear to be scenarios (e.g. conferencing) where a low MAX_STREAMS limit could be exceeded. \r\n\r\nRelated: WebTransport API [Issue 446](https://github.com/w3c/webtransport/issues/446)",
      "createdAt": "2022-12-14T16:21:26Z",
      "updatedAt": "2023-05-18T09:03:04Z",
      "closedAt": "2023-05-18T09:03:04Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "We have been discussing this issue in the W3C WEBTRANSPORT WG.  Even though the MAX_STREAMS limit is cumulative, web browsers continually update the limit, based on the default maximum number of simultaneous streams on a QUIC connection (100 for Chrome).  The maximum number of simultaneous streams in use is determined by the maximum number of RTP streams and the level of concurrency (e.g. how many QUIC streams are simultaneously in use for each RTP stream).  \r\n\r\nThere are some scenarios in a limit of 100 simultaneous QUIC streams can be exceeded.  For example, consider a conference in which there are 50 participants and each RTP stream may have 4 QUIC streams in use at a time (e.g. 4 frames in transit).  This might require a limit of 200+ QUIC streams rather than 100.  ",
          "createdAt": "2023-02-23T23:21:02Z",
          "updatedAt": "2023-02-23T23:21:02Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "The current draft says:\r\n\r\n> Opening new streams for new packets MAY implicitly limit the number of packets concurrently in transit because the QUIC receiver provides an upper bound of parallel streams, which it can update using QUIC MAX_STREAMS frames. The number of packets that have to be transmitted concurrently depends on several factors, such as the number of RTP streams within a QUIC connection, the bitrate of the media streams, and the maximum acceptable transmission delay of a given packet. Receivers are responsible for providing senders with enough credit to open new streams for new packets at any time.\r\n\r\nAs Christian mentioned on the MoQ list, a sender may need additional credits for background streams that are not RTP/RTCP. However, depending on the type of these background streams, they may or may not take some of the credit that is also used for media streams. According to [RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html#name-controlling-concurrency), `max_streams` of 100 means that a sender can open `100 * 4 + first_stream_id_of_type` streams. `first_stream_id_of_type` can either be `2` if the sender is a client or `3` if it is a server (since we are only using unidirectional streams. If the background data transfer also uses unidirectional streams, it may be necessary to rate limit it to avoid the problem that it takes up all the credit all the time.\r\n\r\nThe level of concurrency depends on how the sender decides to use streams. The draft currently allows sending any number of packets on a stream or opening new streams at any time, but this may change (see #45). If the receiver knows the properties of the incoming media streams, how many there are, and how the sender uses QUIC streams, it may be able to calculate how often and by how much it must increase the MAX_STREAMS limit.",
          "createdAt": "2023-03-20T09:53:31Z",
          "updatedAt": "2023-03-20T09:53:31Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "I_kwDOFUmh7s5ZOpbl",
      "title": "QUIC interaction with ICE",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/50",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "SDP",
        "NextDoc",
        "NotJustRTP",
        "external doc",
        "FIN-WAIT"
      ],
      "body": "We need QUIC-ICE in order to support peer-to-peer operation, but some functionalities overlap between ICE and QUIC. For example,\r\n- QUIC validates addresses, and ICE nominates candidate pairs\r\n- QUIC Ping frames and ICE Keepalives\r\nAnd, of course, ICE prioritizes candidate pairs, which QUIC might have opinions about for connection migration. \r\n\r\nThat's probably an incomplete list. But we need to figure this out. ",
      "createdAt": "2022-12-14T16:43:15Z",
      "updatedAt": "2024-02-29T15:15:44Z",
      "closedAt": "2024-02-29T15:15:44Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "QUIC over ICE shipped in a [Chromium Origin Trial in 2019](https://developer.chrome.com/blog/rtcquictransport-api/), and these issues were addressed as follows: \r\n\r\n* QUIC connection migration was not enabled, since this was handled by ICE, just as SCTP migration is not supported in WebRTC data channel. \r\n\r\n* ICE keepalives were implemented, since the socket can be shared (e.g. QUIC, SRTP/SRTCP, DTLS, ZRTP can be multiplexed) and so you can't assume that the keepalives are solely handled by QUIC. \r\n\r\n* For similar reasons, you need both ICE connectivity checks and QUIC address validation. ",
          "createdAt": "2022-12-14T21:34:40Z",
          "updatedAt": "2022-12-14T21:34:40Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins and @mengelbart suspect that the ICE negotiations may belong in another document that this document will reference, saying \"you need an open validate QUIC connection, and if you can't find the other endpoint without ICE, you need to go look at ICE-for-QUIC and come back here when you do have an open valid QUIC connection\". ",
          "createdAt": "2023-06-16T16:40:42Z",
          "updatedAt": "2023-06-16T16:40:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins thinks this is probably the RoQ version of https://github.com/moq-wg/moq-requirements/issues/103, and should probably have the same proposed path forward at this time, which is, for reference, \r\n\r\n> I think the Right Thing To DO is for us to participate in, and gate this issue on, discussion of draft-seemann-quic-nat-traversal-00 and draft-thatcher-p2p-quic-00 in the QUIC working group. @LPardue, is that WRONG?\r\n\r\n> I'll leave this tagged \"Deferred for now\" for now.\r\n\r\nWe don't have \"Deferred for now\" in THIS repo, but we do have \"Not Yet\", so it's probably correctly tagged for now. ",
          "createdAt": "2023-08-11T16:01:36Z",
          "updatedAt": "2023-08-11T16:01:36Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins is taking the action to see what, if anything, the QUIC working group can/will do to add ICE support to the base QUIC protocol, noting that my understanding from @aboba is that this is critical for WebRTC use of RoQ. ",
          "createdAt": "2023-09-01T16:19:00Z",
          "updatedAt": "2023-09-01T16:19:00Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "A complete replacement of ICE by QUIC is probably a long-term project.  But there are a few immediate questions: \r\n\r\na. The overlap between ICE candidate pair selection and QUIC interface selection.  Only one of these is probably needed.\r\nb. The use of QUIC ping for consent freshness versus RFC 7675. \r\n\r\nOther things (possibly handled in an SDP doc)\r\nc. The authentication mechanism. Self-signed certs with hash verification in signaling? \r\nd. It is possible to multiplex more than one RoQ connection on the same socket? ",
          "createdAt": "2023-09-02T01:54:37Z",
          "updatedAt": "2023-09-02T01:58:21Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "(This was actually part of a comment in the wrong issue - sorry! fixed now)\r\n\r\n> I'm thinking we can defer this issue for now and see how [P2P QUIC](https://datatracker.ietf.org/doc/draft-thatcher-p2p-quic/) and/or [Using QUIC to traverse NATs](https://datatracker.ietf.org/doc/draft-seemann-quic-nat-traversal/) progress. Thoughts?",
          "createdAt": "2023-10-23T15:44:35Z",
          "updatedAt": "2023-10-23T15:48:58Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "So, I've re-read the current doc on ICE, and the only place ICE is mentioned is [here](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-impact-of-connection-migrat).\r\n\r\nGiven that the document doesn't describe interactions with, or implications of, using RoQ with ICE, my suggestion for this version of the specification is that we delete the second paragraph in Section 12.1, and consider mentioning this in the Future Work section proposed in #161 - that issue already says we should mention ICE in the new section. ",
          "createdAt": "2024-02-29T03:11:44Z",
          "updatedAt": "2024-02-29T03:11:44Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDOFUmh7s5ZO8vp",
      "title": "Possible use of QUIC multipath?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/51",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "NextDoc",
        "Not Yet",
        "FIN-WAIT"
      ],
      "body": "We can easily imagine usages of QUIC-RTP that would benefit from multipath capabilities. There are likely a number of considerations that we need to think through - for instance, would we provide one path to the application, that uses multiple paths below the application, or would we expect the application to manage multiple paths on its own? \r\n\r\nSome details: \r\n\r\n- [Multipath Extension for QUIC](https://datatracker.ietf.org/doc/draft-ietf-quic-multipath/) is a QUIC working group draft now. \r\n- If we expect QUIC-RTP to use QUIC connection migration, we are already a long way toward a finished specification on how to use MPQUIC. \r\n- [Multipath RTP (MPRTP)](https://datatracker.ietf.org/doc/draft-ietf-avtcore-mprtp/) was adopted as an AVTCORE draft, but expired in 2016, due to lack of cycles for the folks who were working on it. \r\n- If we could resurrect MPRTP, we could provide a capability that RTCP understands. \r\n\r\nThis would need exploration, in order to propose a path forward. ",
      "createdAt": "2022-12-14T17:28:54Z",
      "updatedAt": "2024-02-16T15:48:59Z",
      "closedAt": "2024-02-16T15:48:59Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "If we are talking about RTP over QUIC over ICE (e.g. RTP over P2P QUIC) then we may not need QUIC connection migration, just as WebRTC data channel relied on ICE rather than SCTP connection migration.\r\n\r\nFor RTP over WebTransport, QUIC connection migration might be more interesting, since ICE is not involved.\r\n\r\nThen there is QUIC multipath versus multipath RTP. \r\n\r\n",
          "createdAt": "2022-12-14T21:28:44Z",
          "updatedAt": "2022-12-14T21:28:44Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We've added \"multipath\" to the [motivations section](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-exploiting-multiple-connect), but more details about this in the RoQ specification should probably wait until [Multipath Extension for QUIC](https://datatracker.ietf.org/doc/draft-ietf-quic-multipath/) is at least past WGLC in QUIC. \r\n\r\n, ",
          "createdAt": "2023-10-23T15:54:02Z",
          "updatedAt": "2023-10-23T15:54:02Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this as NextDoc, for a document that would provide guidance about using multiple paths for RoQ.",
          "createdAt": "2024-02-16T15:48:59Z",
          "updatedAt": "2024-02-16T15:48:59Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "I_kwDOFUmh7s5ZPAI7",
      "title": "Possible use of QUIC Multicast? ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/52",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "wontfix",
        "NextDoc"
      ],
      "body": "QUIC does not have a [Multicast Extension for QUIC](https://datatracker.ietf.org/doc/draft-jholland-quic-multicast/) on its plate - this is currently an individual draft. \r\n\r\nIf $SOMEONE could move this draft forward in QUIC, and $SOMEONE could take on working through the details in AVTCORE, we could provide a QUIC-RTP that could support many of the [RFC 7667](https://datatracker.ietf.org/doc/rfc7667/) topologies that are currently out of scope for us. \r\n\r\nNo need for immediate attention to this issue, but it is something to keep in mind, until we decide that it's not. ",
      "createdAt": "2022-12-14T17:39:30Z",
      "updatedAt": "2023-10-16T14:47:13Z",
      "closedAt": "2023-10-16T14:47:13Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "There are no plans to support multicast in WebTransport, so I think we can rule that out. \r\n\r\nAre there any implementations of multicast over raw QUIC?  ",
          "createdAt": "2022-12-14T21:23:07Z",
          "updatedAt": "2022-12-14T21:23:07Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "We haven't discussed this explicitly, but I think we agree that multicast is not something that needs to be addressed in this version of RoQ. It would add a new dependency to an individual draft which contradicts #127, so I suggest we close this as *won't fix*.",
          "createdAt": "2023-10-11T12:57:52Z",
          "updatedAt": "2023-10-11T12:57:52Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins agrees with @mengelbart on closing this issue within the current RoQ draft work. If we do move forward on this, it should definitely be in another (\"follow-on\") document, anyway. ",
          "createdAt": "2023-10-16T14:47:13Z",
          "updatedAt": "2023-10-16T14:47:13Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "I_kwDOFUmh7s5ZQNEi",
      "title": "Review of RTP over QUIC draft (Vidhi Goel)",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/53",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Posted to the AVTCORE WG mailing list: https://mailarchive.ietf.org/arch/msg/avt/BA7LGvYhodx-PnnaKKPj2gcnzBc/\r\n\r\nHello Authors,\r\n\r\nI have read and reviewed draft-ietf-avtcore-rtp-over-quic-01 and below are my comments.\r\n\r\nGeneral comment - I think this draft will be really helpful for developers of real time applications in migrating to QUIC (from UDP and DTLS). The current draft touches on some important aspects such as multiplexing, de-depulication of RTCP feedback fields etc. But it needs some more details and clarifications regarding sections like congestion control, connection migration, multi path capability.\r\n\r\nSpecific comments - I am providing my comments section wise and there are a mix of minor nits, typos and major comments.\r\n\r\nSection 1. - A very big advantage of migrating to QUIC would be connection migration and MPQUIC. I think this should be mentioned in the intro and later described the impact of each of these on RTP. \r\nSection 3. - Current text - Such new media transport protocols may be covered elsewhere, e.g., in the MOQ WG. I don\u2019t think reference to MOQ is needed here. \r\nSection 6. - Multiplexing RTP/RTCP and non RTP (eg. HTTP) - since this will be discussed on Dec 15th interim, I will leave out my comment until a decision has been made.\r\nSection 6.1 - Current text - If it is known to either the sender, that a packet, which was not yet successfully and completely transmitted, is no longer needed.... Typo in the first part where \u201ceither\u201d is not needed.\r\nSection 7. - Typo in the word \u201cadditional\u201d -  QUIC layer to the application instead of exchanging addtional\r\nSection 7.1 - The list of replaceable RTCP reports appears without any pretext before \u201cReceiver Reports\u201d. A simple line that says what is coming next would solve it.\r\n                   - Under Receiver reports->Fractions lost, current text - Later packets SHOULD be ignored, since they may still be in flight, unless other QUIC packets that were sent after the datagram frame,. Why only sent after the datagram frame (and not stream) - maybe reframe the sentence to say RTP packet instead?\r\n\t\t   - Under Receiver reports->Highest Sequence Number received - This field is not clear. It would be clearer if it\u2019d say what does this field mean in RTP and can QUIC provide the exact same feedback from its ACKs.\r\n\t\t   - Negative acknowledgements - Probably make the recommendation clearer that since QUIC can provide all the information that a negative ack provides, there is no need to use RTCP negative Ack.\r\n   \t\t   - ECN feedback - same comment as above, clearly state that reporting of ECN feedback should be done via QUIC instead of RTCP feedback.\r\nSection 7.2 - English nit in current text - A QUIC receiver can also not calculate. Suggestion, Nor can a QUIC receiver calculate..\r\nSection 8 - This section needs some work IMO with regards to,\r\n\t1. What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n\t2. Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n\t3. If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n\r\nSection 10.2 - This is a sub section for impact of connection migration and it would be good to add one for MP QUIC as Multipath offers more benefits than migration. And, both the sections should clearly state if the RTP layer needs to do anything on path change.\r\n\t\t     - This line caught my attention - Application layer congestion control mechanisms (and also packet repair schemes such as retransmissions) need to be prepared to cope with such spikes.  Isn\u2019t this something they already deal with UDP anyway? I wasn\u2019t sure the reason for mentioning this explicitly.\r\n\r\nCommon to the entire draft - I think the word \u201cunreliable\u201d before datagrams doesn\u2019t really add to the value of the draft as we all know datagrams are not retransmitted and the word \u201cunreliable\u201d doesn\u2019t bring anything good to the table. Perhaps that can be removed at some places. The word congestion control is well known in the community but I think most real time drafts use the word \u201crate adaptation algorithm\u201d and that word makes more sense to me than congestion control. Happy to hear what the authors (and others) think.\r\n\r\nI can send out a PR for some of these comments.\r\n\r\nThanks,\r\nVidhi\r\n",
      "createdAt": "2022-12-14T21:20:49Z",
      "updatedAt": "2023-01-23T15:51:33Z",
      "closedAt": "2023-01-23T15:51:33Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @goelvidhi, as you can see, @aboba entered your review comments after the December virtual interim meeting. They are all in this issue, and most of the resolutions should be easy, so I will just respond to them as individual comments here, and they're likely to all end up in one PR. \r\n\r\nAnd thank you for your help!",
          "createdAt": "2023-01-12T20:19:35Z",
          "updatedAt": "2023-01-12T20:19:35Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>Section 1. - A very big advantage of migrating to QUIC would be connection migration and MPQUIC. I think this should be mentioned in the intro and later described the impact of each of these on RTP.\r\n\r\nI have a couple of thoughts. \r\n\r\n- I agree that these advantages are worth mentioning, but one of the major points the authors are working on, is to specify as much as we **need** to specify, without waiting until we specify everything that **can** be specified. I'll mention both of these, without promising that they will be added in the short term.\r\n- QUIC connection migration is included in [RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000#name-connection-migration), but Multipath QUIC is still an [Internet Draft](https://datatracker.ietf.org/doc/html/draft-ietf-quic-multipath-03). It's been adopted by the QUIC working group, but hasn't been WGLCed yet, so perhaps we should wait a bit before including details about how RTP can exploit multipath QUIC capabilities. \r\n\r\nI opened issue #51, and will follow up on this comment when I'm working on that issue. ",
          "createdAt": "2023-01-13T00:33:05Z",
          "updatedAt": "2023-01-16T23:00:27Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment:\r\n\r\n> Section 3. - Current text - Such new media transport protocols may be covered elsewhere, e.g., in the MOQ WG. I don\u2019t think reference to MOQ is needed here.\r\n\r\nSpencer agrees. Making this change now. ",
          "createdAt": "2023-01-13T00:34:02Z",
          "updatedAt": "2023-01-16T16:45:09Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>Section 6. - Multiplexing RTP/RTCP and non RTP (eg. HTTP) - since this will be discussed on Dec 15th interim, I will leave out my comment until a decision has been made.\r\n\r\n@mengelbart has been working on this independently, in #54. Let's track this comment there. ",
          "createdAt": "2023-01-13T00:37:33Z",
          "updatedAt": "2023-01-16T16:48:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>Section 6.1 - Current text - If it is known to either the sender, that a packet, which was not yet successfully and completely transmitted, is no longer needed.... Typo in the first part where \u201ceither\u201d is not needed.\r\n\r\nSpencer agrees. Making this change now.",
          "createdAt": "2023-01-13T00:38:25Z",
          "updatedAt": "2023-01-16T16:49:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 7. - Typo in the word \u201cadditional\u201d - QUIC layer to the application instead of exchanging addtional\r\n\r\nSpencer agrees. Making this change now.",
          "createdAt": "2023-01-13T00:39:15Z",
          "updatedAt": "2023-01-16T19:42:52Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 7.1 - The list of replaceable RTCP reports appears without any pretext before \u201cReceiver Reports\u201d. A simple line that says what is coming next would solve it.\r\n\r\nSpencer agrees. Making this change now.",
          "createdAt": "2023-01-13T00:40:03Z",
          "updatedAt": "2023-01-16T19:43:13Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>- Under Receiver reports->Fractions lost, current text - Later packets SHOULD be ignored, since they may still be in flight, unless other QUIC packets that were sent after the datagram frame,. Why only sent after the datagram frame (and not stream) - maybe reframe the sentence to say RTP packet instead?\r\n\r\nUpon reflection, Spencer suspects that this bullet really is datagram-specific, because QUIC (helpfully? :raised_eyebrow:) retransmits RTP packets carried in QUIC stream. A couple of paragraphs earlier, the text talks about direct mapping understating RTP losses and misstating RTP jitter when QUIC streams are used, and this might be clearer if it's restated in this bullet. \r\n\r\n@mengelbart, could you look at this, and tell me if I'm completely wrong? \r\n\r\nIn the meantime, I'm proposing this text, to make (my understanding of the point) clearer. \r\n\r\n  * *Fraction lost*: When RTP packets are carried in QUIC datagrams, the fraction of lost packets can be directly inferred from\r\n    QUIC's acknowledgments. The calculation SHOULD include all packets up to the\r\n    acknowledged RTP packet with the highest RTP sequence number. Later packets\r\n    SHOULD be ignored, since they may still be in flight, unless other QUIC\r\n    packets that were sent after the RTP packet frame, were already acknowledged.",
          "createdAt": "2023-01-13T00:42:23Z",
          "updatedAt": "2023-01-16T21:15:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment:\r\n\r\n> - Under Receiver reports->Highest Sequence Number received - This field is not clear. It would be clearer if it\u2019d say what does this field mean in RTP and can QUIC provide the exact same feedback from its ACKs.\r\n\r\nI'm proposing this text,\r\n\r\n  * *Highest Sequence Number received*: The highest sequence number received is\r\n    the highest sequence number of all RTP packets carried in a QUIC packet that was acknowledged.",
          "createdAt": "2023-01-13T00:43:12Z",
          "updatedAt": "2023-01-16T21:22:18Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> - Negative acknowledgements - Probably make the recommendation clearer that since QUIC can provide all the information that a negative ack provides, there is no need to use RTCP negative Ack.\r\n\r\nI'm proposing this text.\r\n\r\n  * The generic negative acknowledgment packet contains information about\r\n    packets which the receiver considered lost. {{Section 6.2.1. of !RFC4585}}\r\n    recommends to use this feature only, if the underlying protocol cannot\r\n    provide similar feedback. QUIC does not provide negative acknowledgments,\r\n    but can detect lost packets through acknowledgments based on the Gap numbers contained in QUIC ACK frames.",
          "createdAt": "2023-01-13T00:44:12Z",
          "updatedAt": "2023-01-16T21:31:39Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> - ECN feedback - same comment as above, clearly state that reporting of ECN feedback should be done via QUIC instead of RTCP feedback.\r\n\r\nThe draft currently says this.\r\n\r\n> QUIC\r\n>     supports ECN reporting through acknowledgments. If the connection supports\r\n>     ECN, the reporting of ECN counts SHOULD be done using QUIC acknowledgments.\r\n\r\nIf this isn't clear enough for the reader, I'm proposing this. \r\n\r\n  * ECN feedback packets report the count of observed ECN-CE marks. {{!RFC6679}}\r\n    defines two RTCP reports, one packet type (with `PT=205` and `FMT=8`) and a\r\n    new report block for the extended reports which are listed below. QUIC\r\n    supports ECN reporting through acknowledgments. If the connection supports\r\n    ECN, the reporting of ECN counts SHOULD be done using QUIC acknowledgments,\r\n    rather than RTCP ECN feedback reports.",
          "createdAt": "2023-01-13T00:45:10Z",
          "updatedAt": "2023-01-16T21:49:40Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 7.2 - English nit in current text - A QUIC receiver can also not calculate. Suggestion, Nor can a QUIC receiver calculate..\r\n\r\nSpencer agrees. Making this change now.",
          "createdAt": "2023-01-13T00:46:38Z",
          "updatedAt": "2023-01-16T21:50:43Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 8 - This section needs some work IMO with regards to,\r\n> 1. What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n\r\nI'm not sure what spec we should comply to, but I definitely agree that we should say explicitly that RFC 9002 isn't the only possible spec that makes sense for realtime applications! I'll propose text here. ",
          "createdAt": "2023-01-13T00:49:55Z",
          "updatedAt": "2023-01-13T00:49:55Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 8 - This section needs some work IMO with regards to,\r\n\r\n> 2. Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n\r\nI'll propose text here. ",
          "createdAt": "2023-01-13T00:51:21Z",
          "updatedAt": "2023-01-13T00:51:41Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> Section 8 - This section needs some work IMO with regards to,\r\n> \r\n> 3. If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n\r\nMy opinion, and I'm sure we need to talk about this, is that for realtime media applications intended to run over the Internet, the application needs to do SOMETHING for (as you mention in another commend) rate adaptation. I'd make two observations here. \r\n\r\nFirst, and foremost, we don't have an agreed mechanism for how to tell a QUIC implementation at each end of a QUIC connection that this connection will be used to carry realtime media. Without that, the QUIC implementation has no way of knowing that the connection is not carrying HTTP/3, and we're going to get RFC 9002 behavior (or worse for realtime media, for example, BBF behavior). We should say that. \r\n\r\nSecond, for realtime media applications intended to run outside of controlled environments (as described in [RFC 8085](https://datatracker.ietf.org/doc/html/rfc8085#autoid-22), at a minimum, we can point to discussion about RTP circuit breakers in [RFC 8083](https://datatracker.ietf.org/doc/html/rfc8083).\r\n\r\nI've opened issue #59 to start more specific work on bandwidth estimation, rate adaptation, and congestion control, and will follow up there. ",
          "createdAt": "2023-01-13T01:27:20Z",
          "updatedAt": "2023-01-16T22:56:04Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n>Section 10.2 - This is a sub section for impact of connection migration and it would be good to add one for MP QUIC as Multipath offers more benefits than migration. And, both the sections should clearly state if the RTP layer needs to do anything on path change.\r\n\r\nThis is related to the comment about QUIC connection migration and MP-QUIC made for Section 1, and whatever we say in Section 10.2 should be summarized in Section 1. ",
          "createdAt": "2023-01-13T01:34:29Z",
          "updatedAt": "2023-01-13T01:34:29Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For this comment: \r\n\r\n> - This line caught my attention - Application layer congestion control mechanisms (and also packet repair schemes such as retransmissions) need to be prepared to cope with such spikes. Isn\u2019t this something they already deal with UDP anyway? I wasn\u2019t sure the reason for mentioning this explicitly.\r\n\r\nI think this is related to our discussion of rate adaptation for a previous comment. I'll come back to this comment in #59.",
          "createdAt": "2023-01-13T01:38:39Z",
          "updatedAt": "2023-01-16T22:57:24Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "For these two comments: \r\n\r\n> Common to the entire draft - I think the word \u201cunreliable\u201d before datagrams doesn\u2019t really add to the value of the draft as we all know datagrams are not retransmitted and the word \u201cunreliable\u201d doesn\u2019t bring anything good to the table. Perhaps that can be removed at some places. \r\n>\r\n> The word congestion control is well known in the community but I think most real time drafts use the word \u201crate adaptation algorithm\u201d and that word makes more sense to me than congestion control. Happy to hear what the authors (and others) think.\r\n\r\n1. At a minimum, we can say \"QUIC datagrams, which are unreliable\" once, and remove all other occurrences. @mengelbart and @joerg-ott would know better, but some of this text, or at least some of the thinking behind it, may date back to the days when the QUIC working group was talking about whether they also needed to support reliable datagrams, but these days, I don't think we need to be as careful about saying this clearly. \r\n\r\n2. \"rate adaptation algorithm\u201d works for me, and for @mengelbart.",
          "createdAt": "2023-01-13T01:45:03Z",
          "updatedAt": "2023-01-16T22:53:04Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thank you, Spencer, for preparing a PR!\r\n\r\nI don't know if you intentionally skipped the comments about the fraction lost and the highest sequence number fields of receiver reports, so I just opened two PRs to address these: https://github.com/mengelbart/rtp-over-quic-draft/pull/56 https://github.com/mengelbart/rtp-over-quic-draft/pull/57 (Feel free to ignore them if you already made changes for these, too).",
          "createdAt": "2023-01-13T09:16:00Z",
          "updatedAt": "2023-01-13T09:16:00Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> > Common to the entire draft - I think the word \u201cunreliable\u201d before datagrams doesn\u2019t really add to the value of the draft as we all know datagrams are not retransmitted and the word \u201cunreliable\u201d doesn\u2019t bring anything good to the table. Perhaps that can be removed at some places.\r\n> > The word congestion control is well known in the community but I think most real time drafts use the word \u201crate adaptation algorithm\u201d and that word makes more sense to me than congestion control. Happy to hear what the authors (and others) think.\r\n> \r\n>     1. At a minimum, we can say \"QUIC datagrams, which are unreliable\" once, and remove all other occurrences. @mengelbart and @joerg-ott would know better, but some of this text, or at least some of the thinking behind it, may date back to the days when the QUIC working group was talking about whether they also needed to support reliable datagrams, but these days, I don't think we need to be as careful about saying this clearly.\r\n\r\nMentioning that QUIC datagrams are unreliable once should be enough. The RFC 9221 also has \"unreliable\" in its name, so the reference should make clear that these are unreliable datagrams.\r\n \r\n>     2. \"rate adaptation algorithm\u201d works for me. Does it work for the authors (and, of course, for the working group, but let's start with @mengelbart and @joerg-ott).\r\n\r\n\"rate adaptation algorithm\" works for me when we talk about real-time media. I'd prefer to keep \"congestion control\" when talking about QUIC's congestion control because it is also the term used in RFC 9002.",
          "createdAt": "2023-01-13T09:30:25Z",
          "updatedAt": "2023-01-13T09:30:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - \r\n> I don't know if you intentionally skipped the comments about the fraction lost and the highest sequence number fields of receiver reports, so I just opened two PRs to address these: #56 #57 (Feel free to ignore them if you already made changes for these, too).\r\n\r\nYou're probably learning that I do a lot of stuff UNintentionally. When I read your comment, I instantly remembered that comment, so whoops, my bad. :zany_face: \r\n\r\nThank you for cleaning up after me, and opening these PRs. I'll work on them as well. \r\n\r\n",
          "createdAt": "2023-01-13T14:30:14Z",
          "updatedAt": "2023-01-13T14:30:14Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - \r\n\r\n> Mentioning that QUIC datagrams are unreliable once should be enough. The RFC 9221 also has \"unreliable\" in its name, so the reference should make clear that these are unreliable datagrams.\r\n\r\nThis actually turned out to be two mentions (one in the introduction, which precedes the terminology section, and one in the terminology section. \r\n\r\n",
          "createdAt": "2023-01-16T23:04:51Z",
          "updatedAt": "2023-01-16T23:04:51Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - \r\n\r\n> \"rate adaptation algorithm\" works for me when we talk about real-time media. I'd prefer to keep \"congestion control\" when talking about QUIC's congestion control because it is also the term used in RFC 9002.\r\n\r\nI touched a lot of text with this one - see what you think!\r\n\r\n",
          "createdAt": "2023-01-16T23:06:15Z",
          "updatedAt": "2023-01-16T23:06:15Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDOFUmh7s5bRjMq",
      "title": "Catch up on acknowledgements to date",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/55",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "@mengelbart, I added Vidhi Goel when I was working through her review comments (#53), and (I hope this is OK) alphabetized the names that were already included so we can avoid omissions and duplications as we get more (and more) reviews and comments, but it will be good for you and @joerg-ott to make sure we have everyone who has helped so far. ",
      "createdAt": "2023-01-12T20:32:27Z",
      "updatedAt": "2023-02-20T08:24:09Z",
      "closedAt": "2023-02-20T08:24:09Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Alphabetized sounds good. I have more additions, but I will wait for your PR so we don't create unnecessary merge conflicts.",
          "createdAt": "2023-01-13T09:33:57Z",
          "updatedAt": "2023-01-13T09:33:57Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "I_kwDOFUmh7s5bWHFS",
      "title": "Scoping description for Abstract and Introduction ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/58",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Starting with material in https://notes.ietf.org/k36X3Z4MR_qXbHtI5HTXFA?edit",
      "createdAt": "2023-01-13T15:50:21Z",
      "updatedAt": "2023-02-20T08:46:25Z",
      "closedAt": "2023-02-20T08:46:25Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@joerg-ott put together an excellent first draft for the scope statement, in [HedgeDoc](https://notes.ietf.org/k36X3Z4MR_qXbHtI5HTXFA?edit). I'll start with that, stir, and season. ",
          "createdAt": "2023-01-27T14:56:20Z",
          "updatedAt": "2023-01-27T14:56:20Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOFUmh7s5bhsfr",
      "title": "CC/RA: Explain how to avoid nested congestion controller loops for real time media",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/59",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "The current draft says (in \"Congestion Control at the Application Layer\"), \r\n\r\n> If the application implements full congestion control rather than just a\r\n> bandwidth estimation at the application layer using a congestion controller that\r\n> satisfies the requirements of {{Section 7 of !RFC9002}}, and the connection is\r\n> only used to send real-time media which is subject to the application layer\r\n> congestion control, **it is RECOMMENDED to disable any other congestion control\r\n> that is possibly running at the QUIC layer**. Disabling the additional congestion\r\n> controllers helps to avoid any interference between the different congestion\r\n> controllers.\r\n\r\nWe have talked about this for at least a couple of years, back when \"RTP over QUIC\" was still in the QUIC working group, but as I understand it, there's no way to do this now (in a standardized way), and a plain reading of the emphasized text makes me think what's being described would require a QUIC extension. \r\n\r\nI don't care how we actually do this, but we need to write down how to do it!",
      "createdAt": "2023-01-16T22:31:46Z",
      "updatedAt": "2023-05-16T20:24:56Z",
      "closedAt": "2023-05-16T20:24:56Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Just noting down the points from my email that needs addressing,\r\n\r\n```\r\nSection 8 - This section needs some work IMO with regards to,\r\n1. What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n2. Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n3. If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n```",
          "createdAt": "2023-01-18T00:49:17Z",
          "updatedAt": "2023-01-18T00:49:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "From discussion with @joerg-ott and @mengelbart -\r\n\r\n- this is mostly about how a sending application tells a QUIC implementation what general type of congestion controller the QUIC implementation should use (say, NADA vs NewReno, \"please DON'T use an h3-optimized congestion controller for media\")\r\n- are we expecting the QUIC implementation to figure this out automagically? \r\n- how badly are h3-optimized congestion controllers going to work for application-limited, interactive applications?\r\n- Mathis work shows that rate-limited RTP rarely encounters QUIC limits that bulk transfer traffic would encounter",
          "createdAt": "2023-01-27T16:19:56Z",
          "updatedAt": "2023-01-27T16:19:56Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "This issue is about the proposal to disable QUIC's congestion controller, since a rate-limiting congestion controller is already in use at the application level. ",
          "createdAt": "2023-01-27T16:29:40Z",
          "updatedAt": "2023-01-27T16:29:40Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I replied to @goelvidhi s comments in #62 .\r\n\r\nI agree that the quoted text above is a bit unclear and maybe mixes a few things together that should be separated.\r\n\r\nI think as long as a sender complies to the congestion control requirements of QUIC as stated in RFC 9002/RFC 8085, it does not matter how it is implemented We might want to state this explicitly in the introduction to section 8 (see also #62).\r\n\r\nThe emphasized text above is about disabling one congestion controller when another is active as long as the active congestion controller applies to all outgoing traffic. The idea was to separate between an *RTP layer* and a *QUIC layer* and have the *RTP layer* do congestion control for real-time media. But that only works as long as the *RTP layer* is the only one sending data over the *QUIC layer*. As soon as the QUIC connection is shared between the *RTP layer* and some other datastream, congestion control must be done for both. \r\n\r\n> * this is mostly about how a sending application tells a QUIC implementation what general type of congestion controller the QUIC implementation should use (say, NADA vs NewReno, \"please DON'T use an h3-optimized congestion controller for media\")\r\n> * are we expecting the QUIC implementation to figure this out automagically?\r\n\r\nI don't see how a QUIC extension could help us solve this, but maybe this is rather an API question than a congestion control question?",
          "createdAt": "2023-02-01T12:57:22Z",
          "updatedAt": "2023-02-01T12:57:22Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Maybe we can discuss this issue either here or at #62. The general idea is to talk about the 3 options very clearly,\r\n1. CC/rate adaptation at both QUIC and RTP\r\n2. CC at QUIC only with necessary bandwidth estimation (perhaps other things) feedback provided from QUIC to RTP\r\n3. real time rate adaptation only with some compliance to 8085 - this one is tricky. Is there any existing rate adaptation algorithm that does this? If not, then this option is least preferable.\r\n\r\nI am not sure about the performance of option 1 and 2, so if there is some testing done for these, I would like to see the results. And testing on physical machines is preferable over emulators.\r\n",
          "createdAt": "2023-02-03T19:49:32Z",
          "updatedAt": "2023-02-03T19:51:33Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think there are multiple dimensions in which we can list different options. The first one is the layer at which congestion control is applied, either at the QUIC implementation layer or the application layer on top of QUIC or both. The second is the kind of congestion control used at both layers, which could for example be optimized for low latency or bulk transfer. And then, we have to distinguish between connections that are used for RTP only and connections that are shared between RTP and other non-RTP streams. Trying to break this down I get to something like this:\r\n\r\n### 0. No App CC + No QUIC CC \r\n\r\n  * Forbidden\r\n\r\n### 1. App CC + No QUIC CC\r\n\r\n* a) If only RTP runs on top of the QUIC connection, this can be any real-time rate adaptation that works well with RTP as long as it satisfies RFC 8085 and ideally also RFC 8836.\r\n* b) If RTP and non-RTP data share a QUIC connection, then all application protocols on top of that connection MUST do their own congestion control. It must be ensured that the result is still compliant with QUIC or RFC 8085 and that each stream receives a fair share of the bandwidth, which might be quite hard to get right.\r\n\r\n### 2. No App CC + QUIC CC\r\n\r\n* a) If only RTP runs on top of QUIC, the connection should ideally use a low latency congestion control algorithm and expose an estimated bandwidth to the application for codec configuration. This option looks very similar to 1a) above, because it is only an implementation detail where CC is implemented.\r\n* b) If RTP and non-RTP data share a connection, the congestion controller should assign bandwidth shares such that no stream can starve another.\r\n\r\n### 3. App CC + QUIC CC\r\n\r\n* a) For only RTP, this could be a potential fallback if 1a) and 2a) are not possible, e.g. because QUIC CC cannot do low latency or cannot expose the estimated bandwidth and it cannot be disabled either.\r\n* b) For a shared connection, this could be a potential fallback if 2b) is not possible.\r\n\r\n1a) and 2a) are very similar when we have free choice over which algorithms are used. 2b) seems the best choice for sharing connections. 3a) and 3b) don't seem to have any advantages but might be useful if other options are not available.\r\n\r\nRegarding real-time rate adaptation that is compliant to RFC 8085: I don't know for sure if the algorithms developed in RMCAT are compliant with RFC 8085, but since they were developed for environments that typically use UDP, I would be surprised if they are not. In any case, even if we can't or don't want to reference those algorithms explicitly, I don't think it should stop us from recommending algorithms that are optimized for low latency in general.\r\n",
          "createdAt": "2023-02-06T15:54:58Z",
          "updatedAt": "2023-02-06T15:54:58Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "The discussion that @mengelbart and @goelvidhi have been having for this issue clarifies things quite a bit, even if the discussion mentioned \"disabling QUIC CC\" from time to time. The parts that don't assume that need to be inserted into the document as guidance, which is what we said at the [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore).",
          "createdAt": "2023-03-09T17:23:04Z",
          "updatedAt": "2023-03-09T17:23:04Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOFUmh7s5cdSXl",
      "title": "Distinguish clearly between \"congestion control\" and \"rate adaptation\"",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/61",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "@goelvidhi mentioned this in her document review (sent to the mailing list, entered into #53 by @aboba), and I worked on this in #60, but where I ended up, was \r\n\r\n- it's helpful to distinguish between congestion control in general, and rate adaptation for interactive low-latency media, **but**\r\n- a significant number of RTP-centric specifications (for example, [RFC 8888](https://datatracker.ietf.org/doc/html/rfc8888)) use the term \"congestion control\" to describe what we're calling rate adaptation in this specification. \r\n\r\nI note that [RFC 8298](https://datatracker.ietf.org/doc/html/rfc8298) distinguishes between \r\n\r\n- Network Congestion Control, \r\n- Sender Transmission Control, and \r\n- Media Rate Control. \r\n\r\nSomething like that, early in this document, may be helpful. ",
      "createdAt": "2023-01-20T17:03:04Z",
      "updatedAt": "2023-02-20T08:25:14Z",
      "closedAt": "2023-02-20T08:25:14Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart said (in another review) that he agreed with the suggestion to add definitions for these terms early in the document. Perhaps prematurely, I renamed the Congestion Control section to be Congestion Control and Rate Adaptation in an earlier PR. ",
          "createdAt": "2023-01-23T15:59:19Z",
          "updatedAt": "2023-01-23T15:59:19Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "I_kwDOFUmh7s5cdWMv",
      "title": "QUIC congestion control, real-time congestion control, and (potentially) both, for the same QUIC connection",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/62",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "@goelvidhi had several questions about this interaction in her document review (sent to the mailing list, entered into #53 by @aboba), and it's worth mentioning this in a separate issue. \r\n\r\n- What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n- Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n- If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n\r\nThis is related to, but not the same as, #59 (if you don't want your media treated like H3 payloads, how do you tell the other endpoint that it's real-time media?). ",
      "createdAt": "2023-01-20T17:14:30Z",
      "updatedAt": "2023-03-09T19:38:16Z",
      "closedAt": "2023-03-09T17:13:59Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> * What spec should one comply to for a real time congestion controller? (I don\u2019t think RFC 9002 is the right compliance for real time CCs)\r\n\r\nSince we are running RTP on top of QUIC and one of our goals is not to change or extend QUIC if possible, I would argue that RFC 9002 is at least one of the specs that a congestion controller should comply with. RFC 9002 says:\r\n\r\n> A sender can unilaterally choose a different algorithm to use, such as CUBIC [[RFC8312](https://www.rfc-editor.org/rfc/rfc9002.html#RFC8312)].\r\n>\r\n> If a sender uses a different controller than that specified in this document, the chosen controller MUST conform to the congestion control guidelines specified in [Section 3.1](https://www.rfc-editor.org/rfc/rfc8085#section-3.1) of [[RFC8085](https://www.rfc-editor.org/rfc/rfc9002.html#RFC8085)].\r\n\r\nwhich is reflected in the current draft in section 8. The section references RTP congestion control mechanisms but doesn't define any requirements. I would suggest adding [RFC 8836 (Congestion Control Requirements for Interactive Real-Time Media)](https://datatracker.ietf.org/doc/rfc8836/) here.\r\n \r\n> * Is bandwidth estimation the only thing needed by media codecs or does QUIC CC need to do more than that?\r\n\r\nI don't think there is anything that a media codec needs from a congestion controller. Calculating a bandwidth estimation helps because it allows the codec to produce media at a rate close to the maximum rate at which data can be transmitted to the receiver in real time. There may be more detailed signals available to improve the experience at the receiver, e.g., by changing the resolution or generating a new key fream, but I don't think this is the responsibility of congestion control.\r\n\r\n\r\n> * If a real time CC can\u2019t comply to 1., does it need to use both real time CC as well as QUIC CC?\r\n\r\nIf a congestion controller does not comply with 1., it would be violating the QUIC specification. I think it is important that a sender complies with RFC 9002/RFC 8085 and RFC 8836 for real-time data, and using both congestion controllers might be a solution, although it might not be the best thing to do.\r\n\r\nShould we add some text to state more clearly, that a sender is expected to comply to the mentioned specifications?",
          "createdAt": "2023-02-01T12:38:28Z",
          "updatedAt": "2023-02-01T12:38:28Z"
        },
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "Adding the specs to comply isn't a problem, its just that if QUIC CC is disabled, we have to make sure that it is feasible for the real time rate adaptation algorithm to comply to 8085. Does any of the current algorithms (Scream, NADA) reference 8085?",
          "createdAt": "2023-02-03T19:43:50Z",
          "updatedAt": "2023-02-03T19:43:50Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @goelvidhi - My understanding of the comments for this issue is that they all revolve around what we do if QUIC CC is disabled, and the guidance we have from the [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore) is **\"don't do that\"**. I think we can close this one. ",
          "createdAt": "2023-03-09T17:13:59Z",
          "updatedAt": "2023-03-09T17:13:59Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I agree with \"don't do that\", if \"QUIC CC is disabled\" means no congestion control is being done.\r\n\r\nIt might be helpful to have some definitions of terms like \"QUIC CC\", \"RTP CC\", \"Real-time CC\", etc. I tried to do that in https://github.com/mengelbart/rtp-over-quic-draft/issues/59#issuecomment-1419312129, because I think a lot of confusion comes from the different interpretations of these terms. \"QUIC CC\" might be used as \"the congestion controller running in the QUIC implementation\" or as \"the reno-like algorithm defined in RFC 9002\". Similarly, \"Real-time CC\" could mean \"congestion controller implemented in an application sending RTP\" or it might be used to reference a specific algorithm like SCReAM, NADA, or BBR.",
          "createdAt": "2023-03-09T17:38:25Z",
          "updatedAt": "2023-03-09T17:38:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agree with \"don't do that\", if \"QUIC CC is disabled\" means no congestion control is being done.\r\n> \r\n> It might be helpful to have some definitions of terms like \"QUIC CC\", \"RTP CC\", \"Real-time CC\", etc. I tried to do that in [#59 (comment)](https://github.com/mengelbart/rtp-over-quic-draft/issues/59#issuecomment-1419312129), because I think a lot of confusion comes from the different interpretations of these terms. \"QUIC CC\" might be used as \"the congestion controller running in the QUIC implementation\" or as \"the reno-like algorithm defined in RFC 9002\". Similarly, \"Real-time CC\" could mean \"congestion controller implemented in an application sending RTP\" or it might be used to reference a specific algorithm like SCReAM, NADA, or BBR.\r\n\r\n@mengelbart - this is a super helpful suggestion. I created #70 to capture it.",
          "createdAt": "2023-03-09T19:38:15Z",
          "updatedAt": "2023-03-09T19:38:15Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "I_kwDOFUmh7s5eVZIM",
      "title": "Describe how RTP and non-RTP traffic sharing multiple QUIC connections on a single 5-tuple would work",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/65",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF119",
        "FIN-WAIT"
      ],
      "body": "We're starting with the idea that these types of traffic might not be using the same model for congestion control, but there's likely much more.",
      "createdAt": "2023-02-13T16:25:04Z",
      "updatedAt": "2024-02-16T15:53:49Z",
      "closedAt": "2024-02-16T15:53:49Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "When bulk transfer is enabled along with media, often the desire is for the bulk transfer not to interfere with the media.  To prevent that, the bulk transfer uses delay-based congestion control, same as for the media.  The bulk transfer will go slower, but that's often what the user wants. ",
          "createdAt": "2023-02-23T23:24:30Z",
          "updatedAt": "2023-02-23T23:24:30Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba - now that we're focusing on \"providing guidance\" about congestion control and rate adaptation, I think that saying what you said in your comment is the right thing to say in the document. ",
          "createdAt": "2023-03-09T17:17:42Z",
          "updatedAt": "2023-03-09T17:17:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We may want a clear description of the many levels of multiplexing we can be doing (at the same time).  It's turtles all the way down. ",
          "createdAt": "2023-05-17T16:55:02Z",
          "updatedAt": "2023-05-17T16:55:31Z"
        },
        {
          "author": "samhurst",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a slight tangent to the topic at hand, but I have thought a few times about this myself, and I keep coming back to the idea that multiplexing multiple application protocols within a single QUIC connection is better solved in a distinct standard as it has applicability beyond facilitating bulk data transfer alongside streaming media.\r\n\r\nFor example, I can see a use case where you could have streaming media, live chat and file sharing all in a single connection. I really don't want to negotiate a connection with an `rq` ALPN on a simple device, only to have to add all the edge cases where a peer could start trying to bundle bulk transfer in the same connection. Instead, I'm thinking about a QUIC protocol extension which on a connection negotiated with ALPN _a_, then says I'd like to also send application protocol _b_. There's then some extension (or replacement for) the `STREAM` frame that stipulates which application protocol the contents of a given stream are destined for. I think connection-level flow control will still be tricky, but I'd imagine such an extension would contain provisions for flow control on each stream dependent on which application protocol it is assigned to (this definitely needs more thought).\r\n\r\nI am surprised an ID for something like this hasn't cropped up yet and I don't know if anyone would be interested in writing one beyond myself. There's always the \"you can do it in WebTransport\" argument but not everything is a conversation between a web browser and a web server.",
          "createdAt": "2023-06-08T13:51:09Z",
          "updatedAt": "2023-06-08T13:51:09Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Sorry, hit comment early... \r\n\r\nSo the current draft says \r\n\r\n> If a receiver cannot associate a flow identifier with any RTP/RTCP or non-RTP stream, it MAY drop the data stream.\r\n\r\nIf that is not ideal, we could define another ALPN that only allows media streams, but that would make things more complicated. When we discussed multiplexing, one of the requirements was to enable use cases where one would like to send non-RTP data on the same connection.\r\n\r\n> There's then some extension (or replacement for) the STREAM frame that stipulates which application protocol the contents of a given stream are destined for.\r\n\r\nThat sounds like what we do with the flow identifier, but without using a QUIC extension or a new frame.\r\n\r\nI don't know if an extension that allows to change the application protocol would be useful. If I understand you correctly, you would then need some other way of negotiating the new protocols on top.\r\n\r\nWe could use a STREAM frame extension (or some other form of indicating what a stream contains) that allows multiplexing different application protocols, but I would consider that a different issue from the ALPN negotiation. ",
          "createdAt": "2023-06-12T17:21:17Z",
          "updatedAt": "2023-06-12T17:21:17Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Not sure why the RTP over QUIC spec should have normative statements relating to non-RTP/RTCP data.  This would be like RFC 3550 attempting to define the behavior of WebRTC data channel.  Yes, WebRTC data channel can be multiplexed with RTP/RTCP, but unless something has done wrong, WebRTC data channel packets will never be forwarded to the RTP/RTCP stack. \r\n\r\nIt's the same here. RTP/RTCP is an application running over the P2P QUIC transport, which takes care of delivering RTP/RTCP data to the RTP stack.   If data is being sent, P2P QUIC multiplexing makes sure that it is not delivered to RTP/RTCP.   \r\n\r\nAlso, there is no need for multiple ALPNs.  Just as WebRTC only defines one ALPN, in P2P QUIC there is only one ALPN. \r\n\r\n",
          "createdAt": "2023-06-12T18:56:45Z",
          "updatedAt": "2023-06-12T18:56:45Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think I agree mostly with what you're saying, but I am a bit lost about the P2P QUIC part. \r\n\r\nWe decided to define multiplexing using the flow identifier and the `rtp-mux-quic` ALPN because, as far as I know, there was nothing like P2P QUIC defined that would do these things for us. If that changed or will change, should we consider dropping multiplexing with non-RTP/RTCP data and relying on the P2P QUIC multiplexing and ALPN instead?",
          "createdAt": "2023-06-12T20:18:35Z",
          "updatedAt": "2023-06-12T20:18:35Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba and @mengelbart - I do think we have an semi-infinitely large number of levels of  multiplexing in RoC, and anything that we don't have to specify is going to help us focus on what we absolutely DO need to specify.",
          "createdAt": "2023-07-27T22:38:24Z",
          "updatedAt": "2023-10-23T15:43:01Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "This discussion has been helpful, but has conflated\r\n\r\n- RTP/RTCP being multiplexed with RTP/RTCP and \r\n- other protocols being multiplexed with RTP/RTCP.\r\n\r\nWe think we have described RTP/RTCP being multiplexed with RTP/RTCP, and #86 is still open for this part of the discussion. \r\n\r\n@mengelbart will create a new issue for other protocols being multiplexed with RTP/RTCP.",
          "createdAt": "2024-02-12T17:11:03Z",
          "updatedAt": "2024-02-12T17:11:03Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "RTP/RTCP being multiplexed with RTP/RTCP is already addressed in the document.\r\n\r\nOther protocols being multiplexed with RTP/RTCP will be addressed in #159.",
          "createdAt": "2024-02-16T15:53:49Z",
          "updatedAt": "2024-02-16T15:53:49Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "I_kwDOFUmh7s5gazP1",
      "title": "CC/RA: Phrase discussion about congestion control/rate adaptation in terms of guidance, not normative should/musts",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/67",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Based on discussion at [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore).",
      "createdAt": "2023-03-09T17:02:11Z",
      "updatedAt": "2023-05-16T20:24:56Z",
      "closedAt": "2023-05-16T20:24:56Z",
      "comments": []
    },
    {
      "number": 68,
      "id": "I_kwDOFUmh7s5gaz0U",
      "title": "CC/RA: Remove mentions about \"disabling QUIC congestion control\", etc. ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/68",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Based on discussion at [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore).",
      "createdAt": "2023-03-09T17:03:42Z",
      "updatedAt": "2023-05-16T20:24:56Z",
      "closedAt": "2023-05-16T20:24:56Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Sorry, I saw this too late: Maybe https://github.com/mengelbart/rtp-over-quic-draft/issues/62#issuecomment-1462480865 should have been posted here. I think a definition of \"QUIC CC\" would be helpful, and removing \"disabling QUIC congestion control\" sounds good because it sounds confusing. But it should be allowed to use SCReAM/NADA/... without also having to run a loss-based algorithm like Reno.",
          "createdAt": "2023-03-09T17:44:38Z",
          "updatedAt": "2023-03-09T17:44:38Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "I_kwDOFUmh7s5ga8Tv",
      "title": "CC/RA: Explain why we aren't making BCP recommendations for rate adaptation algorithms in this document",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/69",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Based on discussion at [February 2023 AVTCORE virtual interim meeting](https://datatracker.ietf.org/meeting/interim-2023-avtcore-01/session/avtcore).\r\n\r\nWe should be describing considerations for people choosing congestion control and rate adaptation algorithms, of course. ",
      "createdAt": "2023-03-09T17:26:37Z",
      "updatedAt": "2023-05-11T07:49:34Z",
      "closedAt": "2023-05-11T07:49:34Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Rate Control is often application and codec-specific.  For example, in WebRTC an application can indicate that it prefers to maintain resolution or framerate in the event of congestion. There are also rate control algorithms that adjust quantization in response to congestion, but this is not always a good idea (e.g. if you are sharing text where maintaining readability is important).  So the RTP specifications and even RTP payload specs don't say much about rate control. \r\n\r\nCurrently, the RMCAT congestion control algorithms are Experimental, so that's a good reason to avoid making a recommendation, ",
          "createdAt": "2023-04-14T15:44:21Z",
          "updatedAt": "2023-04-14T15:44:21Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOFUmh7s5gbvdq",
      "title": "CC/RA: More clearly define what we mean by \"QUIC CC\", real-time media rate adaptation, etc. in this document.",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/70",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Suggested by @mengelbart in a #62 [comment](https://github.com/mengelbart/rtp-over-quic-draft/issues/62#issuecomment-1462480865). ",
      "createdAt": "2023-03-09T19:36:53Z",
      "updatedAt": "2023-04-14T12:25:00Z",
      "closedAt": "2023-04-14T12:25:00Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "*Congestion Control* and *Rate Adaptation* are already defined in the terminology section. I would suggest adding the following definitions:\r\n\r\n* **Loss-based congestion control algorithm**: A congestion control algorithm that uses packet loss as a signal for congestion. Loss-based congestion control algorithms allow senders to send data on a path until packets are dropped by intermediary network elements, which the algorithm treats as a signal of congestion.\r\n* **Delay-based or Low-latency congestion control algorithm**: A congestion control algorithm that aims at keeping queues, and thus the latency, at intermediary network elements as short as possible. Delay-based congestion control algorithms use, for example, an increasing one-way delay as a signal of congestion.\r\n* **QUIC congestion controller**: A software component of a QUIC implementation that implements a congestion control algorithm.\r\n* **RTP congestion controller**: A software component of an RTP implementation that implements a congestion control algorithm.",
          "createdAt": "2023-03-20T12:06:13Z",
          "updatedAt": "2023-03-20T12:06:13Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - thanks for this proposed text. I have two suggestions, which I'll put in my PR, but what you said was super helpful. \r\n\r\n> Loss-based congestion control algorithm: A congestion control algorithm that uses packet loss as a signal for congestion. Loss-based congestion control algorithms allow senders to send data on a path until packets are dropped by intermediary network elements, which the algorithm treats as a signal of congestion.\r\n\r\nI'm being pedantic, but I would also include networks that provide ECN, which is typically treated as data loss (although Scalable Congestion Controllers treat ECN(1) differently\r\n\r\nAnd, actually I'd also include networks that support ECN(1) under \"Delay-based or Low-latency congestion control algorithm\". So, I guess that's two and a half suggestions? \r\n\r\n> RTP congestion controller: A software component of an RTP implementation that implements a congestion control algorithm.\r\n\r\nI THINK that this can also happen in an application using an RTP implementation, can't it? ",
          "createdAt": "2023-03-25T11:19:19Z",
          "updatedAt": "2023-03-25T11:19:19Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Including ECN sounds good to me. Do you suggest including them under loss-based, delay-based, or both?\r\n\r\n> I THINK that this can also happen in an application using an RTP implementation, can't it?\r\n\r\nYes, I think this is possible, but maybe it just depends on where you draw the line between the RTP implementation and the application?",
          "createdAt": "2023-03-27T02:35:55Z",
          "updatedAt": "2023-03-27T02:35:55Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> > I THINK that this can also happen in an application using an RTP implementation, can't it?\r\n> \r\n> Yes, I think this is possible, but maybe it just depends on where you draw the line between the RTP implementation and the application?\r\n\r\n@mengelbart - on thinking more (and more clearly), I don't think we need to address this here. ",
          "createdAt": "2023-03-27T08:01:20Z",
          "updatedAt": "2023-03-27T08:01:20Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "I_kwDOFUmh7s5h22qf",
      "title": "PLEASE choose an acronym for \"RTP over QUIC\"!!!",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/74",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart",
        "joerg-ott"
      ],
      "labels": [],
      "body": "If we had a reasonable acronym for \"RTP-over-QUIC\", our specification would be more than a little bit easier to read. \r\n\r\nI'm not suggesting one - I think @mengelbart and @joerg-ott should have the honor of painting that bikeshed - but I think we need one badly, and I expect marketing types outside the IETF, or even participants in other SDOs, to pick one if we don't. \r\n\r\n:upside_down_face:",
      "createdAt": "2023-03-27T09:46:26Z",
      "updatedAt": "2023-04-27T07:14:15Z",
      "closedAt": "2023-04-27T07:14:15Z",
      "comments": [
        {
          "author": "samhurst",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Might I suggest [QRT](https://datatracker.ietf.org/doc/html/draft-hurst-quic-rtp-tunnelling)? \ud83d\ude07\r\n\r\nAlternatively, maybe just \"rq\", in the same way that HTTP-over-QUIC was originally \"hq\"?",
          "createdAt": "2023-03-27T09:55:31Z",
          "updatedAt": "2023-03-27T09:55:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "The obvious one is one syllable - RoQ. Why not?",
          "createdAt": "2023-03-28T05:27:16Z",
          "updatedAt": "2023-03-28T05:27:16Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "RoQ - I like it!",
          "createdAt": "2023-04-14T15:45:15Z",
          "updatedAt": "2023-04-14T15:45:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think RoQ makes sense as it also aligns with MoQ and DoQ. I also just talked to @joerg-ott and we agreed on using RoQ.  I'll open a PR.",
          "createdAt": "2023-04-14T16:00:50Z",
          "updatedAt": "2023-04-14T16:00:50Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "I_kwDOFUmh7s5h8XdB",
      "title": "Improve consideration for multi-hop topologies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/75",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "Discussion required"
      ],
      "body": "So the QUIC connection carrying RTP will for now be point to point. However, as RTP has notion of RTP middleboxes that are used to create multiparty topologies there need to be better consideration for when one can do optimizations like reducing the rate of RTCP because the RTCP receiver related statistics will be known by QUIC sender. So if one can reduce the rate or even skip some RTCP reports is all dependent if the RTP middlebox that interconnects has full autonomy and can act on all aspects on the transport feedback. However, if the original sender in a system would monitor all receivers and actually adapt its general rates in a simulcast for example and the middlebox just selects between the simulcast versions then one would have to maintain RTCP reports that does cross reporting over the whole RTP session. \r\n\r\nSo I think you need to clarify for example in Section 6.1 that the system needs to decided on its need and use signalling to both configure the reports the system needs as well as the frequency of the RTCP reporting.  ",
      "createdAt": "2023-03-28T05:14:28Z",
      "updatedAt": "2024-02-11T01:55:37Z",
      "closedAt": "2023-09-25T16:17:23Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "I would also note that if a RTP session member does not send any RTCP receiver reports it might be classify it as not longer part of the session. RFC 3550 does only require one to send RTP/RTCP packets the last 5 reporting interval. However, I have feeling that many implementation will us SR or RR as equivalent to sending RTCP as they have been the base line. ",
          "createdAt": "2023-03-28T05:21:50Z",
          "updatedAt": "2023-03-28T05:21:50Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "[the second comment](https://github.com/mengelbart/rtp-over-quic-draft/issues/75#issuecomment-1486234250) is Related to #117, but this issue requires us to provide a reasonably complete set of mappings between RTCP feedback and QUIC feedback for any middlebox that bridges between legacy RTP and RoQ. We should probably do #117 first, and then start work on the set of mappings. \r\n\r\nOne other alternative is to signal RoQ endpoints saying \"this RoQ session is being bridged to legacy RTP, and I'm NOT mapping between QUIC feedback and RTCP reports, so you should probably be using RTCP\". More thought required ... ",
          "createdAt": "2023-09-01T15:18:44Z",
          "updatedAt": "2023-09-01T15:26:56Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOFUmh7s5h8bFA",
      "title": "Important: define error codes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/76",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "Related to #13 but also applicable to the rest of the specification.\r\n\r\nRTP over QUIC is an application layer mapping for RTP applications. \r\n\r\nWhen using STOP_SENDING or RESET_STREAM, the code has to be an application-layer error code, and you don't have one. Without that, people will just pick random numbers (or worse, send 0 for everything). \r\n\r\nDefining codes isn't too hard, we should put some thought into gradeful or abrupt conditions that can be communicated via error codes",
      "createdAt": "2023-03-28T05:30:40Z",
      "updatedAt": "2023-10-23T14:09:55Z",
      "closedAt": "2023-10-23T14:09:55Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@LPardue - do you plan to provide text for this issue by the next AVTCORE interim? ",
          "createdAt": "2023-09-15T15:22:48Z",
          "updatedAt": "2023-09-15T15:22:48Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "I_kwDOFUmh7s5iK0bf",
      "title": "Add motivations for RoQ adoption",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/77",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Add motivations for RQ work and adoption\r\n\r\nTransport-level encryption with RQ.\r\n\r\nUsing QUIC as it evolves (connection migration, and especially multipath QUIC).\r\n\r\nThinking about policy aspects of connection migration between interfaces (cheap WiFi vs expensive cellular).\r\n\r\nPotential connection sharing with other protocols over QUIC.\r\n\r\nQUIC path MTU discovery, especially in multiparty environments (today conference server has no option except using the lowest path MTU for all conference participants). \r\n\r\nACK piggybacking in QUIC if there are any QUIC frames going the other direction versus ACKs decreasing the available MTU for media. \r\n\r\nBeing clear about how RQ congestion control and flow control work.\r\n\r\nPossible advantage if audio is piggybacking on video in RQ - packaging multiple frames into a packet. \r\n\r\nThink about how multiple media quality variants would work - is there an advantage here?\r\n\r\nMultiplexing real-time and non-real-time flows. \r\n\r\nInteraction between QUIC congestion control and media congestion control. ",
      "createdAt": "2023-03-30T06:35:41Z",
      "updatedAt": "2024-02-11T01:55:37Z",
      "closedAt": "2023-07-23T21:35:46Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated motivations issues \r\n\r\nm-Transport-level encryption with RQ.\r\n\r\nm-Using QUIC as it evolves (connection migration, and especially multipath QUIC).\r\n\r\nm-Potential connection sharing with other protocols over QUIC.\r\n\r\nm-QUIC path MTU discovery, especially in multiparty environments (today conference server has no option except using the lowest path MTU for all conference participants).\r\n\r\nm-ACK piggybacking in QUIC if there are any QUIC frames going the other direction versus ACKs decreasing the available MTU for media. #85 \r\n\r\nm-Possible advantage if audio is piggybacking on video in RQ - packaging multiple frames into a packet.\r\n\r\nm-Multiplexing real-time and non-real-time flows.",
          "createdAt": "2023-05-17T16:33:41Z",
          "updatedAt": "2023-05-17T16:33:41Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "The initial list for this issue are from discussions with with @gchandok at IETF 116. ",
          "createdAt": "2023-06-16T15:55:45Z",
          "updatedAt": "2023-06-16T16:27:51Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins requested this one be assigned to him, because he is likely responsible for similar text in the [MOQ Requirements draft](https://github.com/moq-wg/moq-requirements). ",
          "createdAt": "2023-06-16T16:29:32Z",
          "updatedAt": "2023-06-16T16:29:32Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "I_kwDOFUmh7s5kglq1",
      "title": "Add RTCP messages from draft-ietf-avtcore-rtcp-green-metadata",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/79",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "draft-ietf-avtcore-rtcp-green-metadata is not yet included in the list of feedback types",
      "createdAt": "2023-04-27T07:19:06Z",
      "updatedAt": "2023-07-23T20:44:50Z",
      "closedAt": "2023-07-23T20:44:50Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba and @JonathanLennox, **this is a process question** - do the chairs think draft-ietf-avtcore-rtcp-green-metadata is ready for us to include it in the RTP over QUIC discussion about mapping QUIC to RTCP feedback? \r\n\r\ndraft-ietf-avtcore-rtcp-green-metadata has been adopted as a working group draft, but it's the first I-D we're including in the QUIC-to-RTCP discussion - everything else has been an approved RFC. So I thought I should ask for guidance. ",
          "createdAt": "2023-04-27T15:21:34Z",
          "updatedAt": "2023-04-27T15:21:34Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba and @JonathanLennox, we haven't heard a response about our process question, and we are assuming that adding the rtcp-green-metadata is the Right Thing To Do, and will add it to our draft. Please tell us if this is wrong. ",
          "createdAt": "2023-06-16T15:10:08Z",
          "updatedAt": "2023-06-16T15:10:08Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDOFUmh7s5kgnOk",
      "title": "Reference RTCP subsections from tables",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/80",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "The tables in sections [6.5](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-6.5) - [6.8](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-6.8) contain a lot of information which is also explained in more detail in section [6.3](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-6.3). I think we can reference the relevant subsections from the tables instead.",
      "createdAt": "2023-04-27T07:23:55Z",
      "updatedAt": "2023-09-22T07:46:09Z",
      "closedAt": "2023-09-22T07:46:09Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I agree that putting all of the material relating to a specific feedback mechanism in one place, and referring to it rather than adding text elsewhere makes sense. Here's what I was thinking about while working on PR #71.\r\n\r\n- some material is duplicated (in text and in tables), \r\n- some material is split (between text in tables), \r\n\r\nThat's roughly this issue. But, in addition, \r\n\r\n- It makes sense to me that we would have a list of what can be mapped between approved QUIC (RFC 9000 + RFC 9221) and RTCP, and a separate list of what could be mapped if we had one of the timestamps drafts (to help people understand why we need one of those drafts). Does that make sense to you? \r\n- I made the (not necessarily correct) decision to list everything that we looked at, whether it can be mapped between QUIC and RTCP or not, so we have a lot of table entries that say \"no\", even if some entries in the same table say \"yes\", and that's begging for us to also document why we think the answer is \"no\" (again, should we be adding that?)\r\n\r\nIt might make sense to move this second group of possible changes into its own, but (especially if we decide that spending a lot of effort on \"no\" entries isn't worth doing), we might be making to changes to text/tables/rows that we'll end up deleting from the document. \r\n\r\nDo you have thoughts about that? Should we have a short Slackathon to discuss?",
          "createdAt": "2023-04-27T15:02:26Z",
          "updatedAt": "2023-04-27T15:02:26Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> It makes sense to me that we would have a list of what can be mapped between approved QUIC (RFC 9000 + RFC 9221) and RTCP, and a separate list of what could be mapped if we had one of the timestamps drafts (to help people understand why we need one of those drafts). Does that make sense to you?\r\n\r\nI agree that having a list of what could be mapped with or without a timestamp extension would be helpful. I am not sure if that should be a separate table or if it would be enough to have an extra column for that.\r\n\r\n> I made the (not necessarily correct) decision to list everything that we looked at, whether it can be mapped between QUIC and RTCP or not, so we have a lot of table entries that say \"no\", even if some entries in the same table say \"yes\", and that's begging for us to also document why we think the answer is \"no\" (again, should we be adding that?)\r\n\r\nThat sounds good, too. I assume that the explanation would be the same for many of the fields so maybe we can do something similar to what you did in the topologies section, so we can reference the explanation/notes/subsection from all rows in the table to which it applies?\r\n",
          "createdAt": "2023-05-02T08:24:10Z",
          "updatedAt": "2023-05-02T08:24:45Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We may want to move some of these sections into an appendix (\"we looked at these and don't think they're useful, so other people don't have to wonder if we looked at them\").",
          "createdAt": "2023-05-17T17:05:42Z",
          "updatedAt": "2023-05-17T17:05:42Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "I_kwDOFUmh7s5lJPAz",
      "title": "Should we describe congestion control BEFORE we describe mapping QUIC feedback onto RTCP?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/82",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "I note that there is some material in the current Section 6 (\"Replacing RTCP and RTP Header Extensions with QUIC Feedback\") that \"prestates\" (it would be restating, but it comes before) the current Section 7 (\"Congestion Control and Rate Adaptation\"), but Step One would be to swap the two sections, and then review for clarity and continuity. \r\n\r\nFor example, [I-D.draft-smith-quic-receive-ts] and [I-D.draft-huitema-quic-ts] are mentioned more than once in each section, and it would be better if we explained what's going on once, on first use, and then just used references. ",
      "createdAt": "2023-05-05T02:32:39Z",
      "updatedAt": "2023-05-18T18:33:30Z",
      "closedAt": "2023-05-18T18:33:30Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Start with the section swap, and then edit looking for redundancies. ",
          "createdAt": "2023-05-17T17:07:07Z",
          "updatedAt": "2023-05-17T17:07:07Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOFUmh7s5ltjik",
      "title": "Add more detail to section 7.3 on congestion control when sharing connections with non-RTP streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/84",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF119"
      ],
      "body": "[Section 5.1](https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic#section-5.1) explains in detail how multiplexing RTP with other protocols would work and [section 7.3](https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic#section-7.3) is supposed to explain how to do congestion control for that. But the only sentence about this is rather vague:\r\n\r\n> Applications multiplexing multiple streams in one connection SHOULD implement some form of stream prioritization or bandwidth allocation.\r\n\r\nThis also came up in discussion with Gurtej and is slightly related to the discussion we had here: https://github.com/mengelbart/rtp-over-quic-draft/pull/83#discussion_r1191585178",
      "createdAt": "2023-05-11T19:45:15Z",
      "updatedAt": "2024-02-16T15:12:05Z",
      "closedAt": "2024-02-16T15:12:05Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We need informed opinions about the maturity of NADA/SCReAM competing with congestion controllers like BBR - probably a good question for CCWG (former [CONGRESS](https://datatracker.ietf.org/doc/charter-ietf-congress/)) when they are chartered. One way or another, this issue relies on expertise that is outside the core competence of many AVTCORE participants, even if some participants have that core competence. ",
          "createdAt": "2023-05-17T17:16:10Z",
          "updatedAt": "2023-06-16T16:15:34Z"
        },
        {
          "author": "pthatcher",
          "authorAssociation": "NONE",
          "body": "One could, of course, just let the QUIC and non-QUIC do their own congestion control that compete with one another.  That's how SCTP and RTP work together in WebRTC.   One could theoretically have the two protocols coordinate with one congestion controller, but that's complex enough work that no one (that I know of) has attempted it.  \r\n\r\nI would suggest just leaving this an implementation detail.   If implementations want to try and do the complex work of coordinating the congestion control across different protocols, they can.  If they want to keep it simple and let them compete, they can.   ",
          "createdAt": "2023-11-08T09:24:08Z",
          "updatedAt": "2023-11-08T10:18:59Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> Oen could, of course, just let the QUIC and non-QUIC do their own congestion control that compete with one another. That's how SCTP and RTP work together in WebRTC. One could theoretically have the two protocols coordinate with one congestion controller, but that's complex enough work that no one (that I know of) has attempted it.\r\n> \r\n> I would suggest just leaving this an implementation detail. If implementations want to try and do the complex work of coordinating the congestion control across different protocols, they can. If they want to keep it simple and let them compete, they can.\r\n\r\n@pthatcher - I agree, and that seems like helpful guidance that isn't going to be **too** helpful. :laughing:",
          "createdAt": "2023-11-08T09:53:22Z",
          "updatedAt": "2023-11-08T09:53:22Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOFUmh7s5ltkx1",
      "title": "Add MTU vs. extra packet considerations for Acknowledgements when using datagrams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/85",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "QUIC acknowledgment frames can be sent in the same packet as stream or datagram frames, which adds overhead and reduces the maximum size of datagram frames. If a packetizer is configured to produce packets at a fixed maximum MTU, the sender may need to send many extra QUIC packets for acknowledgments. It may be helpful to reference the acknowledgment frequency draft, which could help to reduce the overhead somewhat.\r\n\r\nMaybe relevant: https://www.rfc-editor.org/rfc/rfc9000#section-13\r\n",
      "createdAt": "2023-05-11T19:49:29Z",
      "updatedAt": "2023-07-10T16:29:52Z",
      "closedAt": "2023-07-10T16:29:52Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "The fundamental problem this issue is pointing to, is that the RTP sender (and receiver) does not have visibility to non-data frames that a QUIC sender may include in an outgoing QUIC packet. So, not just QUIC ACKs. We can provide a description of the trade-offs in the document now, but we probably can't make specific recommendations (\"do this, not that\") in the document, at least not yet. ",
          "createdAt": "2023-06-16T16:08:25Z",
          "updatedAt": "2023-06-16T16:08:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "If we find that we are able to make specific recommendations, these recommendations may be added under a follow-up issue. ",
          "createdAt": "2023-06-16T16:18:14Z",
          "updatedAt": "2023-06-16T16:18:14Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "I_kwDOFUmh7s5ltlUH",
      "title": "Coalescing RTP packets in single QUIC packet",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/86",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "Discussion required",
        "IETF119"
      ],
      "body": "Over UDP, every RTP packet gets sent in a UDP datagram. In QUIC, one could batch multiple small RTP packets together in a QUIC packet. This will probably happen automatically for streams but may depend on some scheduling for datagrams. That scheduling should take real-time requirements into account, i.e., try to optimize by batching, but also not delay packets too much.\r\n\r\nMaybe relevant: https://www.rfc-editor.org/rfc/rfc9000#section-13\r\n",
      "createdAt": "2023-05-11T19:51:13Z",
      "updatedAt": "2024-02-16T15:10:51Z",
      "closedAt": "2024-02-16T15:10:51Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Batching RTP packets is something that QUIC implementations can do, and @mengelbart and @SpencerDawkins think this is worth noting in the document, but it seems more useful to wait until we have some experience that tells us whether this will matter (assuming a conforming QUIC implementation) before we add text about recommendations implementers of RTP senders should consider. . ",
          "createdAt": "2023-06-16T15:59:56Z",
          "updatedAt": "2023-06-16T15:59:56Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "I_kwDOFUmh7s5ltnbS",
      "title": "Are real-time congestion controllers tied to RTP or usable in QUIC stacks?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/87",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "question"
      ],
      "body": "SCReAM, NADA, and GCC were specifically designed with RTP/RTCP in mind. Is it feasible to use one of these in the QUIC stack itself, or are there other alternatives that could be implemented directly in a QUIC stack to follow the recommendations given in [section 7.1](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-7.1)? One requirement that all of the RMCAT algorithms have is that they need timestamps, which could be provided by one of the QUIC timestamp extension drafts.\r\n\r\nThis came up in discussion with Gurtej and again in https://github.com/mengelbart/rtp-over-quic-draft/pull/83#discussion_r1190525045\r\n",
      "createdAt": "2023-05-11T19:57:00Z",
      "updatedAt": "2024-02-16T15:55:37Z",
      "closedAt": "2024-02-16T15:55:36Z",
      "comments": [
        {
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "body": "IMO, it would be ideal to implement a real time rate adaptation algorithm in the QUIC stack and then expose an API for bitrate estimation to the application/framework that uses that to call into encoder. I can take this issue but do we need a PoC before making this text change?",
          "createdAt": "2023-06-10T01:01:03Z",
          "updatedAt": "2023-06-10T01:01:03Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I agree with that. I think a PoC and some experiments exploring such an implementation would be nice. I had this on my list for some time now but didn't get to implement it yet. I don't know if we need it before changing any text, but it might give some insights that could be useful to document.",
          "createdAt": "2023-06-12T17:26:34Z",
          "updatedAt": "2023-06-12T17:26:34Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I said I would send this out to @lpardue and @pthatcher as a question, and failed. I **promise, promise, promise** ...",
          "createdAt": "2023-07-27T22:53:39Z",
          "updatedAt": "2023-07-27T22:53:39Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I'm not sure what the question is - what can I help with?",
          "createdAt": "2023-07-27T23:13:54Z",
          "updatedAt": "2023-07-27T23:13:54Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@goelvidhi - on this:\r\n\r\n> IMO, it would be ideal to implement a real time rate adaptation algorithm in the QUIC stack and then expose an API for bitrate estimation to the application/framework that uses that to call into encoder. I can take this issue but do we need a PoC before making this text change?\r\n\r\nI think a POC is a fine idea, but if we have a new congestion controller, that probably starts in [ICCRG](https://datatracker.ietf.org/rg/iccrg/about/), doesn't it?",
          "createdAt": "2023-07-27T23:14:12Z",
          "updatedAt": "2023-07-27T23:14:12Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @SpencerDawkins think that asking @LPardue and @pthatcher for clues is still the right thing to do, but not until we merge PR #134, because we're still changing the text that we want to ask about. :roll_eyes:",
          "createdAt": "2023-10-16T15:21:36Z",
          "updatedAt": "2023-10-16T15:23:39Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We have now merged PR #134, and @SpencerDawkins thinks that we need to uplevel to talk about how we expect QUIC stacks, especially at the other end of a RoQ connection, to Do The Right Thing for media. We have had many ideas, and none have achieved consensus.\r\n\r\n- \"turn off QUIC congestion control and do everything in RTP\" - this was rejected for excellent reasons\r\n- \"allow RoQ to configure QUIC congestion control\" - at a high level, not like picking algorithms\r\n- \"use a different ALPN that says \"this is RoQ, so Do The Right Thing\" - this is [in the draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-connection-establishment-an) now\r\n- \"assume that QUIC implementations that attempt to prevent increasing one-way delays for any QUIC traffic will work for media, that wants that, too\" - if that's a plan, we should probably check with the QUIC working group if that's what they think, too\r\n\r\n@SpencerDawkins thinks leaving this vaguely specified is a problem. I'm tagging this For Discussion, with IETF 118 coming up in a couple of weeks, to see whether we can make progress. ",
          "createdAt": "2023-10-23T15:38:15Z",
          "updatedAt": "2023-10-23T15:38:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> We have now merged PR #134, and @SpencerDawkins thinks that we need to uplevel to talk about how we expect QUIC stacks, especially at the other end of a RoQ connection, to Do The Right Thing for media. We have had many ideas, and none have achieved consensus.\r\n\r\nI don't think we necessarily need the other end to cooperate on this much. If the other end is receiving media, it needs to give the correct feedback so that the sending end can do the right thing. The feedback may require timestamps, but that would be negotiated via transport parameters. Either timestamps are available or not. No need to negotiate beyond what a potential timestamp extension would specify, anyway.\r\n\r\n>     * \"allow RoQ to configure QUIC congestion control\" - at a high level, not like picking algorithms\r\n\r\nI think RoQ application developers need to choose the right QUIC implementation and congestion controller to use for _sending_ media.\r\n\r\n>     * \"use a different ALPN that says \"this is RoQ, so Do The Right Thing\" - this is [in the draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-connection-establishment-an) now\r\n\r\nThe ALPN section is there for a different reason, it is not required for congestion control, but because QUIC requires application protocols to use ALPN (or equivalent mechanisms, see [Section 7 of RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html#name-cryptographic-and-transport) and [Section 8.1 of RFC 9001](https://www.rfc-editor.org/rfc/rfc9001.html#name-protocol-negotiation)).\r\n\r\n>     * \"assume that QUIC implementations that attempt to prevent increasing one-way delays for any QUIC traffic will work for media, that wants that, too\" - if that's a plan, we should probably check with the QUIC working group if that's what they think, too\r\n\r\nI think this is what the draft assumes, but I agree that it is probably a good idea to get more input on this (maybe from the QUIC WG, CCWG, or even ICCRG?).",
          "createdAt": "2023-10-24T13:04:52Z",
          "updatedAt": "2023-10-24T13:04:52Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - on this ...\r\n\r\n> I don't think we necessarily need the other end to cooperate on this much. If the other end is receiving media, it needs to give the correct feedback so that the sending end can do the right thing. The feedback may require timestamps, but that would be negotiated via transport parameters. Either timestamps are available or not. No need to negotiate beyond what a potential timestamp extension would specify, anyway.\r\n\r\nI agree on this (so far, modulo the sending end knowing what the right thing to do is), but keep reading. ",
          "createdAt": "2023-11-01T23:06:42Z",
          "updatedAt": "2023-11-01T23:06:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart -\r\n\r\n> I think **RoQ application developers need to choose the right** QUIC implementation and **congestion controller** to use for sending media.\r\n\r\nThat's the challenge - especially if the QUIC implementation isn't tightly coupled with the application. Maybe we can say that RoQ application developers need to watch for this carefully? ",
          "createdAt": "2023-11-01T23:10:29Z",
          "updatedAt": "2023-11-01T23:10:29Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - \r\n\r\n> The ALPN section is there for a different reason, it is not required for congestion control, but because QUIC requires application protocols to use ALPN (or equivalent mechanisms, see [Section 7 of RFC 9000](https://www.rfc-editor.org/rfc/rfc9000.html#name-cryptographic-and-transport) and [Section 8.1 of RFC 9001](https://www.rfc-editor.org/rfc/rfc9001.html#name-protocol-negotiation)).\r\n\r\nUnderstood. The problem is that we've been thinking that we needed to do something other than just trusting the QUIC implementation to Do The Right Thing for media, and if we are using a different APLN for media, it's easy for people to conflate choosing an application instance for media with choosing an application instance that will Do The Right Thing for media. \r\n\r\nI suspect the best way for us to handle this is actually saying something like \r\n\r\n> This document relies on the assumption that QUIC implementations will attempt to prevent increasing one-way delays when sending **any** QUIC traffic, and this will meet the needs of RTP over QUIC\".\r\n\r\nDoes that make sense?",
          "createdAt": "2023-11-01T23:22:52Z",
          "updatedAt": "2023-11-01T23:22:52Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I'm late here , sorry, and still playing catchup. I don't think I have all of the context of RoQ paged in but from this ticket, there's something about the discussion of expectations (or setting of expectations) on QUIC implementations that doesn't quite sit right with me. \r\n\r\nThis ticket is titled \"Are real-time congestion controllers tied to RTP or usable in QUIC stacks?\" yet Spencer asks some different questions. That feels, to me, a bit like \"are electric hybrids tied to gasoline or usable in 3 phase? we need to uplevel to conversations about how efficiently divers lift and coast\"\r\n\r\nI need some more time to digest but endevour to provide a better response than this one.",
          "createdAt": "2023-11-02T00:42:51Z",
          "updatedAt": "2023-11-02T00:42:51Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @LPardue - \r\n\r\nThanks for popping in here. \r\n\r\n> I'm late here , sorry, and still playing catchup. I don't think I have all of the context of RoQ paged in but from this ticket, there's something about the discussion of expectations (or setting of expectations) on QUIC implementations that doesn't quite sit right with me.\r\n\r\nYou are not alone. :thinking: I feel your pain (and confusion). \r\n\r\n> This ticket is titled \"Are real-time congestion controllers tied to RTP or usable in QUIC stacks?\" yet Spencer asks some different questions. That feels, to me, a bit like \"are electric hybrids tied to gasoline or usable in 3 phase? we need to uplevel to conversations about how efficiently divers lift and coast\"\r\n\r\nMy apologies for incoherence when when adding my most recent comments in the issue. AVTCORE/RoQ has moved a LONG way from early discussions, where people who talked to us were expecting RoQ endpoints to disable QUIC congestion control (**\"whut?\"** :raised_eyebrow: :roll_eyes:) and require specific congestion controllers in the spec. \r\n\r\nMy list upthread (which @mengelbart was responding to) was trying to capture the various places we've been, and make sure that we're all in one place now. \r\n\r\nI **THINK** we're now here: \r\n\r\n> This document relies on the assumption that QUIC implementations will attempt to prevent increasing one-way delays when sending any QUIC traffic, and this will meet the needs of RTP over QUIC\"\r\n\r\nand I **THINK** @mengelbart agrees with that, so let's focus on that point, for now. BUT ...\r\n\r\n> I need some more time to digest but endevour to provide a better response than this one.\r\n\r\n... please don't endeavor too hard **right now** - @mengelbart and I have been around and around on this topic, and we're still working on the questions we are going to ask the working group during the AVTCORE session on Wednesday. Can you hold off a bit, while we finalize our slides, and then I'll update the issue and see if **I** can do better?",
          "createdAt": "2023-11-02T16:03:46Z",
          "updatedAt": "2023-11-02T16:04:51Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "There are low latency CC algorithms currently integrated into QUIC stacks, including: \r\n\r\n1. COPA:  See:  https://engineering.fb.com/2019/11/17/video-engineering/copa/\r\n2. L4S. See: https://developer.apple.com/documentation/network/testing_and_debugging_l4s_in_your_app\r\n\r\n\r\n\r\n",
          "createdAt": "2023-11-06T07:10:27Z",
          "updatedAt": "2023-11-06T07:10:27Z"
        },
        {
          "author": "pthatcher",
          "authorAssociation": "NONE",
          "body": "Another impl of COPA: https://github.com/Tencent/tquic/blob/develop/src/congestion_control/copa/copa.rs",
          "createdAt": "2023-11-08T09:27:06Z",
          "updatedAt": "2023-11-08T09:27:06Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba and @pthatcher - thank you both for the helpful information!",
          "createdAt": "2023-11-08T09:47:20Z",
          "updatedAt": "2023-11-08T09:47:20Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "From IETF 118 minutes: \r\n\r\n> Bernard: both COPA and L4S have been implemented in QUIC, although we're not sure whether they've been deployed\r\n> Randell Jesup: This draft should say \"should use real-time congestion control\" but can't say much more. This isn't something we can mandate, we can only request that the implementation does something appropriate.\r\n> Peter Thatcher: Should also recommend using timestamp extensions for better congestion control.\r\n> Zahed Sarker: Need some considerations on rate control/adaptation part, rather than just congestion control.\r\n> Bernard Aboba: Per frame QP (quantization parameters) can respond fast to congestion, but need to know if such mechanisms are useful here.\r\n",
          "createdAt": "2024-02-01T15:31:22Z",
          "updatedAt": "2024-02-01T15:31:22Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I did add a mention of L4S. \r\n\r\nWe rephrased rate adaptation/congestion control in -08. \r\n\r\nWe're waiting for timestamps to progress enough for a normative recommendation. \r\n\r\nBernard mentioned COPA. Do we want to mention this, or any other possible mechanisms, in informative text?",
          "createdAt": "2024-02-12T17:20:16Z",
          "updatedAt": "2024-02-12T17:20:16Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "This has been resolved in PRs for several other issues. ",
          "createdAt": "2024-02-16T15:55:37Z",
          "updatedAt": "2024-02-16T15:55:37Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "I_kwDOFUmh7s5mDuup",
      "title": "List all QUIC extensions documents that might be useful for RoQ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/92",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "RoQ does not require any QUIC extensions, but there are a few extension documents referenced in the document, and it would be helpful to have a complete list of extensions that might be useful for RoQ. The list should include the timestamp draft(s) and the ENOUGH frame and maybe more.",
      "createdAt": "2023-05-16T15:26:17Z",
      "updatedAt": "2024-02-11T01:55:38Z",
      "closedAt": "2023-07-23T20:53:13Z",
      "comments": []
    },
    {
      "number": 93,
      "id": "I_kwDOFUmh7s5mLgfc",
      "title": "Using streams, datagrams, and per-RTP-frame streams with RoQ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/93",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "We may need a short section explaining the ROQ-specific tradeoffs",
      "createdAt": "2023-05-17T16:52:12Z",
      "updatedAt": "2023-09-15T15:07:17Z",
      "closedAt": "2023-09-15T15:07:17Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba asked if a sender had any restrictions on using streams, per-frame streams, and datagrams. I agree and think we should explicitly say something (\"silence is permission\"), and also consider interactions.",
          "createdAt": "2023-07-27T22:47:14Z",
          "updatedAt": "2023-07-27T22:47:14Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "I asked the question in the context of Peter's SDP negotiation slide, in which it wasn't clear what UDP/QUIC/RTP/AVPF meant exactly. For example, would an Answerer receiving this in the Offer interpret it to mean that it needs to be willing receive RTP over streams, datagrams and some mixture of both? Or is there a way for an Offerer to indicate that only requires the Answerer to support a subset of all potential transport modes (e.g. reliable streams OR datagrams).\n\nNote that in the same discussion we also talked about multiplexing, specifically whether \"a=mid\" referred to the SDES/MID RTP header extension or to a QUIC multiplexing-ID. I think raises the question about what BUNDLE over QUIC looks like. ",
          "createdAt": "2023-07-28T00:46:47Z",
          "updatedAt": "2023-07-28T00:49:46Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba - so, I think the last time we had a meaningful conversation about SDP for RoQ in AVTCORE was at IETF 115, and I used slides in the [combined slide deck](https://datatracker.ietf.org/meeting/115/materials/slides-115-avtcore-ietf-115-avtcore-wg-03). Check out slide 53, but we definitely talked about \r\n\r\n> \u201cstream/\u201d, \u201cdgram/\u201d and \u201c/shared\u201d prepended to UDP/QUIC/RTP/AVPF\r\n\r\nSo, yes, it isn't clear what UDP/QUIC/RTP/AVPF meant exactly. :wink: :innocent:\r\n\r\nI got sufficiently strong pushback on trying to maintain the SDP draft while we were still figuring out how RoQ would work, that I dropped that draft to work with @mengelbart and @joerg-ott on the RoQ draft, so that I wasn't just annoying the working group with requests for unnecessary adoption polls. \r\n\r\nI'm fine to pick up that work when you and @JonathanLennox think RoQ is stable enough to allow a successful adoption poll for an SDP draft, but in the meantime, you might want to remind presenters who include SDP in their slides, that which AVP profiles will be registered was still an active question in the working group, the last time we talked about that. ",
          "createdAt": "2023-09-01T11:52:20Z",
          "updatedAt": "2023-09-01T11:52:20Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "While working on a PR for this issue, I noticed the following text in [Section 3 of RFC 9221](https://datatracker.ietf.org/doc/html/rfc9221#name-transport-parameter):\r\n\r\n> Application protocols that use datagrams **MUST** define how they react to the absence of the max_datagram_frame_size transport parameter. If datagram support is integral to the application, the application protocol can fail the handshake if the max_datagram_frame_size transport parameter is not present.\r\n\r\nI don't think this belongs in a subsection of Section 3 in the RoQ draft, but we do need to do it, and we should talk about what the behavior should be before we add this to the draft (probably in [Section 4 of the draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-connection-establishment-an). I'm adding issue #122 so we don't forget. ",
          "createdAt": "2023-09-01T14:46:47Z",
          "updatedAt": "2023-09-01T14:46:47Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "I_kwDOFUmh7s5mUaiC",
      "title": "Add header extensions to RTCP analysis",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/95",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "In #71 we added a section about header extensions to the RTCP analysis, but it does not include a table of all header extensions we considered. I think it makes sense to add one, just like we did for the RTCP packets, too.",
      "createdAt": "2023-05-19T05:17:31Z",
      "updatedAt": "2023-07-23T23:03:44Z",
      "closedAt": "2023-07-23T23:03:44Z",
      "comments": []
    },
    {
      "number": 103,
      "id": "I_kwDOFUmh7s5q87Zq",
      "title": "Reference new CLOSE_STREAM draft",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/103",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-07T21:10:36Z",
      "updatedAt": "2023-07-23T23:01:18Z",
      "closedAt": "2023-07-23T23:01:18Z",
      "comments": []
    },
    {
      "number": 104,
      "id": "I_kwDOFUmh7s5rGQIx",
      "title": "Add @spencerdawkins as co-author",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/104",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-10T13:35:33Z",
      "updatedAt": "2023-07-10T19:42:09Z",
      "closedAt": "2023-07-10T19:42:09Z",
      "comments": []
    },
    {
      "number": 107,
      "id": "I_kwDOFUmh7s5r5MRf",
      "title": "Clean up introduction of \"RTP over QUIC\" and \"RoQ\" terms in the draft",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/107",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "ISTM that \"RTP over QUIC\" and \"RoQ\" should appear in the Abstract and Introduction, but neither does, and we don't actually say that we're going to be referring to \"RTP over QUIC\" as \"RoQ\" in the document. ",
      "createdAt": "2023-07-18T15:21:14Z",
      "updatedAt": "2023-07-23T21:01:52Z",
      "closedAt": "2023-07-23T21:01:51Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "We have the following in the introduction:\r\n\r\n> The mapping described in this document is called RTP over QUIC (RoQ).\r\n\r\nBut adding it to the abstract might be good, too.",
          "createdAt": "2023-07-18T16:04:08Z",
          "updatedAt": "2023-07-18T16:04:08Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "I_kwDOFUmh7s5sTJgO",
      "title": "Check SHOULD requirements for ROQ receivers ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/111",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF119"
      ],
      "body": "This is probably premature, but I noticed \r\n\r\n> To send RTP/RTCP packets over QUIC streams, a sender MUST open a\r\n> new unidirectional QUIC stream. Streams are unidirectional because there is no\r\n> synchronous relationship between sent and received RTP/RTCP packets. A peer that\r\n> receives a bidirectional stream with a flow identifier that is associated with\r\n> an RTP or RTCP stream, **SHOULD** stop reading from the stream and send a\r\n> STOP\\_SENDING frame with the application protocol error code set to\r\n> ROQ\\_STREAM\\_CREATION\\_ERROR.\r\n\r\nAs I noted in comments on PR #91, that's a fundamental violation of the protocol (\"MUST open a new unidirectional QUIC stream\"). If that's a MUST, ISTM that we need to either make detecting bidirectional ROQ connections a MUST, or explain what would be likely to happen if the receiver just decides to read from the stream and - what - never write to it? or start writing to it, in spite of the stream violating the protocol? \r\n\r\nBut this is actually just a reminder that we need to look at SHOULDs for receivers, and make sure that it makes sense for a receiver to ignore the SHOULD action, and explain at least some of the likely consequences if the receiver does so. \r\n\r\nAs long as we're still writing significant normative text, it may make sense to wait and check all the SHOULDs at once, later in the process. As long as we don't forget. ",
      "createdAt": "2023-07-23T02:14:16Z",
      "updatedAt": "2024-02-20T07:45:44Z",
      "closedAt": "2024-02-20T07:45:44Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we've written enough text to justify looking at BCP 14 language, and especially at SHOULDs. I'll start on a PR for that. ",
          "createdAt": "2024-02-09T00:48:47Z",
          "updatedAt": "2024-02-09T00:48:47Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "I_kwDOFUmh7s5szNHB",
      "title": "RESET_STREAM and media dependencies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/112",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "wontfix",
        "NextInterim",
        "Discussion required"
      ],
      "body": "STOP_SENDING/RESET_STREAM currently does not allow sending media frames on a new QUIC stream if they were previously sent on a QUIC stream that received STOP_SENDING/RESET_STREAM. We need to figure out if that is a problem if there are dependencies between those media frames.",
      "createdAt": "2023-07-27T23:20:10Z",
      "updatedAt": "2023-10-16T14:50:49Z",
      "closedAt": "2023-10-16T14:50:49Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Consider the following scenario: A sender sends a group of pictures consisting of media frames A, B and C, where A is a keyframe, B depends on A, and C depends on B:\r\n\r\n`A <- B <- C`\r\n\r\nThe sender starts sending frames A and B on QUIC stream 1 but receives STOP_SENDING before it can send frame C. According to the draft (and RFC 9000), it now has to send RESET_STREAM on QUIC stream 1 and continue to send frame C on a different QUIC stream. Additionally, it MUST NOT retransmit frames A or B on *any* QUIC stream. If A or B was lost, sending frame C does not make sense since the receiver cannot decode it.\r\n\r\nSome options are:\r\n\r\n* Drop C and continue with the next frame that is decodable independently from A and B (and C)\r\n  * Problem: may unnecessarily drop frames\r\n* Send C as an independently decodable frame\r\n  * may not always be possible because it depends on interaction with the encoder.\r\n* Allow dependencies to be retransmitted on different streams\r\n  * Problem: Potentially results in situations where the receiver asks to stop, but the sender continues sending the same frames anyway, just on different QUIC streams.\r\n\r\n*Side note:* The real problem here is the receiver sending STOP_SENDING without knowing what trouble it is causing the sender. Maybe receivers should not try to be smart about what they read from streams and where to stop.\r\n\r\n*Comments on CLOSE_STREAM and ENOUGH:* These would enable the sender and receiver to agree on where exactly the receiver can stop reading from the current QUIC stream. We could then allow the sender to send everything following that offset on a different QUIC stream. However, we still have to solve the problem regarding STOP_SENDING.\r\n",
          "createdAt": "2023-09-15T10:37:17Z",
          "updatedAt": "2023-09-15T10:37:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "As of this moment, [Reliable QUIC Stream Resets](https://datatracker.ietf.org/doc/draft-ietf-quic-reliable-stream-reset/) is an adopted QUIC WG draft, and [Signaling That a QUIC Receiver Has Enough Stream Data](https://datatracker.ietf.org/doc/draft-thomson-quic-enough/) is still individual, but our understanding from @marten-seemann is that ENOUGH may be included in [Reliable QUIC Stream Resets](https://datatracker.ietf.org/doc/draft-ietf-quic-reliable-stream-reset/).",
          "createdAt": "2023-09-15T15:19:11Z",
          "updatedAt": "2023-09-15T15:19:11Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "NONE",
          "body": "@SpencerDawkins' understanding is correct, in fact, we have a PR that adds ENOUGH: https://github.com/quicwg/reliable-stream-reset/pull/26.\r\n\r\nHowever, at this point, it's not decided yet if this PR will get merged. I just sent an email to the QUIC and AVT mailing list, and it would be useful to discuss potential use cases for the frame there.",
          "createdAt": "2023-10-10T06:13:59Z",
          "updatedAt": "2023-10-10T06:13:59Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "A related issue for the CLOSE_STREAM/ENOUGH discussion is #113 . \r\n\r\nAs commented on the AVTCORE in QUIC mailing lists yesterday, I don't expect ENOUGH to be useful for RoQ, because it only allows a receiver to keep reading old frames while dropping newer ones, which doesn't seem useful in a real-time streaming application.\r\n\r\nAs discussed in the last interim meeting, it is the application's responsibility to figure out what to do in case a dependency of a frame is dropped with STOP_SENDING. I suggest labeling this issue as won't fix and closing it. ",
          "createdAt": "2023-10-11T09:28:08Z",
          "updatedAt": "2023-10-11T09:28:08Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins agrees with @mengelbart, that these mechanisms make great sense for reliable application streams (where you want to retransmit as little as possible, but with no gaps), but less sense for unreliable applications like RTP (where you want to see the newest media frames, and don't care about gaps). We can close this as \"wontfix\". ",
          "createdAt": "2023-10-16T14:50:49Z",
          "updatedAt": "2023-10-16T14:50:49Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "I_kwDOFUmh7s5szWt-",
      "title": "Given that we are doing STOP\\_SENDING, do we need CLOSE\\_STREAM?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/113",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "wontfix",
        "Not Yet",
        "external doc",
        "Discussion required"
      ],
      "body": "Assuming that CLOSE|_STREAM moves forward ...",
      "createdAt": "2023-07-27T23:56:46Z",
      "updatedAt": "2023-10-11T14:02:42Z",
      "closedAt": "2023-10-11T14:02:41Z",
      "comments": []
    },
    {
      "number": 114,
      "id": "I_kwDOFUmh7s5szXzF",
      "title": "Guidance on RoQ DATAGRAM use",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/114",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "question",
        "Discussion required",
        "IETF119"
      ],
      "body": "@SpencerDawkins and @mengelbart sait through some really interesting discussion at WEBTRAN about pooled connections ...",
      "createdAt": "2023-07-28T00:00:44Z",
      "updatedAt": "2024-02-20T18:38:07Z",
      "closedAt": "2024-02-20T18:38:07Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "The slides for that discussion are [here](https://datatracker.ietf.org/meeting/117/materials/slides-117-webtrans-ietf-117-webtrans-wg-slides-02), starting with slide 9. ",
          "createdAt": "2023-09-01T15:49:43Z",
          "updatedAt": "2023-09-01T15:49:43Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins thinks we moved automatically to supporting both QUIC streams and QUIC datagrams in RoQ, and he isn't sure whether support for QUIC datagrams is necessary, given the amount of complexity this introduces in the specification. We should be asking (on the mailing list and at IETF 118) whether support for QUIC datagrams as transport is useful, and whether it would allow application developers to do something they can't do with QUIC streams. \r\n\r\nIMO, of course ... :yum:",
          "createdAt": "2023-10-16T15:10:09Z",
          "updatedAt": "2023-10-16T15:10:09Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "The questions we have for the working group are\r\n\r\n1. Do we know that people are planning to use RoQ with QUIC DATAGRAMs? \r\n2. (With @aboba in the room) Do we know that people are **hoping** to use RoQ with QUIC DATAGRAMs in WebTransport? ",
          "createdAt": "2023-10-23T15:14:27Z",
          "updatedAt": "2023-10-23T15:14:27Z"
        },
        {
          "author": "samhurst",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We (BBC) have an ambition to support transparent tunnelling of existing UDP RTP flows via a RoQ-supporting RTP Mixers/Translators to extend existing RTP workflows, and I'm envisioning doing this over DATAGRAMs to give the smallest possible processing overhead. I'm actually gearing up to do some practical work to try and measure whether there's any practical differences in the approaches, but I don't envision having results by IETF 118 (and I can't make the meeting anyway).\r\n\r\nThis is all not using WebTransport, as it'll be on embedded devices without a browser.",
          "createdAt": "2023-10-23T15:54:01Z",
          "updatedAt": "2023-10-23T15:54:01Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @samhurst,\r\n\r\nThank you for the feedback on this!\r\n\r\n> We (BBC) have an ambition to support transparent tunnelling of existing UDP RTP flows via a RoQ-supporting RTP Mixers/Translators to extend existing RTP workflows, and I'm envisioning doing this over DATAGRAMs to give the smallest possible processing overhead.\r\n\r\nThis is very useful - I think there are at least a few other people who are considering this at a high level, for the reasons you mention. That said, \r\n\r\n> I'm actually gearing up to do some practical work to try and measure whether there's any practical differences in the approaches, \r\n\r\nThis is exactly (IMO) what we need to know - whether the conceptual advantages of using DATAGRAMs provides actual benefits over using QUIC streams, especially in some of the creative ways that we're trying to describe in [Section 3.1](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-rtp-with-quic-streams-quic-)  of the current editor's version. \r\n\r\n> but I don't envision having results by IETF 118 (and I can't make the meeting anyway).\r\n\r\n@mengelbart and I just labeled this issue Discussion Required, which means that we'll have a slide about it at IETF 118, but we're doing that to make progress, which in this case probably means that we're asking people with (informed) opinions, like yours, to say something, so we know how much the draft needs to say about RoQ with QUIC DATAGRAMs. \r\n\r\nIf other people have results, especially results they can share, explain, and answer questions about, I'll be pleased and impressed, but we wouldn't expect anyone to be able to provide results in the IETF 118 timeframe. \r\n\r\nBecause we'll have a slide on this, would you like for us to say this is something you're pursuing, and invite other people who are also pursuing this work with you? That could speed things up, or slow them down, but I wanted whether we ask the question to be helpful for you. \r\n\r\n> This is all not using WebTransport, as it'll be on embedded devices without a browser.\r\n\r\nThat's also good to know. Again, thank you for popping up - it's always helpful!",
          "createdAt": "2023-10-23T17:02:04Z",
          "updatedAt": "2023-10-23T17:02:29Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "From discussion at IETF 114\r\n\r\n> Spencer Dawkins: Would it be useful to give guidance on using streams vs datagrams? Or even switching from streams to datagrams after STOP_SENDING on a stream?\r\n> Bernard Aboba: Sending video over streams and audio over datagrams, for example, makes sense. However, switching doesn't make sense.\r\n> What should a receiver do if it receives a video frame over a QUIC stream, and packets from the same frame over datagrams?\r\n> Spencer (echoing Bernard): maybe the guidance should include \"pick either streams or datagrams for a media flow, but don't plan on doing both, or switching between them\"\r\n> Mo: MoQ is doing something similar here, and decided to allow senders to decide how to deliver media over streams or datagrams, not constrained by receiver preferences. But that may reflect MoQ almost always doing fan-out to many receivers, and we're probably talking about 1:1 here. But Mo agrees with Bernard that both streams and datagrams are useful.\r\n> Peter Thatcher: Another use case is FEC over datagrams for media over datagrams, with reliable media sent over streams. Agree this should be a sender optimization not dictated by receivers.",
          "createdAt": "2024-02-01T15:35:12Z",
          "updatedAt": "2024-02-01T15:35:12Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "From discussion at IETF 118\r\n\r\n> * For a given media stream, choose either streams or datagrams, don\u2019t switch\r\n> * Allow senders to optimize, e.g., audio/datagrams and video/streams or even I-frames/streams and P-/B-frames/datagrams, FEC use cases\r\n\r\nThese are somewhat contradictory. :stuck_out_tongue:\r\n\r\nOn balance, we should allow senders to make the right decision about what is carried in streams, what is carried in datagrams, and how RTP streams are switched between QUIC streams and QUIC DATAGRAMs.",
          "createdAt": "2024-02-11T01:44:49Z",
          "updatedAt": "2024-02-11T01:45:31Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins will review [Section 3.1](https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic#name-rtp-with-quic-streams-quic-) and see whether we can/need to say anything else. ",
          "createdAt": "2024-02-16T15:58:37Z",
          "updatedAt": "2024-02-16T15:58:37Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> @SpencerDawkins will review [Section 3.1](https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic#name-rtp-with-quic-streams-quic-) and see whether we can/need to say anything else.\r\n\r\nHaving reviewed [Section 3 in the current main branch](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-rtp-with-quic-streams-quic-), I think Section 3.1 says a lot about streams and datagrams, so adding a lot more material there probably isn't the right thing to do, but we've talked about a lot of considerations in this issue (and in the meeting discussions that we mentioned in comments), that probably ought to be included somewhere else. I suggest adding a guidance section as part of [Section 5](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-encapsulation) or [Section 7](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-congestion-control-and-rate). \r\n\r\nI'll start on a PR, and try to do the right thing, but am obviously interested in feedback. ",
          "createdAt": "2024-02-19T17:29:46Z",
          "updatedAt": "2024-02-19T17:29:46Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "@SpencerDawkins Aside from transport of media, there is also the question of whether RTCP should be sent over datagrams, streams or both. ",
          "createdAt": "2024-02-20T05:02:49Z",
          "updatedAt": "2024-02-20T05:02:49Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "I_kwDOFUmh7s5tz1Ty",
      "title": "Motivation: Exploiting Multiple Connections",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/115",
      "state": "CLOSED",
      "author": "gchandok",
      "authorAssociation": "NONE",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NotJustRTP",
        "Current Focus",
        "IETF119"
      ],
      "body": "Pasting the original text with some suggestions inline: \r\n\r\n1.2.6.  Exploiting Multiple Connections **[Migrating between multiple paths. Mention paths and not connections]**\t \t\t\r\n \t\t\r\n   Although there is much interest in multiplexing flows on a single\t \t\t\r\n   QUIC connection as described in Section 1.2.5, QUIC also provides the\t \t\t\r\n   capability of establishing and validating multiple paths for a single\t \t\t\r\n   QUIC connection [RFC9000].  Once multiple paths have been validated,\t \t\t\r\n   a sender can migrate from one path to another with no additional\t \t\t\r\n   signaling, allowing an endpoint to move from one endpoint address to\t \t\t\r\n   another without interruption, as long as only a single path is in\t \t\t\r\n   active use at any point in time.\t \t\t\r\n \t\t\r\n   Connection migration may be desireable for a number of reasons, but\t \t\t\r\n   to give one example, this allows a sender to distinguish between more\t \t\t\r\n   costly cellular paths and less costly WiFi paths, with no action\t \t\t\r\n   required from the application. **[RTP applications do need to know about path used being expensive/not since the application  may want to use a lower bitrate cap for an expensive path like cellular. So some action will be required from the application possibly at connection setup time to specify the caps in wants to use for each interface type]** ",
      "createdAt": "2023-08-09T01:18:02Z",
      "updatedAt": "2024-02-16T15:09:49Z",
      "closedAt": "2024-02-16T15:09:49Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We think this is a useful comment, but we want to make sure that the new text doesn't contradict other text that says the application doesn't need to do anything. \r\n\r\n@SpencerDawkins thinks this comment is opening up at least two interesting areas that we need to think about: \r\n\r\n- policy for path selection, and \r\n- API for RTP over QUIC. \r\n\r\nFor the policy question, we need to think about how the use case @gchandok describes maps onto QUIC connection migration and multipath QUIC. \r\n\r\nFor the API, @mengelbart was testing with QUIC-GO, which at that time didn't support connection migration. Current implementations seem to give applications more control over connection handling, so we need to investigate further. \r\n\r\nWe will keep these ideas here for now, but may need to open new issues in the (near) future. ",
          "createdAt": "2023-08-11T15:32:28Z",
          "updatedAt": "2023-08-11T15:32:28Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "... and then, @SpencerDawkins woke up.\r\n\r\n> @SpencerDawkins thinks this comment is opening up at least two interesting areas that we need to think about:\r\n> \r\n> *** policy for path selection, and**\r\n> * API for RTP over QUIC.\r\n> \r\n> **For the policy question, we need to think about how the use case @gchandok describes maps onto QUIC connection migration and multipath QUIC.**\r\n\r\nThe bolded part of this comment is only true, if \"we\" means the QUIC working group. \r\n\r\nPolicy for QUIC connection migration and multipath are both potential issues for any QUIC application, and I can't think of anything that's unique about RTP over QUIC, compared to any other QUIC application (for example, HTTP/3 over QUIC). \r\n\r\nI'd say providing ways to handle these policies is out of scope for this specification, and for the AVTCORE working group. \r\n\r\nIt does seem reasonable to more clearly distinguish between the motivations for connection migration and multipath in this specification. \r\n\r\n@aboba and @JonathanLennox, does that sound right to you?",
          "createdAt": "2024-02-10T23:45:19Z",
          "updatedAt": "2024-02-11T00:23:09Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "@SpencerDawkins I agree that it is important to separate out innovations in QUIC from the RTP over QUIC transport mapping.   There is still fundamental work going on in QUIC, and we may not be in a position to decide what is relevant and what is not, until RTP over QUIC has been implemented.",
          "createdAt": "2024-02-11T20:41:00Z",
          "updatedAt": "2024-02-11T20:41:00Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "I_kwDOFUmh7s5tz2Xx",
      "title": "Reasoning for not mandating a rate adaptation algorithm",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/116",
      "state": "CLOSED",
      "author": "gchandok",
      "authorAssociation": "NONE",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "\r\n\r\nA rate adaptation algorithm can be plugged in to adapt the media\r\n    bitrate to the available bandwidth.  This document does not mandate\r\n|   any specific rate adaptation algorithm, _because the desired response\r\n|   to congestion can be application and codec-specific.  For example,\r\n|   adjusting quantization in response to congestion may work well in\r\n|   many cases, but if what's being shared is video that includes text,\r\n|   maintaining readability is important._\r\n|\r\n|   As of this writing, the IETF has produced two Experimental-track rate\r\n|   adaptation specifications, Network-Assisted Dynamic Adaptation (NADA)\r\n|   [RFC8698] and Self-Clocked Rate Adaptation for Multimedia (SCReAM)\r\n|   [RFC8298]. \r\n\r\n\r\n**Rate adaptation mechanisms like NADA/SCREAM don\u2019t necessarily mandate how the encoder handles the rate changes. That handling may be codec specific so makes sense to leave it out. So the argument and example (in italics) don\u2019t seem appropriate in this section. Rate adaptation mechanism RFCs you mention above talk about how the sending rate should be computed, what feedback is needed and how traffic should be paced / shaped which are not codec specific. You can just say that application may pick a rate adaptation mechanism of its choice and this document does not mandate it. That should be sufficient**",
      "createdAt": "2023-08-09T01:24:54Z",
      "updatedAt": "2023-09-15T15:08:44Z",
      "closedAt": "2023-09-15T15:08:44Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@gchandok - let me take a look at this. I think it's useful to say something about why we wouldn't mandate ANY rate adaptation algorithm, but if I can't come up with better text, I agree that confusing text as currently isn't useful ... ",
          "createdAt": "2023-08-11T15:14:11Z",
          "updatedAt": "2023-08-11T15:14:11Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@gchandok - I've now taken a look at this, and I think our problem is that I am conflating two things that need to be described separately - the response that an application takes to adjust the encoded media stream it sends, and the mechanism that an application uses to decide how to send it. I think both of these are important to mention, but they are two different things, and need to be explained in a way that clearly distinguishes between them. \r\n\r\nI'm working on a PR for this ... ",
          "createdAt": "2023-09-01T10:21:06Z",
          "updatedAt": "2023-09-01T10:21:06Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "I_kwDOFUmh7s5tz2lx",
      "title": "Suppressing QUIC signaling in favor of RTCP signaling",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/117",
      "state": "CLOSED",
      "author": "gchandok",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "Because QUIC relies on certain frames being sent, it is\r\n   not possible to supress QUIC signaling in favor of RTCP signaling,\r\n\r\n**In Datagram mode, QUIC flow control and retransmissions are disabled. Also, this draft allows for congestion control to live in the application. So in this situation we should consider disabling ACK frames in the QUIC layer. What function do they provide? Those are probably the most common non-data frames that will be sent at quic layer**",
      "createdAt": "2023-08-09T01:26:16Z",
      "updatedAt": "2023-09-25T16:22:37Z",
      "closedAt": "2023-09-25T16:22:37Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins and @mengelbart are thinking about this, but we THINK there is some level of QUIC signaling that is required in order to look like a working QUIC connection. \r\n\r\n@SpencerDawkins is also remembering that there is a minimal level of RTCP RR reporting that is required for an RTP application to know that the (stateless) RTP session is still active. \r\n\r\nWhat we NEED to do, is make text about disabling/suppressing/whatever QUIC acks/congestion control and RTCP RR reporting match these two realities. \r\n\r\n@gchandok's observation about congestion control living in the application is important. We should also make sure that the implications that we describe are accurate. ",
          "createdAt": "2023-08-11T15:40:32Z",
          "updatedAt": "2023-08-11T15:40:32Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm talking about this issue with @mengelbart, and we think what's needed is a lot more nuanced than \"turning RTCP feedback off\" or \"turning QUIC feedback and related flow control/congestion control off\", but we don't think this is a lot of work. We can target the September virtual interim for PR text. ",
          "createdAt": "2023-09-01T15:13:59Z",
          "updatedAt": "2023-09-01T15:13:59Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "While the application can control rate, congestion control is handled by QUIC and can't be safely turned off.",
          "createdAt": "2023-09-03T11:20:18Z",
          "updatedAt": "2023-09-03T11:20:18Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "I_kwDOFUmh7s5tz2uh",
      "title": "Carrying SR NTP Timestamps at QUIC layer",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/118",
      "state": "CLOSED",
      "author": "gchandok",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "_SR_ NTP timestamps: We cannot send NTP timestamps in the same\r\n      format the SRs use, but couldn't a QUIC timestamp extension\r\n      provide the same information?\r\n\r\n**SR really carries an RTP timestamp to NTP time mapping that is required for lip sync. This cannot solely be provided at the QUIC layer since it does not know about RTP timestamps**",
      "createdAt": "2023-08-09T01:27:07Z",
      "updatedAt": "2023-09-22T07:46:10Z",
      "closedAt": "2023-09-22T07:46:10Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We think the action here is to remove the editor's note and clarify that QUIC signaling can't replace this, even with a timestamp extension. ",
          "createdAt": "2023-08-11T15:16:42Z",
          "updatedAt": "2023-08-11T15:16:42Z"
        }
      ]
    },
    {
      "number": 122,
      "id": "I_kwDOFUmh7s5v6VrN",
      "title": "Define how RoQ reacts to the absence of max_datagram_frame_size transport parameter",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/122",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "Current Focus"
      ],
      "body": "While working on a PR for Issue #93 I noticed the following text in [Section 3 of RFC 9221](https://datatracker.ietf.org/doc/html/rfc9221#name-transport-parameter):\r\n\r\n> Application protocols that use datagrams **MUST** define how they react to the absence of the max_datagram_frame_size transport parameter. If datagram support is integral to the application, the application protocol can fail the handshake if the max_datagram_frame_size transport parameter is not present.\r\n\r\nI don't think this belongs in a subsection of [Section 3 in the RoQ draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-protocol-overview), but we do need to do it, and we should talk about what the behavior should be before we add this to the draft (probably in [Section 4 of the ROQ draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-connection-establishment-an).",
      "createdAt": "2023-09-01T14:45:59Z",
      "updatedAt": "2024-02-11T01:55:38Z",
      "closedAt": "2023-10-23T14:27:50Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #13 ",
          "createdAt": "2023-09-01T15:29:59Z",
          "updatedAt": "2023-09-01T15:29:59Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart reminds me that including the max_datagram_frame_size transport parameter is how QUIC negotiates support for datagrams, so this issue is even more closely related to #13 than @SpencerDawkins thought ... :zany_face:\r\n\r\nWhat we are thinking is that we can't fail connection establishment because the max_datagram_frame_size transport parameter isn't specified, unless we know from signaling that the application intends to use datagrams, so we need to say that clearly in the draft, and then we have met the MUST defined in [Section 3 of RFC 9221](https://datatracker.ietf.org/doc/html/rfc9221#name-transport-parameter).",
          "createdAt": "2023-09-01T15:41:40Z",
          "updatedAt": "2023-09-01T15:41:40Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We note that the description of the decisions a RoQ receiver must make goes in [Section 3 in the RoQ draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-protocol-overview), but the errors if datagrams are signaled but not negotiated goes in [Section 4 of the ROQ draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-connection-establishment-an) ",
          "createdAt": "2023-09-01T16:04:25Z",
          "updatedAt": "2023-09-01T16:04:25Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "This is actually already explained in [section 5.3](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-5.3). We could also add it to the connection establishment section, although I'm not sure if that is really necessary. I don't think we need to add this detail to the protocol overview in section 3.",
          "createdAt": "2023-10-11T12:48:31Z",
          "updatedAt": "2023-10-11T12:48:31Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins notes that this is close enough to #13 that it could have been a duplicate. Even if it's not a duplicate, we can probably close both with one PR. ",
          "createdAt": "2023-10-16T14:55:17Z",
          "updatedAt": "2023-10-16T14:55:17Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@SpencerDawkins notes that he has apparently gotten lost on the original point for this (non- #13) point:\r\n\r\n> **Application protocols that use datagrams MUST define how they react** to the absence of the max_datagram_frame_size transport parameter. If datagram support is integral to the application, the application protocol can fail the handshake if the max_datagram_frame_size transport parameter is not present.\r\n\r\nThat is to say, it would be helpful to \r\n\r\n- point out that you can \"hope\" to use datagrams,\r\n- and even offer/answer that you want to use datagrams, \r\n- but if you don't negotiate the use of datagrams in the QUIC handshake, you've got some choices to make. \r\n\r\nWe do give a hint about this, in the current text:\r\n\r\n> If the use of an extension was signaled using a signaling protocol, but the extension was not negotiated during the QUIC handshake, a peer MAY close the connection with the ROQ_EXPECTATION_UNMET error code.\r\n\r\nBut then there's the question, what might the peer do **next**? \r\n\r\nI'll work on a PR for **that**. ",
          "createdAt": "2023-10-19T00:02:45Z",
          "updatedAt": "2023-10-19T00:08:52Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "I_kwDOFUmh7s5xyb2x",
      "title": "Review Appendix B for completeness",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/126",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "Discussion required",
        "IETF119"
      ],
      "body": "We have a lot of information in [Appendix B.  Considered RTCP Packet Types and RTP Header Extensions](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-list-of-optional-quic-exten), and it looks like we might have some missing table entry details, such as \r\n\r\n> Texas Instruments Extended VoIP Quality Block | | | |\r\n\r\nI see that one has a reference in the IANA registry that returns a 404, but we might want to say that in the table, just so readers know we didn't miss anything they need to know. And @joerg-ott is the designated expert for that registry - we should probably ask him how to report the 404, in case he has a better idea where to look than the current reference! :grin:\r\n\r\nAlso, it would be good for us to point to relevant IANA registries at the beginning of each section (for example, [RTP Control Protocol Extended Reports (RTCP XR) Block Type Registry](https://www.iana.org/assignments/rtcp-xr-block-types/rtcp-xr-block-types.xhtml).\r\n\r\n[B.5.1. Compact Header Extensions](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-sdes-compact-header-extensi) has several \"probably not(?)\" entries. Is this just because we haven't looked closely at the 3GPP specifications yet? We should probably look at that - RTP over QUIC should be relevant to 3GPP in the next 5G release or two. ",
      "createdAt": "2023-09-22T14:44:18Z",
      "updatedAt": "2024-02-16T15:08:37Z",
      "closedAt": "2024-02-16T15:08:37Z",
      "comments": []
    },
    {
      "number": 127,
      "id": "I_kwDOFUmh7s5x3YVR",
      "title": "Normative References",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/127",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "From the AVTCORE WG mailing list: https://mailarchive.ietf.org/arch/msg/avt/WH8OTXO7LT8IQzxPh2QwfeGVcF0/\r\n\r\nWith the QUIC specifications still evolving, this specification is put in a difficult position.  Beyond the basic QUIC specifications, there are extensions which could be of potential benefit.  However, some of the extensions are not yet WG work items, or are not widely deployed, or may take some time to be published as RFCs, or may never be published as RFCs.\r\n\r\nCurrently, the document has an Appendix A: List of Optional QUIC extensions, which states \"The following is a list of QUIC protocol extensions that might be beneficial for RoQ, but are not required by RoQ.\" Putting discussion of non-RFC QUIC extensions into a (non-normative) Appendix seems like a good idea, if it could allow the main specification to focus on the core QUIC functionality and avoid normative references to documents which may or may not ever be published as RFCs.\r\n\r\nHowever, the problem is that discussion of the extensions is not limited to the (non-normative) Appendix, but is contained in other sections, including Sections 7, 7.3.4 and 8.1.\r\n\r\nThis results in normative references to [I-D.draft-huitema-quic-ts], [I-D.draft-ietf-quic-ack-frequency] and [I-D.draft-smith-quic-receive-ts]. \u00b6\r\n\r\nI would like to suggest that the RTP over QUIC specification be restructured so as to only normatively reference documents which have been published as RFCs.\r\n\r\nFor this to work, material in Sections 6, 7 and 8 may need to be moved to Appendix A, which would presumably avoid normative references.",
      "createdAt": "2023-09-24T19:00:32Z",
      "updatedAt": "2023-10-23T14:12:44Z",
      "closedAt": "2023-10-23T14:12:43Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba - I have what I hope is a friendly amendment to this proposal:\r\n\r\n> I would like to suggest that the RTP over QUIC specification be restructured so as to only normatively reference documents which have been published as RFCs.\r\n\r\nI don't think limiting ourselves to published RFCs is quite right, but it's a step in the right direction. \r\n\r\nI think moving helpful commentary about things that might be done into appendices is a step in the right direction. This would include the observations we make about timestamps, etc. \r\n\r\nI think we might have exceptions to \"only published RFCs\" for drafts that are \r\n\r\n- adopted by QUIC or a similar WG, or \r\n- adopted and considered mature enough to wait for, or\r\n- past WGLC and somewhere in the publication requested/approved state machine. \r\n\r\nDoes that make sense?\r\n\r\nAssuming so, Mathis will propose a linked PR that moves what we think needs to be moved into appendices, and we'll talk, OK?",
          "createdAt": "2023-10-09T14:49:29Z",
          "updatedAt": "2023-10-09T14:49:29Z"
        }
      ]
    },
    {
      "number": 128,
      "id": "I_kwDOFUmh7s5x3kLt",
      "title": "Congestion Control and Rate Control",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/128",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "From the AVTCORE WG mailing list: https://mailarchive.ietf.org/arch/msg/avt/7IFLBJAmFbB3f1_OgkoPyN0lhT8/\r\n\r\nLooking over the coverage of Congestion Control and Rate Control, the two\r\ntopics appear to be conflated in places and also there appear to be some issues that\r\nhave not been fully considered.\r\n\r\nSection 1.2.2\r\n\r\nWhile the effect of QUIC's response to congestion means that some RTP\r\npackets will arrive at the receiver later than a user of the RTP flow might\r\nprefer, it is still preferable to \"ceasing transmission\" completely until\r\nthe RTP sender has a reason to believe that restarting the flow will not\r\nresult in congestion.\u00b6\r\n\r\n[BA] In contrast to circuit breakers, which do not restrict the ability to\r\nsend RTCP feedback, QUIC congestion control affects RTCP feedback, not just\r\nRTP.  So saying QUIC congestion control is \"preferable\" seems questionable.\r\n\r\nMoreover, when a single QUIC connection is used to multiplex both RTP-RTCP\r\nand non-RTP packets as described in Section 1.2.5\r\nthe QUIC connection will still be Internet-safe, with no coordination\r\nrequired.\r\n\r\n[BA] While it may be \"Internet-safe\", delays in RTCP feedback are likely to\r\ndestabilize rate control as well as resulting in challenges to A/V sync.\r\nSo not sure that \"Internet-safe\" is the only important metric here.\r\n\r\nSection 1.2.3\r\n\r\nOne word of caution is in order - RTP implementations may rely on at least\r\nsome minimal periodic RTCP feedback, in order to determine that an RTP flow\r\nis still active, and is not causing sustained congestion (as described in\r\nRFC8083, but since this \"periodicity\" is measured in seconds, the impact of this \"duplicate\"\r\nfeedback on path bandwidth utilization is likely close to zero.\r\n\r\n[BA] Under congestion, RTCP feedback can potentially be delayed\r\nsubstantially. Here the issue is not \"bandwidth utilization\" but whether\r\nRTCP receives the transport treatment required for control traffic.  Note\r\nalso that similar considerations apply to treatment of audio vs. video.\r\nSerious problems with a/v sync are possible (or even likely) under\r\ncongestion.\r\n\r\nSection 1.2.4\r\n\r\nThis is especially useful in certain conferencing topologies, where\r\notherwise senders have no choice but to use the lowest path MTU for all\r\nconference participants, but even in point-to-point RTP sessions, this also\r\nallows senders to piggyback audio media in the same UDP packet as video\r\nmedia, for example, and also allows QUIC receivers to piggyback QUIC ACK\r\nframes on any QUIC frames being transmitted in the other direction.\u00b6\r\n\r\n[BA] The draft does not talk much about piggybacking of audio and video\r\nmedia, but we have seen some implementations experimenting with this to\r\navoid audio/video sync issues without having to resort to other techniques\r\nsuch as prioritization.  Is this something that deserves more discussion?\r\n\r\nSection 2\r\n\r\nRate control:\r\n\r\nA congestion control mechanism that helps a sender determine and adjust its\r\nsending rate, in order to maximize the amount of information that is sent\r\nto a receiver, without causing queues to build beyond a reasonable amount,\r\ncausing \"buffer bloat\" and \"jitter\". Rate adapation is one way to\r\naccomplish congestion control for real-time media, especially when a sender\r\nhas multiple media streams to the receiver, because the sum of all sending\r\nrates for media streams must not be high enough to cause congestion on the\r\npath these media streams share between sender and receiver.\u00b6\r\n\r\n[BA] Rate control and congestion control are distinct. So the definition\r\nhere doesn't seem right, particularly for RoQ where congestion control is\r\nbuilt into QUIC while rate adaptation is application and even\r\ncodec-specific as you state later in the document. \r\n\r\nElsewhere in the document, the relationship is stated more clearly.  QUIC congestion\r\ncontrol limits the amount that can be sent. Since realtime applications\r\nseek to achieve low latency, they will typically prefer to respond to\r\nbandwidth limitations by controlling rate, rather than experiencing\r\nqueueing delays or increased loss.\r\n\r\nBut since congestion control and rate control are distinct and are handled\r\nat different layers, rate control is not \"one way to accomplish congestion\r\ncontrol\" but rather \"one way to respond to send rate limitations imposed by\r\ncongestion control algorithms\".\r\n\r\nSection 3\r\n\r\nA rate adaptation algorithm can be plugged in to adapt the media bitrate to\r\nthe available bandwidth. This document does not mandate any specific rate\r\nadaptation algorithm, because the desired response to congestion can be\r\napplication and codec-specific. For example, adjusting quantization in\r\nresponse to congestion may work well in many cases, but if what's being\r\nshared is video that includes text, maintaining readability is important.\r\n\r\n[BA] This text is good. I believe it should be placed earlier in the\r\ndocument (perhaps in the scope section).\r\n\r\nAs of this writing, the IETF has produced two Experimental-track rate\r\nadaptation specifications, Network-Assisted Dynamic Adaptation (NADA) [\r\nRFC8698 <https://www.rfc-editor.org/rfc/rfc8698>] and Self-Clocked Rate\r\nAdaptation for Multimedia (SCReAM) [RFC8298\r\n<https://www.rfc-editor.org/rfc/rfc8298>]. These rate adaptation algorithms\r\nrequire some feedback about the network's performance to calculate target\r\nbitrates. Traditionally this feedback is generated at the receiver and sent\r\nback to the sender via RTCP.\r\n\r\n[BA] Within the context of the previous paragraph is it correct to\r\ncharacterize these specifications as \"rate adaptation algorithms\"?  The\r\nprevious paragraph mentions QP-based rate control which is indeed codec and\r\napplication specific. NADA, SCReAM, gcc, etc. were developed as congestion\r\ncontrol algorithms and therefore they do not provide application and\r\ncodec-specific rate control mechanisms. Elswhere you characterize NADA\r\nand SCReAM as \"congestion control algorithms\", which seems correct.\r\n\r\nSection 6\r\n\r\nLike any other application on the internet, RoQ applications need a\r\nmechanism to perform congestion control to avoid overloading the network.\r\nWhile any generic congestion controller can protect the network, this\r\ndocument takes advantage of the opportunity to use rate adaptation\r\nmechanisms that are designed to provide superior user experiences for\r\nreal-time media applications.\u00b6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6-1>\r\n\r\n[BA] This paragraph appears to conflate congestion control and rate\r\ncontrol. Congestion control is built into QUIC, and RoQ therefore inherits\r\nit. So RoQ applications have a mechanism for congestion control.\r\n\r\nSince earlier it was stated that there is no normative guidance on rate\r\ncontrol, how can \"this document take advantage of the opportunity to use\r\nrate adaptation mechanisms that are designed to provide superior user\r\nexperiences\"?\r\n\r\nA wide variety of rate adaptation algorithms for real-time media have been\r\ndeveloped (for example, \"Google Congestion Controller\" [\r\nI-D.draft-ietf-rmcat-gcc\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-rmcat-gcc-02>]). The IETF\r\nhas defined two algorithms in two Experimental RFCs (e.g. SCReAM [RFC8298\r\n<https://www.rfc-editor.org/rfc/rfc8298>] and NADA [RFC8698\r\n<https://www.rfc-editor.org/rfc/rfc8698>]). These rate adaptation\r\nalgorithms for RTP are specifically tailored for real-time transmissions at\r\nlow latencies, but this section would apply to any rate adaptation\r\nalgorithm that meets the requirements described in \"Congestion Control\r\nRequirements for Interactive Real-Time Media\" [RFC8836\r\n<https://www.rfc-editor.org/rfc/rfc8836>].\r\n\r\n[BA] As noted earlier, NADA, etc. are not rate control algorithms (e.g.\r\nper-frame QP), they are congestion control algorithms and should be\r\nreferred to as such. \r\n\r\nThis document defines two architectures for congestion control and\r\nbandwidth estimation for RoQ, depending on whether most rate adaptation is\r\nperformed within a QUIC implementation at the transport layer, as described\r\nin Section 6.1\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#cc-quic-layer>,\r\nor within an RTP application layer, as described in Section 6.2\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#cc-application-layer>,\r\nbut this document does not mandate any specific congestion control or rate\r\nadaptation algorithm for either QUIC or RTP.\u00b6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6-3>\r\n\r\n[BA] QUIC implementations cannot implement rate control, because as you\r\nstate earlier, that is application and/or codec-specific. So again you seem\r\nto be conflating congestion control and rate control.\r\n\r\nIt is assumed that the congestion controller in use provides a pacing\r\nmechanism to determine when a packet can be sent to avoid bursts. The\r\ncurrently proposed congestion control algorithms for real-time\r\ncommunications (e.g. SCReAM and NADA) provide such pacing mechanisms. The\r\nuse of congestion controllers which don't provide a pacing mechanism is out\r\nof scope of this document.\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6-6>\r\n\r\n[BA] In this paragraph you correctly refer to SCReaM and NADA as congestion\r\ncontrol algorithms. Please use this terminology consistently.\r\n\r\nSection 6.1\r\n\r\nIf a QUIC implementation is to perform rate adaptation in a way that\r\naccommodates real-time media, one way for the implementation to recognize\r\nthat it is carrying real-time media is to be explicitly told that this is\r\nthe case. This document defines a new \"TLS Application-Layer Protocol\r\nNegotiation (ALPN) Protocol ID\", as described in Section 4\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#alpn>,\r\nthat a QUIC implementation can use as a signal to choose a real-time\r\nmedia-centric rate controller, but this is not required for ROQ deployments.\r\n\u00b6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6.1-2>\r\n\r\n[BA] Again, QUIC implementations do not perform rate adaptation. That is an\r\napplication layer function. I think you mean \"perform congestion control\"\r\nhere.\r\n\r\nCongestion control is orthogonal to the use of an ALPN, so mixing\r\nthese two concepts is problematic. \r\n\r\nIf congestion control is to be applied at the transport layer, it is\r\nRECOMMENDED that the QUIC Implementation uses a congestion controller that\r\nkeeps queueing delays short to keep the transmission latency for RTP and\r\nRTCP packets as low as possible, such as the IETF-defined SCReAM [RFC8298\r\n<https://www.rfc-editor.org/rfc/rfc8298>] and NADA [RFC8698\r\n<https://www.rfc-editor.org/rfc/rfc8698>] algorithms.\u00b6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6.1-3>\r\n\r\n[BA] You might also mention L4S here. This seems more likely to be\r\nsupported as a built-in QUIC CC mechanism than the other low latency\r\nalgorithms you mention in the draft.\r\n\r\nIf congestion control is done by the QUIC implementation, the application\r\nneeds a mechanism to query the currently available bandwidth to adapt media\r\ncodec configurations. The employed congestion controller of the QUIC\r\nconnection SHOULD expose such an API to the application. If a current\r\nbandwidth estimate is not available from the QUIC congestion controller,\r\nthe sender can either implement an alternative bandwidth estimation at the\r\napplication layer as described in Section 6.2\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#cc-application-layer>\r\n or a receiver can feedback the observed bandwidth through RTCP, e.g., using\r\n [I-D.draft-alvestrand-rmcat-remb\r\n<https://datatracker.ietf.org/doc/html/draft-alvestrand-rmcat-remb-03>].\u00b6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6.1-5>\r\n\r\n[BA] This paragraph is good, since it describes how the QUIC implementation\r\nprovides info to the application, to be used in rate control. I think you\r\nneed to be more clear about the relationship throughout the document. \r\n\r\nHowever, normative language is problematic because this document cannot have\r\nnormative API dependencies. Also, you need to be careful with references to\r\ndrafts which will not be published as RFCs, particularly REMB which has\r\nbeen deprecated in favor of transport CC.\r\n\r\nSection 6.2\r\n\r\nThe rate adaptation algorithms for RTP are specifically tailored for\r\nreal-time transmissions at low latencies, as described in Section 6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#congestion-control>.\r\nThe available rate adaptation algorithms expose a target_bitrate that can\r\nbe used to dynamically reconfigure media codecs to produce media at a rate\r\nthat can be sent in real-time under the observed network conditions.\u00b6\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6.2-2>\r\n\r\n[BA] Again, there is a conflation of rate adaptation and congestion\r\ncontrol. In this paragraph \"congestion control algorithms\" should be used\r\ninstead of \"rate control algorithms\".\r\n\r\nSection 6.3\r\n\r\nBecause QUIC is a congestion-controlled transport, as described in Section\r\n6.1\r\n<https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#cc-quic-layer>,\r\nand RTP applications can also perform congestion control and rate\r\nadaptation,\r\n\r\n[BA] Since congestion control is built into QUIC, RoQ applications can only\r\ndo rate control, not congestion control.\r\n\r\n   - Application-limited Media Flows - if an application chooses RTP as its\r\n   transport mechanism, the goal will be maximizing the user experience, not\r\n   maximizing path bandwidth utilization. If the application is, in fact,\r\n   transmitting media that does not saturate path bandwidth, and paces its\r\n   transmission, more heavy-handed congestion control mechanisms (drastic\r\n   reductions in the sending rate when loss is detected, with much slower\r\n   increases when losses are no longer detected) should rarely come into play.\r\n   If the application chooses ROQ as its transport, sends enough media to\r\n   saturate the path bandwidth, and does not adapt its own sending rate,\r\n   drastic measures will be required in order to avoid sustained or\r\n   oscillating congestion along the path.\u00b6\r\n   <https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#section-6.3-2.1>\r\n\r\n[BA] This document probably isn't the right place to discuss this, but it\r\nis a very big issue that has limited the deployment of the algorithms\r\nproduced by RMCAT, because probing was supported by gcc and not in the\r\nNADA, SCreAM, etc. In practice, fixing this problem requires probing\r\ncontrolled by the CC algorithm at the QUIC layer. So far I'm not aware of\r\nany QUIC implementations which support this kind of probing.\r\n",
      "createdAt": "2023-09-24T21:51:24Z",
      "updatedAt": "2023-10-23T16:40:17Z",
      "closedAt": "2023-10-23T14:26:29Z",
      "comments": [
        {
          "author": "fideltian",
          "authorAssociation": "NONE",
          "body": "Very interesting record. Is congestion control a must for RTP over Quic? why not let application layer to do congest control and bitrate control? Then it will have broad usage, especially on real time data or low latency data.\r\n\r\nAnother idea is  Why not raw UDP alike solution(such as Direct Sockets( https://wicg.github.io/direct-sockets/).) or limited \"congest control\" for \"RTP over Quic\".  \"Limited\" means satisfy the minimum requirement of security if really need.\r\n",
          "createdAt": "2023-10-09T10:26:15Z",
          "updatedAt": "2023-10-09T10:26:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I opened PR #134 to address some of these issues. See some comments below:\r\n\r\n> From the AVTCORE WG mailing list: https://mailarchive.ietf.org/arch/msg/avt/7IFLBJAmFbB3f1_OgkoPyN0lhT8/\r\n> \r\n> Looking over the coverage of Congestion Control and Rate Control, the two topics appear to be conflated in places and also there appear to be some issues that have not been fully considered.\r\n> \r\n> Section 1.2.2\r\n> \r\n> While the effect of QUIC's response to congestion means that some RTP packets will arrive at the receiver later than a user of the RTP flow might prefer, it is still preferable to \"ceasing transmission\" completely until the RTP sender has a reason to believe that restarting the flow will not result in congestion.\u00b6\r\n> \r\n> [BA] In contrast to circuit breakers, which do not restrict the ability to send RTCP feedback, QUIC congestion control affects RTCP feedback, not just RTP. So saying QUIC congestion control is \"preferable\" seems questionable.\r\n> \r\n> Moreover, when a single QUIC connection is used to multiplex both RTP-RTCP and non-RTP packets as described in Section 1.2.5 the QUIC connection will still be Internet-safe, with no coordination required.\r\n> \r\n> [BA] While it may be \"Internet-safe\", delays in RTCP feedback are likely to destabilize rate control as well as resulting in challenges to A/V sync. So not sure that \"Internet-safe\" is the only important metric here.\r\n> \r\n> Section 1.2.3\r\n> \r\n> One word of caution is in order - RTP implementations may rely on at least some minimal periodic RTCP feedback, in order to determine that an RTP flow is still active, and is not causing sustained congestion (as described in RFC8083, but since this \"periodicity\" is measured in seconds, the impact of this \"duplicate\" feedback on path bandwidth utilization is likely close to zero.\r\n> \r\n> [BA] Under congestion, RTCP feedback can potentially be delayed substantially. Here the issue is not \"bandwidth utilization\" but whether RTCP receives the transport treatment required for control traffic. Note also that similar considerations apply to treatment of audio vs. video. Serious problems with a/v sync are possible (or even likely) under congestion.\r\n\r\nI think these are good points, but since #134 is already quite large, I will create a new issue to address these separately.\r\n\r\n> Section 1.2.4\r\n> \r\n> This is especially useful in certain conferencing topologies, where otherwise senders have no choice but to use the lowest path MTU for all conference participants, but even in point-to-point RTP sessions, this also allows senders to piggyback audio media in the same UDP packet as video media, for example, and also allows QUIC receivers to piggyback QUIC ACK frames on any QUIC frames being transmitted in the other direction.\u00b6\r\n> \r\n> [BA] The draft does not talk much about piggybacking of audio and video media, but we have seen some implementations experimenting with this to avoid audio/video sync issues without having to resort to other techniques such as prioritization. Is this something that deserves more discussion?\r\n\r\nI think this could be addressed in #86.\r\n\r\n> Section 2\r\n> \r\n> Rate control:\r\n> \r\n> A congestion control mechanism that helps a sender determine and adjust its sending rate, in order to maximize the amount of information that is sent to a receiver, without causing queues to build beyond a reasonable amount, causing \"buffer bloat\" and \"jitter\". Rate adapation is one way to accomplish congestion control for real-time media, especially when a sender has multiple media streams to the receiver, because the sum of all sending rates for media streams must not be high enough to cause congestion on the path these media streams share between sender and receiver.\u00b6\r\n> \r\n> [BA] Rate control and congestion control are distinct. So the definition here doesn't seem right, particularly for RoQ where congestion control is built into QUIC while rate adaptation is application and even codec-specific as you state later in the document.\r\n\r\nI tried to fix this in #134. I added another definition for bandwidth estimation, because I think that was also conflated with the other terms. In my understanding, congestion control is what the transport layer does to avoid transmitting too much data in-flight and overloading the network. Bandwidth estimation is necessary to calculate a bitrate and rate adaptation is how a sender decides what to send while being limited to the estimated bandwidth. Congestion control should happen at QUIC layer and rate adaptation at the application, but bandwidth estimation can be done by both and depends on the APIs provided by QUIC.\r\n\r\nPlease let me know what you think about the changes I made. \r\n\r\n> Elsewhere in the document, the relationship is stated more clearly. QUIC congestion control limits the amount that can be sent. Since realtime applications seek to achieve low latency, they will typically prefer to respond to bandwidth limitations by controlling rate, rather than experiencing queueing delays or increased loss.\r\n> \r\n> But since congestion control and rate control are distinct and are handled at different layers, rate control is not \"one way to accomplish congestion control\" but rather \"one way to respond to send rate limitations imposed by congestion control algorithms\".\r\n> \r\n> Section 3\r\n> \r\n> A rate adaptation algorithm can be plugged in to adapt the media bitrate to the available bandwidth. This document does not mandate any specific rate adaptation algorithm, because the desired response to congestion can be application and codec-specific. For example, adjusting quantization in response to congestion may work well in many cases, but if what's being shared is video that includes text, maintaining readability is important.\r\n> \r\n> [BA] This text is good. I believe it should be placed earlier in the document (perhaps in the scope section).\r\n\r\nI will open another issue/pull request for this.\r\n\r\n> As of this writing, the IETF has produced two Experimental-track rate adaptation specifications, Network-Assisted Dynamic Adaptation (NADA) [ RFC8698 https://www.rfc-editor.org/rfc/rfc8698] and Self-Clocked Rate Adaptation for Multimedia (SCReAM) [RFC8298 https://www.rfc-editor.org/rfc/rfc8298]. These rate adaptation algorithms require some feedback about the network's performance to calculate target bitrates. Traditionally this feedback is generated at the receiver and sent back to the sender via RTCP.\r\n> \r\n> [BA] Within the context of the previous paragraph is it correct to characterize these specifications as \"rate adaptation algorithms\"? The previous paragraph mentions QP-based rate control which is indeed codec and application specific. NADA, SCReAM, gcc, etc. were developed as congestion control algorithms and therefore they do not provide application and codec-specific rate control mechanisms. Elswhere you characterize NADA and SCReAM as \"congestion control algorithms\", which seems correct.\r\n\r\nDo we need the reference to these algorithms in the overview section at all? As explained in the updated section 7, they can only be used when QUIC timestamp extensions are available and that is discussed in detail in section 7. I suggest removing this paragraph.\r\n\r\n> Section 6.3\r\n> \r\n> Because QUIC is a congestion-controlled transport, as described in Section 6.1 https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-05#cc-quic-layer, and RTP applications can also perform congestion control and rate adaptation,\r\n> \r\n> [BA] Since congestion control is built into QUIC, RoQ applications can only do rate control, not congestion control.\r\n\r\nI tried to shorten and merge this section into the previous one. Please let me know if you think we should keep it as a separate section.\r\n\r\n",
          "createdAt": "2023-10-10T14:11:08Z",
          "updatedAt": "2023-10-10T14:11:08Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @fideltian ,\r\n\r\nThanks for the comments! \r\n\r\n> Very interesting record. Is congestion control a must for RTP over Quic? why not let application layer to do congest control and bitrate control? Then it will have broad usage, especially on real time data or low latency data.\r\n\r\n@mengelbart and I have done multiple PRs about this, trying to get the explanation right in the editor's version, especially in [Section 1.2.2](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-always-on-internet-safe-con) and [Section 7](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-congestion-control-and-rate)\r\n\r\nThe part that we didn't actually write down was that we haven't talked to anyone who thinks that adding a mechanism for an (untrusted) application to disable QUIC-level congestion control is a good idea. We would have to force a draft about this through the QUIC working group, and that seemed like a problem if we wanted to deploy RoQ in a timely way. \r\n\r\nWhat we tried to say in  [Section 1.2.2](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-always-on-internet-safe-con) is that \r\n\r\n- QUIC will always be ready to do QUIC connection-level congestion control if it needs to do that, but \r\n- RoQ applications can do stream-level rate adaptation, and this ought to prevent or minimize packet loss that QUIC would detect and try to recover (retransmission, coarse adjustment of sending rate for the entire QUIC connection, etc.) \r\n\r\nPlease let us know if that's not clear from the (just merged about an hour ago) text. \r\n\r\n> Another idea is Why not raw UDP alike solution(such as Direct Sockets( https://wicg.github.io/direct-sockets/).) or limited \"congest control\" for \"RTP over Quic\". \"Limited\" means satisfy the minimum requirement of security if really need.\r\n\r\nThank you for pointing me to https://wicg.github.io/direct-sockets/ - I had not seen this previously. Apparently I lead a sheltered life. :upside_down_face:\r\n\r\nThis is actually a better question for @aboba and JonathanLennox, as AVTCORE chairs - speaking only for me, I'm not sure if this would be in scope for RoQ, and perhaps not in scope for AVTCORE. But I do have a couple of thoughts about this:\r\n\r\n- It would be helpful to have at least a high-level slide or two explaining what the API would allow application developers to do, that is difficult or impossible using existing/chartered IETF protocols, and whether this would require any work on the QUIC protocol, or on the RoQ protocol (so, this proposal would be for more than \"encapsulating RTP messages in UDP using the [UDPsocketinterface](https://wicg.github.io/direct-sockets/#udpsocket-interface)\".\r\n- - https://wicg.github.io/direct-sockets/ is (as I understand it) a W3C incubator community group for pre-standardization discussion, so that might be \"too soon\" for the IETF to charter protocol work that would support that API.\r\n- That's not to say it's too soon for people to talk about this possibility in the IETF, of course. \r\n\r\nIf this sounds like something you'd like to pursue, I'd suggest that you start by talking with the AVTCORE chairs, and being ready to talk to the DISPATCH chairs, in case the AVTCORE chairs don't think this idea would be in scope for them. \r\n\r\nBest wishes, of course!",
          "createdAt": "2023-10-23T16:40:17Z",
          "updatedAt": "2023-10-23T16:40:17Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "I_kwDOFUmh7s5x9c0R",
      "title": "CONNECTION_CLOSE does have an error phrase",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/129",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "[Section 8.4.4](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-8.4.4) claims that QUIC's CONNECTION_CLOSE cannot carry an error reason as a string, but that is not true, see [Section 19.19 of RFC9000](https://www.rfc-editor.org/rfc/rfc9000.html#section-19.19).",
      "createdAt": "2023-09-25T16:58:59Z",
      "updatedAt": "2023-10-16T13:33:23Z",
      "closedAt": "2023-10-16T13:33:23Z",
      "comments": []
    },
    {
      "number": 131,
      "id": "I_kwDOFUmh7s5yWVw3",
      "title": "Section 8.4.1: Mapping QUIC Feedback to RTCP Receiver Reports (\"RR\")",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/131",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "AVTCORE WG mailing list: https://mailarchive.ietf.org/arch/msg/avt/o6in-c7jAZ2mo0z8JKZdOEn5ZyA/\r\n\r\nRoQ section 10.1 \"Information to be exported from QUIC says:\r\n\r\n   - *Datagram Acknowledgment and Loss*: Section 5.2\r\n   <https://rfc-editor.org/rfc/rfc9221#section-5.2> of [RFC9221\r\n   <https://www.rfc-editor.org/rfc/rfc9221>] allows QUIC implementations to\r\n   notify the application that a QUIC Datagram was acknowledged or that it\r\n   believes a datagram was lost. The exposed information SHOULD include enough\r\n   information to allow the application to maintain a mapping between the\r\n   datagram that was acknowledged/lost and the RTP packet that was sent in\r\n   that datagram.\u00b6\r\n\r\nSince this only refers to Datagram Acknowledgment and Loss, this lead me to wonder  about the implications for other transport modes (e.g. frame/stream), particularly in scenarios where multiple SSRCs are sent over the same QUIC connection.\r\n\r\nRFC 3550 Section 6.4.2 defines the RTCP Receiver Report. \r\n\r\nAs noted in Section 8.4.1, an RTCP RR packet can provide information relating to multiple sources, each identified by their own SSRCs.   It is possible for multiple SSRCs to be sent over the same QUIC connection.\r\n\r\nSection 8.4.1 says:\r\n\r\nConsiderations for mapping QUIC feedback into *Receiver Reports* (PT=201,\r\nName=RR, [RFC3550 <https://www.rfc-editor.org/rfc/rfc3550>]) are:\u00b6\r\n\r\n   - *Fraction lost*: When RTP packets are carried in QUIC datagrams, the\r\n   fraction of lost packets can be directly inferred from QUIC's\r\n   acknowledgments. The calculation SHOULD include all packets up to the\r\n   acknowledged RTP packet with the highest RTP sequence number. Later packets\r\n   SHOULD be ignored, since they may still be in flight, unless other QUIC\r\n   packets that were sent after the RTP packet, were already acknowledged.\u00b6\r\n   <https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic/#section-8.4.1-2.1>\r\n\r\n   - *Cumulative lost*: Similar to the fraction of lost packets, the\r\n   cumulative loss can be inferred from QUIC's acknowledgments including all\r\n   packets up to the latest acknowledged packet.\r\n\r\n   - *Highest Sequence Number received*: In RTCP, this field is a 32-bit\r\n   field that contains the highest sequence number a receiver received in an\r\n   RTP packet and the count of sequence number cycles the receiver has\r\n   observed. A sender sends RTP packets in QUIC packets and receives\r\n   acknowledgments for the QUIC packets. By keeping a mapping from a QUIC\r\n   packet to the RTP packets encapsulated in that QUIC packet, the sender can\r\n   infer the highest sequence number and number of cycles seen by the receiver\r\n   from QUIC acknowledgments.\r\n\r\n[BA] As you note, for the sender to compute the info in the RTCP RR (including Fraction Lost, Cumulative Lost, Highest Sequence Number received, etc.) it is necessary for the sender to keep a mapping of QUIC packets to RTP packet info (e.g. SSRC, sequence number).\r\n\r\nSince Section 10.1 only mentions datagrams, is it envisaged that such a mapping will be maintained for frame/stream transport? Does the existing RoQ implementation support the mapping of QUIC ACKs to RTP info for frame/stream transport?\r\n\r\n   - *Interarrival jitter*: If QUIC acknowledgments carry timestamps as\r\n   described in [I-D.draft-smith-quic-receive-ts\r\n   <https://datatracker.ietf.org/doc/html/draft-smith-quic-receive-ts-00>],\r\n   senders can infer the interarrival jitter from the arrival timestamps in\r\n   QUIC acknowledgments.\u00b6\r\n   <https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic/#section-8.4.1-2.4>\r\n   - *Last SR*: Similar to lost packets, the NTP timestamp of the last\r\n   received sender report can be inferred from QUIC acknowledgments.\u00b6\r\n   <https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic/#section-8.4.1-2.5>\r\n   - *Delay since last SR*: This field is not required when the receiver\r\n   reports are entirely replaced by QUIC feedback.\r\n\r\n[BA] Given that Section 10.1 only mentions datagrams, is there an assumption that RTCP RRs/SRs are sent using QUIC datagrams? In some QUIC implementations, datagrams are prioritized over reliable streams, which might help ensure that RTCP traffic isn't subject to excess delays or starvation.\r\n",
      "createdAt": "2023-09-29T01:14:05Z",
      "updatedAt": "2023-10-23T14:59:38Z",
      "closedAt": "2023-10-23T14:59:38Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba, \r\n\r\nI think the key problem you're pointing out is here: \r\n\r\n> [BA] Given that **Section 10.1 only mentions datagrams**, is there an assumption that RTCP RRs/SRs are sent using QUIC datagrams? \r\n\r\nMy suggestion is to make sure section 10.1 contains equivalent guidance for streams. \r\n\r\nDoes that make sense?",
          "createdAt": "2023-10-09T14:56:48Z",
          "updatedAt": "2023-10-09T14:56:48Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "I_kwDOFUmh7s5zXNuk",
      "title": "Congestion and rate control in motivation section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/135",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "Current Focus"
      ],
      "body": "From @aboba in https://github.com/mengelbart/rtp-over-quic-draft/issues/128:\r\n\r\n> \r\n> Looking over the coverage of Congestion Control and Rate Control, the two\r\n> topics appear to be conflated in places and also there appear to be some issues that\r\n> have not been fully considered.\r\n> \r\n> Section 1.2.2\r\n> \r\n> While the effect of QUIC's response to congestion means that some RTP\r\n> packets will arrive at the receiver later than a user of the RTP flow might\r\n> prefer, it is still preferable to \"ceasing transmission\" completely until\r\n> the RTP sender has a reason to believe that restarting the flow will not\r\n> result in congestion.\u00b6\r\n> \r\n> [BA] In contrast to circuit breakers, which do not restrict the ability to\r\n> send RTCP feedback, QUIC congestion control affects RTCP feedback, not just\r\n> RTP. So saying QUIC congestion control is \"preferable\" seems questionable.\r\n> \r\n> Moreover, when a single QUIC connection is used to multiplex both RTP-RTCP\r\n> and non-RTP packets as described in Section 1.2.5\r\n> the QUIC connection will still be Internet-safe, with no coordination\r\n> required.\r\n> \r\n> [BA] While it may be \"Internet-safe\", delays in RTCP feedback are likely to\r\n> destabilize rate control as well as resulting in challenges to A/V sync.\r\n> So not sure that \"Internet-safe\" is the only important metric here.\r\n> \r\n> Section 1.2.3\r\n> \r\n> One word of caution is in order - RTP implementations may rely on at least\r\n> some minimal periodic RTCP feedback, in order to determine that an RTP flow\r\n> is still active, and is not causing sustained congestion (as described in\r\n> RFC8083, but since this \"periodicity\" is measured in seconds, the impact of this \"duplicate\"\r\n> feedback on path bandwidth utilization is likely close to zero.\r\n> \r\n> [BA] Under congestion, RTCP feedback can potentially be delayed\r\n> substantially. Here the issue is not \"bandwidth utilization\" but whether\r\n> RTCP receives the transport treatment required for control traffic. Note\r\n> also that similar considerations apply to treatment of audio vs. video.\r\n> Serious problems with a/v sync are possible (or even likely) under\r\n> congestion.",
      "createdAt": "2023-10-10T14:12:19Z",
      "updatedAt": "2024-02-11T01:55:39Z",
      "closedAt": "2023-10-23T14:42:45Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> Looking over the coverage of Congestion Control and Rate Control, the two\r\ntopics appear to be conflated in places and also there appear to be some issues that\r\nhave not been fully considered.\r\n\r\n@SpencerDawkins notes that the subtle definitions of congestion control and rate adaptation have morphed in the decades since Van Jacobson introduced slow start, congestion avoidance, etc. One of the most obvious differences is that even the mechanisms that focus on \"defending the network\" are now likely to include some form of \"chirping\", to avoid bufferbloat, etc. \r\n\r\nIt would be useful to actually point this out in the RoQ document, point to the definitions we have included in the terminology section, and say that guessing what we mean without looking at the definitions will probably be confusing at best. ",
          "createdAt": "2023-10-16T15:05:13Z",
          "updatedAt": "2023-10-19T14:58:29Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba, thank you for the pushback. I wrote much of the text you are commenting on, and I appreciate feedback representing the endpoint's point of view, and not just the network's point of view. \r\n\r\nI'm working on a PR for this now. I'll ask you to look it over, when it's in the repo. ",
          "createdAt": "2023-10-19T13:03:29Z",
          "updatedAt": "2023-10-19T13:03:29Z"
        }
      ]
    },
    {
      "number": 136,
      "id": "I_kwDOFUmh7s5zeKVp",
      "title": "Allow to continue sending media on QUIC datagrams after receiving STOP_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/136",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "> When a RoQ sender receives a STOP\\_SENDING frame for the last open stream available to send RTP/RTCP-data, the RoQ sender MUST open one or more new QUIC streams before sending new media frames. \r\n\r\nAlternatively, it could also continue to send media frames in QUIC datagrams. I think the important bit here is, that the receiver MUST continue to send media of the same media stream.",
      "createdAt": "2023-10-11T09:19:20Z",
      "updatedAt": "2023-10-16T14:04:26Z",
      "closedAt": "2023-10-16T14:04:26Z",
      "comments": []
    },
    {
      "number": 141,
      "id": "I_kwDOFUmh7s5z9-7C",
      "title": "Move CC paragraph to scope section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/141",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "Current Focus"
      ],
      "body": "From @aboba in #128:\r\n\r\n> Section 3\r\n> \r\n> A rate adaptation algorithm can be plugged in to adapt the media bitrate to\r\n> the available bandwidth. This document does not mandate any specific rate\r\n> adaptation algorithm, because the desired response to congestion can be\r\n> application and codec-specific. For example, adjusting quantization in\r\n> response to congestion may work well in many cases, but if what's being\r\n> shared is video that includes text, maintaining readability is important.\r\n> \r\n> [BA] This text is good. I believe it should be placed earlier in the\r\n> document (perhaps in the scope section).\r\n\r\n",
      "createdAt": "2023-10-16T16:20:09Z",
      "updatedAt": "2024-02-11T01:55:39Z",
      "closedAt": "2023-10-23T14:08:43Z",
      "comments": []
    },
    {
      "number": 142,
      "id": "I_kwDOFUmh7s50RBVf",
      "title": "Add text for configuring unidirectional RoQ streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/142",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "Current Focus"
      ],
      "body": "A LONG time ago, in [an issue far, far away](https://github.com/mengelbart/rtp-over-quic-draft/issues/13#issuecomment-1172980290), @LPardue said\r\n\r\nYou're right about zero credits, that could always happen. HTTP/3 recommends at least 100 concurrent bidirectional streams at any time https://www.rfc-editor.org/rfc/rfc9114.html#section-6.1-2. Section 6.1 and 6.2 more broadly discuss considerations for flow control and unidirectional streams. I'd suggest other application mappings think of similar guidance.\r\n\r\nThat's gotten a bit lost, up until now, and it doesn't have anything to do with datagrams. I'm moving that to its own issue (here)",
      "createdAt": "2023-10-18T20:43:06Z",
      "updatedAt": "2024-02-11T01:55:40Z",
      "closedAt": "2023-10-23T14:23:24Z",
      "comments": []
    },
    {
      "number": 147,
      "id": "I_kwDOFUmh7s50qu03",
      "title": "Make sure \"QUIC datagram\" (the UDP payload) and \"QUIC DATAGRAM\" (the frame type) are used consistently",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/147",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart",
        "SpencerDawkins"
      ],
      "labels": [
        "documentation",
        "IETF119"
      ],
      "body": "We say that \"datagram\" has two meanings in the terminology section, and say that \"datagram\" without qualification refers to [QUIC DATAGRAM frames](https://www.rfc-editor.org/rfc/rfc9221), but if we always qualify the term, that would be easier for the reader. ",
      "createdAt": "2023-10-23T14:49:47Z",
      "updatedAt": "2024-02-21T02:19:18Z",
      "closedAt": "2024-02-21T02:19:18Z",
      "comments": []
    },
    {
      "number": 149,
      "id": "I_kwDOFUmh7s52YtoN",
      "title": "Incorrect use of term \"rate adaptation\" instead of congestion control",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/149",
      "state": "CLOSED",
      "author": "gchandok",
      "authorAssociation": "NONE",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "\"A wide variety of congestion control algorithms for real-time media\r\n   have been developed (for example, \"Google Congestion Controller\"\r\n   [I-D.draft-ietf-rmcat-gcc]).  The IETF has defined two algorithms in\r\n   two Experimental RFCs (SCReAM [RFC8298] and NADA [RFC8698]).  These\r\n   algorithms for RTP are specifically tailored for real-time\r\n   transmissions at low latencies, but this section would apply to any\r\n   **rate adaptation algorithm** that meets the requirements described in\r\n   \"Congestion Control Requirements for Interactive Real-Time Media\"\r\n   [RFC8836].\"\r\n\r\nPlease replace   **rate adaptation algorithm** with congestion control algorithm since the algorithms being discussed are congestion control algorithms",
      "createdAt": "2023-11-09T18:32:08Z",
      "updatedAt": "2024-02-09T09:43:31Z",
      "closedAt": "2024-02-09T09:43:31Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@gchandok - I agree with this, and I can prepare a PR for it. \r\n\r\nJust as background - both @mengelbart and I have made passes over this draft trying to get the usages of \"rate adaptation\" and \"congestion control\" right. Mathis made the most recent pass for issue [128](https://github.com/mengelbart/rtp-over-quic-draft/issues/128) from @aboba, so it's my turn now. \t:yum:",
          "createdAt": "2023-11-10T06:35:52Z",
          "updatedAt": "2023-11-10T06:35:52Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Just for the notes: \r\n\r\n> Please replace rate adaptation algorithm with congestion control algorithm since the algorithms being discussed are congestion control algorithms\r\n\r\nis more accurately \r\n\r\n> Please replace rate adaptation algorithm with congestion control algorithm since the algorithms being discussed DESCRIBE THEMSELVES AS congestion control algorithms  :laughing:",
          "createdAt": "2024-02-01T15:50:17Z",
          "updatedAt": "2024-02-01T15:50:17Z"
        }
      ]
    },
    {
      "number": 157,
      "id": "I_kwDOFUmh7s5-_FnN",
      "title": "Add references for each IANA reference named in the document",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/157",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "documentation",
        "IETF119"
      ],
      "body": "@mengelbart noticed that the link in our document for DBI is broken, and @SpencerDawkins noticed that we don't seem to have references for each IANA registry that we name in the document. It would be good to add them, and clean up the DBI reference. ",
      "createdAt": "2024-02-12T16:12:52Z",
      "updatedAt": "2024-02-20T08:11:20Z",
      "closedAt": "2024-02-20T08:11:20Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "References go in Section 8.4 and for each table in Appendix B subsections. \r\n\r\nWhat happened was, @SpencerDawkins used the RFC references that CREATED each registry of interest, but didn't add references for the registries themselves. THAT'S what Spencer needs to fix. ",
          "createdAt": "2024-02-12T17:37:34Z",
          "updatedAt": "2024-02-12T17:37:34Z"
        }
      ]
    },
    {
      "number": 159,
      "id": "I_kwDOFUmh7s5_fOUy",
      "title": "Multiplexing RTP/RTCP with other protocols",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/159",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF119"
      ],
      "body": "We discussed multiplexing at the 2024-avtcore-01 interim meeting and I offered to write a PR that replaces the current multiplexing scheme with one that only allows RTP/RTCP but no other protocols. Other protocols can still be multiplexed with new ALPNs, but those have to be specified in other documents. See [draft-engelbart-quic-data-channels](https://datatracker.ietf.org/doc/draft-engelbart-quic-data-channels/) and [draft-engelbart-multiplex-roq-qdc](https://datatracker.ietf.org/doc/draft-engelbart-multiplex-roq-qdc/) for an example.",
      "createdAt": "2024-02-16T15:52:17Z",
      "updatedAt": "2024-02-21T02:24:36Z",
      "closedAt": "2024-02-21T02:24:36Z",
      "comments": []
    },
    {
      "number": 160,
      "id": "I_kwDOFUmh7s5_fUdL",
      "title": "Moving details about ECN and L4S from terminology to the right place in Section 7 (probably 7.1)",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/160",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "documentation",
        "IETF119"
      ],
      "body": "There are WAY too many details to be in a terminology section, especially when the draft already has a section where they are more appropriate!",
      "createdAt": "2024-02-16T16:04:13Z",
      "updatedAt": "2024-02-20T14:58:38Z",
      "closedAt": "2024-02-20T14:58:38Z",
      "comments": []
    },
    {
      "number": 161,
      "id": "I_kwDOFUmh7s5_fW2D",
      "title": "Adding descriptions of experiments and future work for publication as Experimental ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/161",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart",
        "joerg-ott",
        "SpencerDawkins"
      ],
      "labels": [
        "IETF119"
      ],
      "body": "@aboba suggested that we add this issue, at the [interim-2024-avtcore-01](https://datatracker.ietf.org/meeting/interim-2024-avtcore-01/session/avtcore) meeting, Various points described here might end up in the shepherd write-up, a \"future work\" section in the document, or both. \r\n\r\nBetter understanding of useful guidelines and recommendations for congestion control and rate adaptation for multiple RoQ flows (whether streams or datagrams). \r\n\r\nGuidance for using RoQ over QUIC multipath. \r\n\r\nCoexistence between RoQ on its own ALPN and QUIC over ICE, if the QUIC working group produces a \"QUIC with ICE\" specification. \r\n\r\nStable reference for implementers to interop test with, and report results. ",
      "createdAt": "2024-02-16T16:10:07Z",
      "updatedAt": "2024-02-29T15:13:54Z",
      "closedAt": "2024-02-29T15:13:54Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "This s a good start.  A few others to consider: \r\n\r\n* Transport for RTCP (e.g. QUIC streams vs. datagrams)\r\n* Role of QUIC extensions (e.g. to estimate one-way transit)\r\n* Realtime-friendly congestion control algorithms (COPA, L4S, etc.)",
          "createdAt": "2024-02-17T18:31:00Z",
          "updatedAt": "2024-02-17T18:31:00Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba - thanks for the additions. \r\n\r\nI think we are talking about two different things, but they both need to be in the document:\r\n\r\n- Topics that we need QUIC extensions to address, or address well, and \r\n- Topics that we need implementation experience with in order to address, or address well. \r\n\r\nThe first category would be directions for future work on RoQ in AVTCORE.\r\nThe second category would be \"why this document is published as experimental\"\r\n\r\nDoes that make sense?",
          "createdAt": "2024-02-19T16:57:17Z",
          "updatedAt": "2024-02-19T16:57:17Z"
        }
      ]
    },
    {
      "number": 163,
      "id": "I_kwDOFUmh7s5_l9Hu",
      "title": "General clean-up of the current draft",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/163",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mengelbart",
        "joerg-ott",
        "SpencerDawkins"
      ],
      "labels": [
        "documentation",
        "NextInterim"
      ],
      "body": "While working on PRs, I noticed that the current main branch does have some spelling mistakes and a few grammar mistakes. \r\n\r\nI suggest that we finish our post-interim burst of PR merging, and then review the document carefully. The sense I have from recent discussion is that we won't be making many more changes to the specification before requesting WGLC and then asking @aboba and @JonathanLennox to request publication, so we will need to clean up the draft soon. ",
      "createdAt": "2024-02-17T23:29:59Z",
      "updatedAt": "2024-04-18T14:45:31Z",
      "closedAt": "2024-04-18T14:45:30Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @SpencerDawkins split off the Editor's Notes resolution into two new issues (#181 and #182), and changed the description of this issue to remove the mention of Editor's Notes here. ",
          "createdAt": "2024-02-29T16:48:31Z",
          "updatedAt": "2024-02-29T16:48:31Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We have several merged PRs to show the WG at IETF 119, plus two more proposed PRs for #181 and #182, so it makes sense to @SpencerDawkins to defer actual editorial cleanup until after IETF 119. ",
          "createdAt": "2024-02-29T17:05:43Z",
          "updatedAt": "2024-02-29T17:05:43Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not going to create another issue for this **now**, but I do want to go over the draft looking at uses of QUIC  \"senders\" and \"receivers\". The QUIC specifications could have been a lot more general-purpose than they turned out, but everyone knew they would be used for HTTP/3, so a lot of \"client\" and \"server\" language ended up in RFC 9000 and its close relatives, reflecting the usage in HTTP/3. That was great for HTTP/3, but not as great for RoQ. \r\n\r\nI think we were usually aware of that - that's why we used \"sender\", \"receiver\", and \"endpoint\" - but even if we were entirely consistent, it would be good for us to include a note to the reader about the terminology in RoQ if someone is trying to match the guidance we give in RoQ to the QUIC mechanisms that are defined in QUIC specs. ",
          "createdAt": "2024-03-08T15:44:48Z",
          "updatedAt": "2024-03-08T15:44:48Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> This document describes an application usage of QUIC ([[RFC9308](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC9308)]). As a baseline, the document does not expect more than a standard QUIC implementation as defined in [[RFC8999](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC8999)], [[RFC9000](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC9000)], [[RFC9001](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC9001)], and [[RFC9002](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC9002)], providing a secure end-to-end transport **that is also expected to work well through NATs and firewalls**.\r\n\r\nIs this last part (highlighted) correct, as far as we're concerned? ",
          "createdAt": "2024-04-10T15:00:21Z",
          "updatedAt": "2024-04-10T15:00:21Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Yes and no. If you only want to use QUIC streams, it should be fine. If you want datagrams, you need RFC 9221. I think we may want to add that constraint to the text.",
          "createdAt": "2024-04-10T15:09:43Z",
          "updatedAt": "2024-04-10T15:09:43Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yes and no. If you only want to use QUIC streams, it should be fine. If you want datagrams, you need RFC 9221. I think we may want to add that constraint to the text.\r\n\r\nI'm actually asking about \"working well through NATs and firewalls. I am also noticing \r\n\r\n> The above implies that **RoQ is targeted at peer-to-peer operation**; but it may also be used in client-server-style settings, e.g., when talking to a conference server as described in RFC 7667 ([[RFC7667](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC7667)]), or, if RoQ is used to replace RTSP ([[RFC7826](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC7826)]), to a media server.\r\n\r\nI THINK the point is \"peer to peer will work fine if you set up QUIC connections directly to the right places, and this document doesn't describe how that happens, and that description should be in some other document\", but I should probably say that clearly. ",
          "createdAt": "2024-04-10T15:14:00Z",
          "updatedAt": "2024-04-10T15:14:00Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "As part of my clean-up review, I'm seeing a bunch of \"may\" and even \"should\" language in lower case. \r\n\r\nThe draft uses the current BCP14 boilerplate, which says \r\n\r\n> The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [[RFC2119](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC2119)] [[RFC8174](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC8174)] **when, and only when, they appear in all capitals, as shown here.**\r\n\r\nEven given that updated BCP14 boilerplate, I'm more comfortable changing these to \"might\", \"can\", \"ought to\", etc. because so many implementers were familiar with pre-RFC8174 normative language, which wasn't limited to upper-case. I'm swapping these out now - please stop me if that's a bad idea. ",
          "createdAt": "2024-04-11T13:57:13Z",
          "updatedAt": "2024-04-11T13:57:13Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm also noticing a bunch of \"RTP/RTCP\" strings in [the Encapsulation section](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-encapsulation). None of these seem to distinguish between RTP data transport protocol and RTP control protocol, and we added this note (recently), \r\n\r\n> Note to the Reader: [RFC3550] actually describes two closely-related protocols - the RTP Data Transfer Protocol Section 5 of [RFC3550], and the RTP Control Protocol Section 6 of [RFC3550]. In this document, the term \"RTP\" refers to the combination of RTP Data Transfer Protocol and RTP Control Protocol, because the distinction isn't relevant for encapsulation, and the term \"RTCP\" always refers to the RTP Control Protocol.\r\n\r\nso I'm changing them to \"RTP\".  ",
          "createdAt": "2024-04-11T15:09:11Z",
          "updatedAt": "2024-04-11T15:09:11Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "In this text, \r\n\r\n> To send RTP/RTCP packets over QUIC streams, a sender MUST open at least one new unidirectional QUIC stream. RoQ uses unidirectional streams, because there is no synchronous relationship between sent and received RTP/RTCP packets. \r\n\r\nQUIC streams could use [either of two unidirectional stream ID types](https://datatracker.ietf.org/doc/html/rfc9000#stream-id-types), depending on whether the stream is client-initiated or server-initiated. \r\n\r\nI don't see any indication in the RoQ specification that says whether we expect RoQ endpoints know whether they are opening QUIC connections as QUIC clients or QUIC servers. Do you think we've said that? If so, where? If not, should we say something about that?\r\n\r\n(I'm guessing that QUIC implementations written for HTTP/3 would know which they are, and would be at least somewhat confused if an implementation thought it was a server and received a STREAM frame with a new stream ID saying it was \"Server-Initiated, Unidirectional\", or was a client and received a STREAM frame with a new stream ID saying it was \"Client-Initiated, Unidirectional\")\r\n\r\nI suspect we do need to say something about whether RoQ endpoints care whether they are QUIC clients or servers, because we say \r\n\r\n> The amount of data that the client can send in QUIC 0-RTT is controlled by the initial_max_data transport parameter supplied by the server. This is described in more detail in {{Section 4.6.1 of !RFC9001}}.",
          "createdAt": "2024-04-11T15:58:55Z",
          "updatedAt": "2024-04-11T16:07:22Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We use the term \"peer\" 21 times in the document. We might want to define that, or qualify it (as something like \"peer endpoint\", with \"endpoint\" already being defined). ",
          "createdAt": "2024-04-11T22:48:45Z",
          "updatedAt": "2024-04-11T22:49:56Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We say \r\n\r\n> The currently proposed congestion control algorithms for real-time communications (e.g., SCReAM and NADA) provide such pacing mechanisms, **and QUIC recommends pacing for senders based on the congestion control algorithm.**\u00b6\r\n\r\nI think the bolded text is good advice, but I'm not seeing a mention of pacing in RFC 9000. Is there a reference we can provide for this?",
          "createdAt": "2024-04-11T23:12:57Z",
          "updatedAt": "2024-04-11T23:12:57Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "In Section 13.1, I said this:\r\n\r\n> Better guidance for congestion control and rate adaptation for multiple **RoQ** flows (whether streams or datagrams).\r\n\r\n> Possible guidance for connection sharing between **RoQ** and **non-RoQ** flows, including considerations for congestion control and rate adaptation, scheduling, prioritization, and which ALPNs to use.\r\n\r\nShould these be \"real-time\" and \"non-real-time\" flows, or is using \"RoQ\" and \"non-RoQ\" flows clear?",
          "createdAt": "2024-04-12T00:50:38Z",
          "updatedAt": "2024-04-12T00:50:38Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Changing RTP/RTCP to RTP and normative words to non-normative sounds good to me. Thanks for doing the work.\r\n\r\nI am moving some of your comments to new issues and will start working on PRs, so we don't forget them when we merge #192 and close this issue.",
          "createdAt": "2024-04-13T13:30:35Z",
          "updatedAt": "2024-04-13T13:30:35Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "\r\n> > To send RTP/RTCP packets over QUIC streams, a sender MUST open at least one new unidirectional QUIC stream. RoQ uses unidirectional streams, because there is no synchronous relationship between sent and received RTP/RTCP packets.\r\n> \r\n> QUIC streams could use [either of two unidirectional stream ID types](https://datatracker.ietf.org/doc/html/rfc9000#stream-id-types), depending on whether the stream is client-initiated or server-initiated.\r\n> \r\n> I don't see any indication in the RoQ specification that says whether we expect RoQ endpoints know whether they are opening QUIC connections as QUIC clients or QUIC servers. Do you think we've said that? If so, where? If not, should we say something about that?\r\n> \r\n> (I'm guessing that QUIC implementations written for HTTP/3 would know which they are, and would be at least somewhat confused if an implementation thought it was a server and received a STREAM frame with a new stream ID saying it was \"Server-Initiated, Unidirectional\", or was a client and received a STREAM frame with a new stream ID saying it was \"Client-Initiated, Unidirectional\")\r\n> \r\n> I suspect we do need to say something about whether RoQ endpoints care whether they are QUIC clients or servers, because we say\r\n> \r\n> > The amount of data that the client can send in QUIC 0-RTT is controlled by the initial_max_data transport parameter supplied by the server. This is described in more detail in {{Section 4.6.1 of !RFC9001}}.\r\n\r\nI can't find a reference for this, but I'd assume that a server sending a stream frame with an ID of a client-initiated stream or vice-versa would be a protocol violation in QUIC. I don't think we need to handle that again in RoQ.",
          "createdAt": "2024-04-13T13:38:09Z",
          "updatedAt": "2024-04-13T13:38:09Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I can't find a reference for this, but I'd assume that a server sending a stream frame with an ID of a client-initiated stream or vice-versa would be a protocol violation in QUIC. I don't think we need to handle that again in RoQ.\r\n\r\nSo, what we're saying is that any reasonable QUIC implementation knows whether it's a server or a client, and uses the correct stream ID for that? ",
          "createdAt": "2024-04-16T19:04:53Z",
          "updatedAt": "2024-04-16T19:04:53Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Yes, that sounds right.",
          "createdAt": "2024-04-16T19:10:57Z",
          "updatedAt": "2024-04-16T19:10:57Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - We've got one remaining (re-)opened question about whether we care - and whether RoQ implementations should care - whether they use a client-initiated stream ID, a server-initiated stream ID, or whether they can use either. \r\n\r\nYou've done more implementation work on this, but I can imagine an implementer reading \r\n\r\n> To send RTP packets over QUIC streams, a sender MUST open at least one new unidirectional QUIC stream.\r\n\r\nthen looking at https://datatracker.ietf.org/doc/html/rfc9000#stream-id-types, and asking herself \"so, am I a client, or a server?\"\r\n\r\nIt seems like we should say SOMETHING, just to reduce the amount of confusion RoQ implementers will have (\"Make Good Choices!\" is a great slogan, but lousy normative language :grin:). If we're not going to be silent, we could do either of the following:\r\n\r\n- Explicitly say \"a sender MUST open at least one new unidirectional QUIC stream, **which can use either a client-initiated or server-initiated stream ID prefix**\", and then we should say something like \"a receiver MUST be prepared to accept either client-initiated or server-initiated stream ID prefixes\", OR\r\n- Pick one - and just for grins, let's say we pick server-initiated - so we explicitly say \"a sender MUST open at least one new **server-initiated** unidirectional QUIC stream\".\r\n\r\nI haven't called myself a software engineer for a while, but it seems to me that allowing either just increases the number of code paths that have to be tested and regression-tested, and I can't think of an advantage that might justify this increased complexity. \r\n\r\n(This is kind of like us changing SHOULDs to MUSTs, because receivers have to be prepared to handle the cases where senders don't do what they SHOULD do, so, more complexity, and more code paths to test and regression-test).\r\n\r\nDoes that make sense?",
          "createdAt": "2024-04-17T14:10:15Z",
          "updatedAt": "2024-04-17T14:10:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I don't understand why the application should worry about the QUIC stream ID. The QUIC implementations I have worked with manage stream IDs internally and don't let the application pick one. Even if they did, I would expect them to handle the error cases, where an application chooses a stream ID that it is not allowed to use (the QUIC stack will know whether it is a server or a client).",
          "createdAt": "2024-04-17T20:54:02Z",
          "updatedAt": "2024-04-17T20:54:02Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't understand why the application should worry about the QUIC stream ID. The QUIC implementations I have worked with manage stream IDs internally and don't let the application pick one. Even if they did, I would expect them to handle the error cases, where an application chooses a stream ID that it is not allowed to use (the QUIC stack will know whether it is a server or a client).\n\nThank you for the feedback! It's very helpful. \n\nAnd you're right - I'm not distinguishing between what a RoQ implementation deals with and what the underlying QUIC implementation deals with. My question is about the QUIC implementation.\n\nSo what I'm trying to ask (not very clearly) is, let's say you and I each have a cell phone with a QUIC implementation that's used for HTTP/3, so it opens streams as a client. \n\nNow, I call you, so I open a client-initiated stream because I'm a client. \n\nYou're also a client, so you'll see a client-initiated stream ID that you didn't initiate. \n\nI THINK one downside is that we're cutting the unidirectional stream ID space in half, and maybe that doesn't matter, but I also THINK the client-initiated/server-initiated stream ID prefixes also prevent two QUIC endpoints from choosing the same stream ID that collides during a race condition. \n\nDoes that seem right? ",
          "createdAt": "2024-04-18T09:30:30Z",
          "updatedAt": "2024-04-18T09:30:30Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> So what I'm trying to ask (not very clearly) is, let's say you and I each have a cell phone with a QUIC implementation that's used for HTTP/3, so it opens streams as a client.\r\n> \r\n> Now, I call you, so I open a client-initiated stream because I'm a client.\r\n> \r\n> You're also a client, so you'll see a client-initiated stream ID that you didn't initiate.\r\n\r\nThat doesn't work because you can't have a QUIC connection between two QUIC clients. Either there's a server involved that forwards data between the clients, or you need some peer-to-peer solution (possibly involving NAT traversal), in which one of the endpoints must act as a QUIC server.\r\n\r\nIf you have a server in between, there is no issue because the sending client will choose client-initiated stream IDs for the server, and the server will choose server-initiated stream IDs to forward the data to the receiving client.\r\n\r\nIf there is a direct connection between the endpoints and one of them is a server, then you also don't have the problem because the client uses client-initiated IDs, and the server uses server-initiated IDs.\r\n\r\nThe QUIC implementation of every endpoint, of course, needs to know whether it is a server or a client, but without knowing that, how would you establish the connection in the first place?",
          "createdAt": "2024-04-18T10:13:12Z",
          "updatedAt": "2024-04-18T10:13:12Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> That doesn't work because you can't have a QUIC connection between two QUIC clients. Either there's a server involved that forwards data between the clients, or you need some peer-to-peer solution (possibly involving NAT traversal), in which one of the endpoints must act as a QUIC server.\r\n\r\nYES! Now I've asked a well-formed question (for the first time in this thread). So, the implications of what you said here, as I understand it, is that \"telling a RoQ endpoint whether its QUIC implementation should act as a QUIC client or QUIC server\". And we agree that this probably needs to be signaled for RoQ, as it is for other encapsulations. ",
          "createdAt": "2024-04-18T14:08:53Z",
          "updatedAt": "2024-04-18T14:08:53Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I've created #203 to cover the QUIC client-server roles in our draft, and I'm closing this issue (again). ",
          "createdAt": "2024-04-18T14:45:30Z",
          "updatedAt": "2024-04-18T14:45:30Z"
        }
      ]
    },
    {
      "number": 168,
      "id": "I_kwDOFUmh7s5_zOxn",
      "title": "Questions about section 1.3",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/168",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "> This specification focuses on providing a secure encapsulation of RTP packets for transmission over QUIC. The expected usage is wherever RTP is used to carry media packets, allowing QUIC in place of other transport protocols such as TCP, UDP, SCTP, DTLS, etc. That is, we expect RoQ to be used in contexts in which a signaling protocol is used to announce or negotiate a media encapsulation and the associated transport parameters (such as IP address, port number). RoQ is not intended as a stand-alone media transport, although QUIC transport parameters could be statically configured.\r\n\r\nReviewing this paragraph I have some questions:\r\n1. Is SCTP actually used to carry RTP? If not, should we remove the reference here to avoid confusion?\r\n2. What does it mean that _QUIC transport parameters could be statically configured_? I don't think that makes sense. Did we mean to say RTP parameters could be statically configured (instead of using explicit signaling)?",
      "createdAt": "2024-02-20T11:15:00Z",
      "updatedAt": "2024-02-29T15:34:45Z",
      "closedAt": "2024-02-29T15:34:45Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> > This specification focuses on providing a secure encapsulation of RTP packets for transmission over QUIC. The expected usage is wherever RTP is used to carry media packets, allowing QUIC in place of other transport protocols such as TCP, UDP, SCTP, DTLS, etc. That is, we expect RoQ to be used in contexts in which a signaling protocol is used to announce or negotiate a media encapsulation and the associated transport parameters (such as IP address, port number). RoQ is not intended as a stand-alone media transport, although QUIC transport parameters could be statically configured.\r\n> \r\n> Reviewing this paragraph I have some questions:\r\n> \r\n> 1. Is SCTP actually used to carry RTP? If not, should we remove the reference here to avoid confusion?\r\n\r\nWell, yes, for some value of **\"actually\"** - at least, [the relevant IANA registry](https://www.iana.org/assignments/sdp-parameters/sdp-parameters.xhtml#sdp-parameters-2) has these entries: \r\n\r\n- proto\tUDP/DTLS/SCTP\t[[RFC8841](https://www.iana.org/go/rfc8841)]\r\n- proto\tTCP/DTLS/SCTP\t[[RFC8841](https://www.iana.org/go/rfc8841)]\r\n\r\n> 2. What does it mean that _QUIC transport parameters could be statically configured_? I don't think that makes sense. Did we mean to say RTP parameters could be statically configured (instead of using explicit signaling)?\r\n\r\nThat wouldn't surprise me - but I think this was written when we were wandering in the weeds, between \"not needing to use an ALPN to set up a RoQ QUIC connection\" and \"not needing to  use SDP to set up a RoQ RTP connection\". The bigger question is whether we need to say anything about EITHER of these things - we're certainly not encouraging implementers to try to do RoQ that way. ",
          "createdAt": "2024-02-21T02:46:02Z",
          "updatedAt": "2024-02-21T02:46:51Z"
        }
      ]
    },
    {
      "number": 171,
      "id": "I_kwDOFUmh7s5_0IcW",
      "title": "Clarify L4S requirements",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/171",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF119"
      ],
      "body": "> An alternative to these dedicated real-time media congestion-control algorithms that QUIC implementations could support without the need for a protocol extension is the Low Latency, Low Loss, and Scalable Throughput (L4S) Internet Service [[RFC9330](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC9330)].\r\n\r\nWhile L4S does not require a QUIC extension, it requires support from the network.",
      "createdAt": "2024-02-20T13:22:11Z",
      "updatedAt": "2024-02-22T15:10:59Z",
      "closedAt": "2024-02-22T15:10:59Z",
      "comments": []
    },
    {
      "number": 175,
      "id": "I_kwDOFUmh7s5_5BTs",
      "title": "Move Section 1.3 later in the document, probably after Section 2, on Terminology",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/175",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "documentation",
        "IETF119"
      ],
      "body": "",
      "createdAt": "2024-02-21T02:27:30Z",
      "updatedAt": "2024-02-22T15:13:13Z",
      "closedAt": "2024-02-22T15:13:13Z",
      "comments": []
    },
    {
      "number": 181,
      "id": "I_kwDOFUmh7s6A2EhH",
      "title": "Specify how the contents of the 0-RTT initial packet payload are handled in RoQ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/181",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF119"
      ],
      "body": "This Editor's Note\r\n\r\n> Editor's Note: Since the QUIC connection will often be created in the context of an existing signaling relationship (e.g., using WebRTC or SIP), specific 0-RTT keying material could be exchanged to prevent replays across sessions. Within the same connection, replayed media packets would be discarded as duplicates by the receiver.\r\n\r\nis worth its own issue, because [Section 9.2 in RFC 9001](https://www.rfc-editor.org/rfc/rfc9001#section-9.2) says\r\n\r\n> Application protocols MUST either prohibit the use of extensions that carry application semantics in 0-RTT or provide replay mitigation strategies.\r\n\r\nand, peeking at [Section 10 9 of RFC 9114](https://datatracker.ietf.org/doc/html/rfc9114#name-early-data), HTTP/3 does replay protection this way \r\n\r\n> The use of 0-RTT with HTTP/3 creates an exposure to replay attack. The anti-replay mitigations in [[HTTP-REPLAY](https://datatracker.ietf.org/doc/html/rfc8470)] MUST be applied when using HTTP/3 with 0-RTT.\r\n\r\nand none of the mitigations in [Section 3 of HTTP-REPLAY (RFC 8470)](https://datatracker.ietf.org/doc/html/rfc8470#autoid-4) seem applicable. \r\n\r\nWe THINK the right answer is to allow 0-RTT connections, but to require RoQ endpoints to ignore any packet payload in an 0-RTT initial packet received during the TLS handshake,",
      "createdAt": "2024-02-29T16:34:48Z",
      "updatedAt": "2024-03-08T15:49:17Z",
      "closedAt": "2024-03-08T15:49:17Z",
      "comments": []
    },
    {
      "number": 182,
      "id": "I_kwDOFUmh7s6A2KaS",
      "title": "Resolving all Editor's Notes in the current draft",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/182",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF119"
      ],
      "body": "For this editor's note: \r\n\r\n> Editor's note: Need to check whether Section 7 will also describe the QUIC interface that's being exposed, or if that ends up somewhere else in the document.\r\n\r\nthe section number did change (it's now in 7 and 11). \r\n\r\nThis one \r\n\r\n> RFC Editor's note: Please remove this section prior to publication of a final version of this document.\r\n\r\nis an RFC Editor's note, and should stay.\r\n\r\nThis one\r\n\r\n> Editor's note: A receiver cannot cancel a certain frame but still receive retransmissions for a frame the was following on the same stream using STOP_SENDING, because STOP_SENDING does not include an offset which would allow signaling where retransmissions should continue.\r\n\r\nhas been overtaken by the language in the previous paragraph and can be removed.\r\n\r\nThis one \r\n\r\n> Editor's Note: Additional discussion of bandwidth minimization could go in this section, or in an earlier proposed section on motivations for defining and deploying RoQ.\r\n\r\ndid go in this section, and the note can be removed. \r\n\r\nThis one\r\n\r\n> Editor's Note: It may be desirable that the API provides an indication of connection migration event for either case.\r\n\r\nWe are realizing that the [API Considerations](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-api-considerations) are actually for the API between RoQ and QUIC. This note is about something that might be exposed by RoQ to an RTP application.  The text should be something like \r\n\r\n> It may be desirable that the RoQ implementation provides an indication of connection migration to the RTP application. \r\n\r\nThis one \r\n\r\n> Editor's Note: Since the QUIC connection will often be created in the context of an existing signaling relationship (e.g., using WebRTC or SIP), specific 0-RTT keying material could be exchanged to prevent replays across sessions. Within the same connection, replayed media packets would be discarded as duplicates by the receiver.\r\n\r\nis worth its own issue, so we created #181.",
      "createdAt": "2024-02-29T16:45:08Z",
      "updatedAt": "2024-03-04T16:10:14Z",
      "closedAt": "2024-03-04T16:10:14Z",
      "comments": []
    },
    {
      "number": 187,
      "id": "I_kwDOFUmh7s6DTHPg",
      "title": "Restructure Directions for Future Work section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/187",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "documentation",
        "NextInterim"
      ],
      "body": "I know what I was thinking when I organized this section, but I think it could be clearer. ",
      "createdAt": "2024-03-22T16:02:21Z",
      "updatedAt": "2024-04-09T18:18:33Z",
      "closedAt": "2024-04-09T18:18:33Z",
      "comments": []
    },
    {
      "number": 188,
      "id": "I_kwDOFUmh7s6D71nG",
      "title": "Clarify RTP vs RTCP vs RTP/RTCP handling early in the document",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/188",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "documentation",
        "NextInterim"
      ],
      "body": "RTP and RTCP were originally defined in the same specification ([RFC 3550](https://datatracker.ietf.org/doc/html/rfc3550)), and later specifications such as [RFC 5761](https://datatracker.ietf.org/doc/html/rfc5761) allowed RTP and RTCP to be multiplexed on the same transport port. The RTP over QUIC specification supports this multiplexing, but at least @SpencerDawkins has not been careful to distinguish between RTP, RTCP, and multiplexed RTP/RTCP in the text. Context clues help the reader, but clear text would help even more. \r\n\r\nFor example, the document title, \"RTP over QUIC\", could just as well be \"RTP/RTCP over QUIC\". ",
      "createdAt": "2024-03-28T15:20:21Z",
      "updatedAt": "2024-04-09T18:56:02Z",
      "closedAt": "2024-04-09T18:56:02Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "(The PR for this issue, #190, also implements a preference for the term \"document\", except when the term \"specification\" is more correct)",
          "createdAt": "2024-04-02T16:18:11Z",
          "updatedAt": "2024-04-02T16:18:11Z"
        }
      ]
    },
    {
      "number": 193,
      "id": "I_kwDOFUmh7s6Fm3_B",
      "title": "working well through NATs and firewalls",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/193",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "> This document describes an application usage of QUIC ([[RFC9308](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC9308)]). As a baseline, the document does not expect more than a standard QUIC implementation as defined in [[RFC8999](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC8999)], [[RFC9000](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC9000)], [[RFC9001](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC9001)], and [[RFC9002](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC9002)], providing a secure end-to-end transport that is also expected to work well through NATs and firewalls.\r\n\r\nSD: Is this last part (highlighted) correct, as far as we're concerned?\r\n\r\n---\r\n\r\nME: Yes and no. If you only want to use QUIC streams, it should be fine. If you want datagrams, you need RFC 9221. I think we may want to add that constraint to the text.\r\n\r\n---\r\n\r\n> Yes and no. If you only want to use QUIC streams, it should be fine. If you want datagrams, you need RFC 9221. I think we may want to add that constraint to the text.\r\n\r\nSD: I'm actually asking about \"working well through NATs and firewalls.\r\n\r\n_Originally posted by @SpencerDawkins in https://github.com/mengelbart/rtp-over-quic-draft/issues/163#issuecomment-2047826581_",
      "createdAt": "2024-04-13T13:23:06Z",
      "updatedAt": "2024-04-16T19:08:41Z",
      "closedAt": "2024-04-16T19:08:41Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I suggest we add something like *and optionally RFC9221* to the list of required RFCs.\r\n\r\nAbout the second question, I think we can just drop the last part of the sentence. I don't see why we need to mention it here, and NAT traversal is discussed elsewhere in the document. What do you think?",
          "createdAt": "2024-04-13T14:08:27Z",
          "updatedAt": "2024-04-13T14:08:27Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I suggest we add something like _and optionally RFC9221_ to the list of required RFCs.\r\n\r\nI think I confused you in my comment. I think the list of \"all you need\" is fine without mentioning RFC 9221, because our list here is what is actually QUIC without extensions - the baseline set of RFCs is fine. If we mention an extension to QUIC here, we should probably consider treating RFC 9221 differently from any other extension - the document has \r\n\r\n- core QUIC specifications\r\n- QUIC extensions\r\n\r\nbut we would be moving to \r\n\r\n- core QUIC specifications\r\n- QUIC extensions that should have been included in RFC 9000\r\n- other QUIC extensions\r\n\r\nand that seems unhelpful. \r\n\r\n> About the second question, I think we can just drop the last part of the sentence. I don't see why we need to mention it here, and NAT traversal is discussed elsewhere in the document. What do you think?\r\n\r\nThat's actually what my comment was about! I think your solution would be great. ",
          "createdAt": "2024-04-16T14:50:08Z",
          "updatedAt": "2024-04-16T14:50:08Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "That makes sense!\r\n\r\nI'll open a PR to remove the sentence about NAT.",
          "createdAt": "2024-04-16T16:28:31Z",
          "updatedAt": "2024-04-16T16:28:31Z"
        }
      ]
    },
    {
      "number": 194,
      "id": "I_kwDOFUmh7s6Fm4Ul",
      "title": "P2P and Client/Server connection setup",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/194",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "NextInterim"
      ],
      "body": "I am also noticing \r\n\r\n> The above implies that **RoQ is targeted at peer-to-peer operation**; but it may also be used in client-server-style settings, e.g., when talking to a conference server as described in RFC 7667 ([[RFC7667](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC7667)]), or, if RoQ is used to replace RTSP ([[RFC7826](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC7826)]), to a media server.\r\n\r\nI THINK the point is \"peer to peer will work fine if you set up QUIC connections directly to the right places, and this document doesn't describe how that happens, and that description should be in some other document\", but I should probably say that clearly.\r\n\r\n_Originally posted by @SpencerDawkins in https://github.com/mengelbart/rtp-over-quic-draft/issues/163#issuecomment-2047826581_\r\n            ",
      "createdAt": "2024-04-13T13:26:57Z",
      "updatedAt": "2024-04-17T13:44:04Z",
      "closedAt": "2024-04-17T13:44:03Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "#195 is a general cleanup of \"peer\" and \"endpoint\", and won't change \r\n\r\n> The above implies that RoQ is targeted at **peer-to-peer** RTP operation; but it can also be used in RTP client-server-style settings, e.g., when talking to a conference server as described in RFC 7667 ([RFC7667]), or, if RoQ is used to replace RTSP ([RFC7826]), to a media server.\r\n\r\nThat's left for this issue. ",
          "createdAt": "2024-04-16T15:20:47Z",
          "updatedAt": "2024-04-16T15:20:47Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "The more I look at this issue, and the surrounding text that it describes, the more I suspect that (because we're talking about media streams) what we should say is mostly about RTP. My apologies for being confused!",
          "createdAt": "2024-04-16T18:57:22Z",
          "updatedAt": "2024-04-16T18:57:22Z"
        }
      ]
    },
    {
      "number": 195,
      "id": "I_kwDOFUmh7s6Fm5fU",
      "title": "Use of the term \"peer\"",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/195",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "> We use the term \"peer\" 21 times in the document. We might want to define that, or qualify it (as something like \"peer endpoint\", with \"endpoint\" already being defined).\r\n\r\n_Originally posted by @SpencerDawkins in https://github.com/mengelbart/rtp-over-quic-draft/issues/163#issuecomment-2050678926_\r\n            ",
      "createdAt": "2024-04-13T13:38:36Z",
      "updatedAt": "2024-04-17T13:39:11Z",
      "closedAt": "2024-04-17T13:39:11Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think we can add a term to the terminology section to explain that by *peer*, we mean the *endpoint* on the other side.",
          "createdAt": "2024-04-13T14:12:42Z",
          "updatedAt": "2024-04-13T14:12:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I think you're right. I can take this one. ",
          "createdAt": "2024-04-16T14:53:56Z",
          "updatedAt": "2024-04-16T14:53:56Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "This is looking a TINY bit more involved, because there are places in the current text that say \"peer\" when they should say \"endpoint\". I'll clean that up, as well. ",
          "createdAt": "2024-04-16T15:10:53Z",
          "updatedAt": "2024-04-16T15:10:53Z"
        }
      ]
    },
    {
      "number": 196,
      "id": "I_kwDOFUmh7s6Fm5uZ",
      "title": "Add reference for pacing recommendation",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/196",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "NextInterim"
      ],
      "body": "> The currently proposed congestion control algorithms for real-time communications (e.g., SCReAM and NADA) provide such pacing mechanisms, **and QUIC recommends pacing for senders based on the congestion control algorithm.**\u00b6\r\n\r\nI think the bolded text is good advice, but I'm not seeing a mention of pacing in RFC 9000. Is there a reference we can provide for this?\r\n\r\n_Originally posted by @SpencerDawkins in https://github.com/mengelbart/rtp-over-quic-draft/issues/163#issuecomment-2050699857_\r\n            ",
      "createdAt": "2024-04-13T13:41:03Z",
      "updatedAt": "2024-04-17T13:42:41Z",
      "closedAt": "2024-04-17T13:42:40Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "https://www.rfc-editor.org/rfc/rfc9002.html#name-pacing",
          "createdAt": "2024-04-13T13:41:13Z",
          "updatedAt": "2024-04-13T13:41:13Z"
        }
      ]
    },
    {
      "number": 197,
      "id": "I_kwDOFUmh7s6Fm50U",
      "title": "Replace RoQ/non-RoQ with real-time/non-real-time",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/197",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [],
      "body": "In Section 13.1, I said this:\r\n\r\n> Better guidance for congestion control and rate adaptation for multiple **RoQ** flows (whether streams or datagrams).\r\n\r\n> Possible guidance for connection sharing between **RoQ** and **non-RoQ** flows, including considerations for congestion control and rate adaptation, scheduling, prioritization, and which ALPNs to use.\r\n\r\nShould these be \"real-time\" and \"non-real-time\" flows, or is using \"RoQ\" and \"non-RoQ\" flows clear?\r\n\r\n_Originally posted by @SpencerDawkins in https://github.com/mengelbart/rtp-over-quic-draft/issues/163#issuecomment-2050777990_\r\n            ",
      "createdAt": "2024-04-13T13:42:09Z",
      "updatedAt": "2024-04-16T16:26:35Z",
      "closedAt": "2024-04-16T16:26:35Z",
      "comments": []
    },
    {
      "number": 203,
      "id": "I_kwDOFUmh7s6GKbMx",
      "title": "Clarify RoQ relationship with QUIC client-server roles",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/203",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "In [#163](https://github.com/mengelbart/rtp-over-quic-draft/issues/163#issuecomment-2050024671) - the link goes to the first comment where the discussion about QUIC client-server roles started - we had a long conversation about how a RoQ endpoint's QUIC implementation knows whether it will act as a QUIC client or QUIC server.\r\n\r\n@mengelbart and @SpencerDawkins have converged, and said that the QUIC implementation does need to know this, but RoQ itself isn't going to tell the QUIC implementation what to do. We'll rely on signaling to provide that information. \r\n\r\nWe need to say that in the draft, and @SpencerDawkins will also make sure that we don't have lingering mentions of client and server that refer to something else. We might also need to add \"client\" and \"server\" as terms in [Section 2](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-terminology-and-notation).\r\n\r\n",
      "createdAt": "2024-04-18T14:43:34Z",
      "updatedAt": "2024-04-19T02:21:25Z",
      "closedAt": "2024-04-19T02:21:25Z",
      "comments": []
    },
    {
      "number": 210,
      "id": "I_kwDOFUmh7s6G7wJl",
      "title": "Update AVB RTCP packet description and correct PSFB value",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/210",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-25T14:53:25Z",
      "updatedAt": "2024-04-25T17:08:25Z",
      "closedAt": "2024-04-25T17:08:25Z",
      "comments": []
    },
    {
      "number": 219,
      "id": "I_kwDOFUmh7s6JTm7r",
      "title": "RoQ Implementation Experience",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/219",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Reading the document, it is not clear how much of the specification has been implemented.  Understanding this will help in evaluating the issues to be investigated during the Experiment.  QUIC implementations differ in ways that can affect RoQ (e.g. handling of RESET_STREAM, prioritizing of datagrams vs. streams, support for QUIC extensions, etc.), so it's useful to understand how much experience we have had with these potential issues. \r\n\r\nSection 1.1 says: \r\n\r\n\"   This document describes an application usage of QUIC ([RFC9308]).  As\r\n   a baseline, the document does not expect more than a standard QUIC\r\n   implementation as defined in [RFC8999], [RFC9000], [RFC9001], and\r\n   [RFC9002], providing a secure end-to-end transport.  Beyond this\r\n   baseline, real-time applications can benefit from QUIC extensions\r\n   such as unreliable DATAGRAMs [RFC9221], which provides additional\r\n   desirable properties for real-time traffic (e.g., no unnecessary\r\n   retransmissions, avoiding head-of-line blocking).\r\n\"\r\n\r\n[BA] Does this imply that the RoQ implementation only supported QUIC reliable streams and not \"RoQ datagrams\"? \r\n\r\nSection 3\r\n\r\n\"RoQ allows the use of\r\n   both QUIC streams and QUIC DATAGRAMs to transport real-time data, and\r\n   thus, if RTP packets are to be sent over QUIC DATAGRAMs, the QUIC\r\n   implementation MUST support QUIC's DATAGRAM extension.\"\r\n\r\n[BA] Does the RoQ implementation support both QUIC streams as well as QUIC datagrams?  \r\n\r\n\"[RFC9221] does not provide demultiplexing between different\r\n   flows on DATAGRAMs but suggests that an application implement a\r\n   demultiplexing mechanism if required.  An example of such a mechanism\r\n   would be flow identifiers prepended to each DATAGRAM frame as\r\n   described in Section 2.1 of [I-D.draft-ietf-masque-h3-datagram].  RoQ\r\n   uses a flow identifier to replace the network address and port number\r\n   to multiplex many RTP sessions over the same QUIC connection.\"\r\n\r\n[BA] Was the demultiplexing mechanism for DATAGRAMS implemented? \r\n\r\nSection 3.1.5\r\n\r\n\"   This document defines a flow identifier for multiplexing multiple RTP\r\n   and RTCP ports on the same QUIC connection to conserve ports,\r\n   especially at NATs and firewalls.  Section 5.1 describes the\r\n   multiplexing in more detail.  \"\r\n\r\n[BA] Was the flow identifier implemented for multiplexing multiple RTP and RTCP ports on the same connection? \r\n\r\n\"A sender can use these capabilities to more effectively exploit\r\n   multiple paths between sender and receiver with no action required\r\n   from the application, even if these paths have different path\r\n   characteristics.  \"\r\n\r\n[BA] Was any experimentation done with multi-path QUIC? \r\n\r\nSection 3.2\r\n\r\n\"Indeed, an application can use both QUIC\r\n   streams and DATAGRAM encapsulations on the same QUIC connection.\"\r\n\r\n[BA] Were streams and DATAGRAM encapsulations both implemented? \r\n\r\nSection 3.2\r\n\r\n\"   There is no default relative priority between DATAGRAM frames with\r\n   respect to each other, and there is no default priority between\r\n   DATAGRAM frames and QUIC STREAM frames.  \"\r\n\r\n[BA] We have seen implementations that do include a default priority between DATAGRAM and STREAM frames.  One question that has arisen is whether the choice (prioritizing DATAGRAM vs. STREAM frames) affects whether RTCP should be encapsulated in STREAM or DATAGRAM frames.  Did the RoQ implementation look at the influence of default priority? \r\n\r\n\"   DATAGRAM frames do inherit the QUIC connection's congestion\r\n   controller.  This means that although there is no frame-level flow\r\n   control, DATAGRAM frames can be delayed until the controller allows\r\n   them to be sent or dropped (with an optional notification to the\r\n   sending application).  Implementations can also delay sending\r\n   DATAGRAM frames to maintain consistent packet pacing (as described in\r\n   Section 7.7 of [RFC9002]), and can allow an application to specify a\r\n   sending expiration time, but these capabilities are not mandated by\r\n   the standard and might not be present in all implementations.\"\r\n\r\n[BA] This is another area where there appears to be significant variation between QUIC implementations. Did the RoQ implementation have experience with the effect of these differences (e.g. delay in sending vs. dropping on expiration)? \r\n\r\n\" *  If the use of DATAGRAMs was critical for the application, the\r\n      endpoint can simply close the QUIC connection, allowing someone or\r\n      something to correct this mismatch, so that DATAGRAMs can be used.\r\n\r\n   *  If the use of DATAGRAMs was not critical for the application, the\r\n      endpoint can negotiate the use of QUIC streams instead.\r\n\"\r\n\r\n[BA] Did the RoQ implementation support one of these policies? \r\n\r\n3.3.  Supported RTP Topologies\r\n\r\n[BA] Did the RoQ implementation attempt support for RoQ to RTP/UDP translation? \r\n\r\nSection 4\r\n\r\n\"This allows different RTP sessions, which might\r\n   use different RTP profiles, to be carried within the same QUIC\r\n   connection.\"\r\n\r\n[BA] Did the RoQ implementation support carrying multiple RTP sessions within the same QUIC connection? \r\n\r\nSection 4.1\r\n\r\n\"   Non-compatible experiments that are based on these draft versions\r\n   MUST append the string \"-\" and an experiment name to the identifier.\r\n\r\n[BA] What is an example of a \"non-compatible experiment\"?  Would this be a RoQ implementation that doesn't interoperate with the RoQ implementation code?  Also, curious about whether we should expect implementations of the published RFC using the \"roq\" ALPN to interoperate. \r\n\r\nSection 5\r\n\r\n\"Senders MAY combine both modes by sending some RTP\r\n   packets over the same or different QUIC streams and others in\r\n   DATAGRAMs.\"\r\n\r\n[BA] Did the RoQ implementation include support for both modes?  If so, what happened if a RoQ peer did not support both?  For example, if the RoQ implementation supported DATAGRAMS and sent RTP/RTCP using them, but did not receive DATAGRAM frames from the peer, only STREAM frames?  Would it switch to use of STREAM frames? Or would communication fail? \r\n\r\nSection 5.1\r\n\r\n\"RTP packets of different RTP sessions MUST use distinct flow\r\n   identifiers.  If endpoints wish to send multiple types of media in a\r\n   single RTP session, they can do so by following the guidance\r\n   specified in [RFC8860].\"\r\n\r\n[BA] Was support for multiple RTP sessions implemented? \r\n\r\n\"A single RTP session can be associated with one or two flow\r\n   identifiers.  Thus, it is possible to send RTP and RTCP packets\r\n   belonging to the same session using different flow identifiers.  RTP\r\n   and RTCP packets of a single RTP session can use the same flow\r\n   identifier (following the procedures defined in [RFC5761]), or they\r\n   can use different flow identifiers.\"\r\n\r\n[BA] Did the RoQ implementation support sending RTP and RTCP using different flow identifiers? \r\n\r\n\"  The association between flow identifiers and RTP streams MUST be\r\n   negotiated using appropriate signaling.  The signaling happens out of\r\n   band and thus a stream or DATAGRAM with a given flow identifer can\r\n   arrive before the signaling finished.  In that case, an endpoint\r\n   cannot associate the stream or DATAGRAM with the corresponding RTP\r\n   stream.  \"\r\n\r\n[BA] Did the RoQ implementation require creation of the association via signaling?   \r\n\r\nRFC 3550 doesn't have an equivalent requirement, and there have been RTP implementations in which an event is triggered on arrival of a non-signaled flow identifier, allowing the application to decide whether to accept the incoming stream or not.  If the incoming stream is accepted, the source SSRC (and the mapping between flow id and SSRC) could be authorized. \r\n\r\nThis allows for the handling of incoming streams without signaling, including where the signaling has not yet arrived.  For example, if the application feels it can render the incoming stream (subject to the limits on buffered streams) it can choose to do so. \r\n\r\n\"If the number of buffered streams exceeds the limit on\r\n   buffered streams, the endpoint MUST send a STOP_SENDING with the\r\n   error code ROQ_UNKNOWN_FLOW_ID. \"\r\n\r\n[BA] Was this implemented? \r\n\r\nSection 5.2\r\n\r\n\"   A RoQ sender can open new QUIC streams for different RTP packets using the same flow identifier.  \"\r\n\r\n[BA] Was this implemented? \r\n\r\nSection 5.2.2\r\n\r\n\"   QUIC uses RESET_STREAM and STOP_SENDING frames to terminate the\r\n   sending part of a stream and to request termination of an incoming\r\n   stream by the sending peer respectively.\"\r\n\r\n[BA] Was this implemented? \r\n\r\n\"   If a RoQ sender discovers that a packet is no longer needed and knows\r\n   that the packet has not yet been successfully and completely\r\n   transmitted, it can use RESET_STREAM to tell the RoQ receiver that\r\n   the RoQ sender is discarding the packet.\"\r\n\r\n[BA]  I am curious about the implementation experience with respect to use of RESET_STREAM and STOP_SENDING. Was this implemented, and if so, in what transport scenarios (e.g. packet/stream, multiple packets/stream, etc.)? \r\n\r\nThis paragraph seems to assume packet/stream encapsulation, so that a RESET_STREAM can be mapped to a specific packet.  But what if multiple packets are sent on the same stream?  Does use of a reliable reset make sense in that scenario?\r\n\r\nAlso, the sender may not know if the packet has \"not yet been successfully and completely transmitted\"?  In some implementations, the sender only knows that the packet has been enqueued for transmission, and the effect of RESET_STREAM can vary depending on how the sender, receiver and intermediary QUIC implementations handle RESET_STREAM.  For example, if RESET_STREAM is sent after the packet has been put on the wire, the RESET_STREAM frame may have no effect. \r\n\r\n\"   A translator that translates between two endpoints, both connected\r\n   via QUIC, MUST forward RESET_STREAM frames received from one end to\r\n   the other unless it forwards the RTP packets encapsulated in\r\n   DATAGRAMs.\"\r\n\r\n[BA] Was there any implementation experience with this? \r\n\r\n5.2.3.  Flow control and MAX_STREAMS\r\n\r\n[BA] I'm curious about the implementation experience relating to MAX_STREAMS, particularly in conferencing scenarios.  This seems like an area where there could be tricky issues. \r\n\r\n5.3.  QUIC DATAGRAMs\r\n\r\n[BA] Was there implementation experience with QUIC DATAGRAMs? \r\n\r\n7.  Error Handling\r\n\r\n[BA] Was this implemented? \r\n\r\n9.  Guidance on Choosing QUIC Streams, QUIC DATAGRAMs, or a Mixture\r\n\r\n   Some applications might have implementation goals that don't fit\r\n   neatly into \"QUIC streams only\" or \"QUIC DATAGRAMs only\" categories.\r\n   For example, another implementation goal might be to use QUIC streams\r\n   to carry RTP video frames, but to use QUIC DATAGRAMs to carry RTP\r\n   audio frames, which are typically much smaller.  Because humans tend\r\n   to tolerate inconsistent behavior in video better than inconsistent\r\n   behavior in audio, the application might add Forward Error Correction\r\n   [RFC6363] to RTP audio packets and encapsulate the result in QUIC\r\n   DATAGRAMs, while encapsulating RTP video packets in QUIC streams.\r\n\r\n[BA] Was there any implementation experience with this mixed stream/datagram approach? \r\n\r\nIn some cases the results appear to be affected by the QUIC stack's default prioritization of streams and datagrams.  For example, prioritizing datagrams over streams would be likely to provide lower delay/loss for the audio, whereas prioritizing streams over datagrams seems like it could create issues with a/v sync. \r\n\r\n",
      "createdAt": "2024-05-17T21:49:41Z",
      "updatedAt": "2024-06-05T09:05:10Z",
      "closedAt": "2024-06-05T09:05:10Z",
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "There are at least two different implementations.\r\n\r\nBBC has published a set of [Gstreamer plugins](https://github.com/bbc/gst-roq) implementing RoQ. I don't know how much of the draft it implements.\r\n\r\nThe implementation linked in [Appendix C](https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-10#appendix-C) is the implementation we used for the initial experiments focusing on congestion control which we presented when we started working on the draft. [That implementation](https://github.com/mengelbart/rtp-over-quic) is not up to date with the current draft, mainly because the stream mapping does not use a length field. Since that implementation is somewhat outdated and includes a lot of features that are not related to RoQ, we moved the RoQ-specific parts to a new library. The [new library](https://github.com/mengelbart/roq) is up to date with the latest draft and only includes the RoQ encapsulation for streams and datagrams.\r\n\r\n> Reading the document, it is not clear how. much of the specification was implemented.\r\n\r\nI think we can update Appendix C to answer these questions, or alternatively add a new regular (sub)section to the draft. What would you prefer?\r\n\r\nAnswers regarding our (new) implementation:\r\n\r\n> Section 1.1 says:\r\n> \r\n> \" This document describes an application usage of QUIC ([RFC9308]). As a baseline, the document does not expect more than a standard QUIC implementation as defined in [RFC8999], [RFC9000], [RFC9001], and [RFC9002], providing a secure end-to-end transport. Beyond this baseline, real-time applications can benefit from QUIC extensions such as unreliable DATAGRAMs [RFC9221], which provides additional desirable properties for real-time traffic (e.g., no unnecessary retransmissions, avoiding head-of-line blocking). \"\r\n> \r\n> [BA] Does this imply that the RoQ implementation only supported QUIC reliable streams and not \"RoQ datagrams\"?\r\n\r\nNo, our implementation supports both.\r\n\r\n> Section 3\r\n> \r\n> \"RoQ allows the use of both QUIC streams and QUIC DATAGRAMs to transport real-time data, and thus, if RTP packets are to be sent over QUIC DATAGRAMs, the QUIC implementation MUST support QUIC's DATAGRAM extension.\"\r\n> \r\n> [BA] Does the RoQ implementation support both QUIC streams as well as QUIC datagrams?\r\n\r\nYes, our implementation supports both.\r\n\r\n> \"[RFC9221] does not provide demultiplexing between different flows on DATAGRAMs but suggests that an application implement a demultiplexing mechanism if required. An example of such a mechanism would be flow identifiers prepended to each DATAGRAM frame as described in Section 2.1 of [I-D.draft-ietf-masque-h3-datagram]. RoQ uses a flow identifier to replace the network address and port number to multiplex many RTP sessions over the same QUIC connection.\"\r\n> \r\n> [BA] Was the demultiplexing mechanism for DATAGRAMS implemented?\r\n\r\nWe implemented the flow identifier, and it is used in streams and datagrams as described in [section 5](https://datatracker.ietf.org/doc/html/draft-ietf-avtcore-rtp-over-quic-10#section-5)\r\n\r\n> Section 3.1.5\r\n> \r\n> \" This document defines a flow identifier for multiplexing multiple RTP and RTCP ports on the same QUIC connection to conserve ports, especially at NATs and firewalls. Section 5.1 describes the multiplexing in more detail. \"\r\n> \r\n> [BA] Was the flow identifier implemented for multiplexing multiple RTP and RTCP ports on the same connection?\r\n\r\nYes, the flow identifier can be used to multiplex multiple RTP and RTCP streams on the same connection.\r\n\r\n> \"A sender can use these capabilities to more effectively exploit multiple paths between sender and receiver with no action required from the application, even if these paths have different path characteristics. \"\r\n> \r\n> [BA] Was any experimentation done with multi-path QUIC?\r\n\r\nNo.\r\n\r\n> Section 3.2\r\n> \r\n> \"Indeed, an application can use both QUIC streams and DATAGRAM encapsulations on the same QUIC connection.\"\r\n> \r\n> [BA] Were streams and DATAGRAM encapsulations both implemented?\r\n\r\nYes, our implementation supports both and allows using both simultaneously, given that the datagram extension was negotiated.\r\n\r\n> Section 3.2\r\n> \r\n> \" There is no default relative priority between DATAGRAM frames with respect to each other, and there is no default priority between DATAGRAM frames and QUIC STREAM frames. \"\r\n> \r\n> [BA] We have seen implementations that do include a default priority between DATAGRAM and STREAM frames. One question that has arisen is whether the choice (prioritizing DATAGRAM vs. STREAM frames) affects whether RTCP should be encapsulated in STREAM or DATAGRAM frames. Did the RoQ implementation look at the influence of default priority?\r\n\r\nThe tests with our initial implementation used RTCP over datagrams and we did not further investigate the influence of priorities between streams or datagrams. That is something we should look at in future experiments.\r\n\r\n> \" DATAGRAM frames do inherit the QUIC connection's congestion controller. This means that although there is no frame-level flow control, DATAGRAM frames can be delayed until the controller allows them to be sent or dropped (with an optional notification to the sending application). Implementations can also delay sending DATAGRAM frames to maintain consistent packet pacing (as described in Section 7.7 of [RFC9002]), and can allow an application to specify a sending expiration time, but these capabilities are not mandated by the standard and might not be present in all implementations.\"\r\n> \r\n> [BA] This is another area where there appears to be significant variation between QUIC implementations. Did the RoQ implementation have experience with the effect of these differences (e.g. delay in sending vs. dropping on expiration)?\r\n\r\nNo.\r\n\r\n> \" * If the use of DATAGRAMs was critical for the application, the endpoint can simply close the QUIC connection, allowing someone or something to correct this mismatch, so that DATAGRAMs can be used.\r\n> \r\n>     * If the use of DATAGRAMs was not critical for the application, the\r\n>       endpoint can negotiate the use of QUIC streams instead.\r\n>       \"\r\n> \r\n> \r\n> [BA] Did the RoQ implementation support one of these policies?\r\n\r\nOur implementation exposes an API that allows applications to send RTP over streams or datagrams. If datagrams cannot be sent, an error will be exposed to the application, and it is the choice of the applications to close the connection or try using streams. The behavior also depends on what was signaled out of band.\r\n\r\n> 3.3. Supported RTP Topologies\r\n> \r\n> [BA] Did the RoQ implementation attempt support for RoQ to RTP/UDP translation?\r\n\r\nNo.\r\n\r\n> Section 4\r\n> \r\n> \"This allows different RTP sessions, which might use different RTP profiles, to be carried within the same QUIC connection.\"\r\n> \r\n> [BA] Did the RoQ implementation support carrying multiple RTP sessions within the same QUIC connection?\r\n\r\nOur implementation supports multiplexing using the flow identifier, but we did not run any experiments with multiple sessions on the same connection.\r\n\r\n> Section 4.1\r\n> \r\n> \" Non-compatible experiments that are based on these draft versions MUST append the string \"-\" and an experiment name to the identifier.\r\n> \r\n> [BA] What is an example of a \"non-compatible experiment\"? Would this be a RoQ implementation that doesn't interoperate with the RoQ implementation code? Also, curious about whether we should expect implementations of the published RFC using the \"roq\" ALPN to interoperate.\r\n\r\nI would consider the first implementation we presented as now being incompatible because it does not use a length field for RTP packets sent on a stream. That will be an interoperability issue because a receiver expecting the length field cannot know where RTP packets start or end. Unfortunately, it was implemented before the addition of this subsection and thus now uses the \"rtp-mux-quic\" ALPN, but that is no longer used in the current draft.\r\n\r\nThis subsection is to be removed before publication. I would expect RoQ implementations to interoperate with other RoQ implementations, and I would expect implementations using the \"roq\" ALPN to implement the final RFC and be interoperable.\r\n\r\n> Section 5\r\n> \r\n> \"Senders MAY combine both modes by sending some RTP packets over the same or different QUIC streams and others in DATAGRAMs.\"\r\n> \r\n> [BA] Did the RoQ implementation include support for both modes? If so, what happened if a RoQ peer did not support both? For example, if the RoQ implementation supported DATAGRAMS and sent RTP/RTCP using them, but did not receive DATAGRAM frames from the peer, only STREAM frames? Would it switch to use of STREAM frames? Or would communication fail?\r\n\r\nOur implementation supports both modes. If the QUIC peer announces support for receiving datagrams, the application using our implementation can send datagrams. If the peer does not announce support for the datagram extension, the application cannot send datagrams, and the API will return an error. Sending and receiving datagrams are independent, thus if a sender sends datagrams but does not receive datagrams, it will not switch to streams and communication will not fail (since it can only send datagrams if the peer announced support).\r\n\r\n> Section 5.1\r\n> \r\n> \"RTP packets of different RTP sessions MUST use distinct flow identifiers. If endpoints wish to send multiple types of media in a single RTP session, they can do so by following the guidance specified in [RFC8860].\"\r\n> \r\n> [BA] Was support for multiple RTP sessions implemented?\r\n\r\nSee above, our implementation supports multiplexing using flow identifiers, but we did not run any tests using multiple sessions.\r\n\r\n> \"A single RTP session can be associated with one or two flow identifiers. Thus, it is possible to send RTP and RTCP packets belonging to the same session using different flow identifiers. RTP and RTCP packets of a single RTP session can use the same flow identifier (following the procedures defined in [RFC5761]), or they can use different flow identifiers.\"\r\n> \r\n> [BA] Did the RoQ implementation support sending RTP and RTCP using different flow identifiers?\r\n\r\nYes, see above.\r\n\r\n> \" The association between flow identifiers and RTP streams MUST be negotiated using appropriate signaling. The signaling happens out of band and thus a stream or DATAGRAM with a given flow identifer can arrive before the signaling finished. In that case, an endpoint cannot associate the stream or DATAGRAM with the corresponding RTP stream. \"\r\n> \r\n> [BA] Did the RoQ implementation require creation of the association via signaling?\r\n\r\nWe did not implement signaling. In our test applications, parameters were static.\r\n\r\n> There have been RTP implementations in which an event is triggered on arrival of a non-signaled flow identifier, allowing the application to decide whether to accept the incoming stream or not. If the incoming stream is accepted, the mapping between flow id and SSRC could be authorized.\r\n> \r\n> This allows for the handling of incoming streams without signaling, or if the signaling has not yet arrived. For example, if the application feels it can render the incoming stream (subject to the limits described in the rest of the paragraph) it can choose to do so.\r\n> \r\n> \"If the number of buffered streams exceeds the limit on buffered streams, the endpoint MUST send a STOP_SENDING with the error code ROQ_UNKNOWN_FLOW_ID. \"\r\n> \r\n> [BA] Was this implemented?\r\n\r\nThis was added very recently. It is implemented in our implementation, but we did not extensively test it (yet).\r\n\r\n> Section 5.2\r\n> \r\n> \" A RoQ sender can open new QUIC streams for different RTP packets using the same flow identifier. \"\r\n> \r\n> [BA] Was this implemented?\r\n\r\nYes, see above.\r\n",
          "createdAt": "2024-05-21T09:54:45Z",
          "updatedAt": "2024-05-21T09:54:45Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba - at least some of these questions (and Mathis's answers) could feed into the shepherd write-up for this draft, I think? ",
          "createdAt": "2024-05-21T15:11:37Z",
          "updatedAt": "2024-05-21T15:11:37Z"
        }
      ]
    },
    {
      "number": 223,
      "id": "I_kwDOFUmh7s6LsoGE",
      "title": "Resolve Signaling dependency discussed in interim meeting",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/223",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [
        "mengelbart"
      ],
      "labels": [
        "IETF120"
      ],
      "body": "At the last interim meeting, we discussed the changes made in #212. Some points that came up in the discussion:\r\n\r\n- The sentence *MUST be negotiated using appropriate signaling* creates a dependency on signaling that should not exist.\r\n- We should allow endpoints to close the connection with error code unknown flow IDs.\r\n- Ideally, signaling should finish before packets carrying flow IDs that depend on the signaling are sent.\r\n- Buffering *some* amount of data arriving with unknown flow IDs is a reasonable solution if necessary because signaling can't be guaranteed to finish in time, and applications can deal with the buffered data.",
      "createdAt": "2024-06-10T12:03:50Z",
      "updatedAt": "2024-06-21T14:56:43Z",
      "closedAt": "2024-06-21T14:56:43Z",
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> * The sentence _MUST be negotiated using appropriate signaling_ creates a dependency on signaling that should not exist.\r\n\r\nI agree on this point, but we should be more explicit in the draft - at least some people intend to use RoQ without signaling (whether via preconfiguration, or just endpoints figuring out what to do with unknown flow IDs). ",
          "createdAt": "2024-06-21T13:08:19Z",
          "updatedAt": "2024-06-21T13:08:19Z"
        }
      ]
    },
    {
      "number": 224,
      "id": "I_kwDOFUmh7s6ND6RG",
      "title": "Align RoQ and SDP-RoQ drafts (in RoQ)",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/224",
      "state": "OPEN",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "IETF120"
      ],
      "body": "We think the RoQ draft is perfect, and we want to make it just a little more perfect. \r\n\r\nWe want to \r\n\r\n- Minimize any mention of signaling and configuration in the RoQ draft.\r\n- Explain considerations for using RoQ on a QUIC connection (using datagrams, flow control, congestion control, etc.) Depending on the underlying QUIC implementation, you might or might not be able to change behaviors, but this is also information for RoQ implementers who are still choosing an underlying QUIC implementation. \r\n- Adjust the pointers to the [SDP-RoQ](https://github.com/mengelbart/draft-engelbart-qlog-roq-events) draft in the RoQ draft.\r\n- Make sure that the [SDP-RoQ](https://github.com/mengelbart/draft-engelbart-qlog-roq-events) draft includes what is necessary to use RoQ with signaling, using SDP as the common case and mentioning that other ways of configuring a RoQ session are possible. \r\n\r\nSpencer will also make the necessary adjustments in the SDP-RoQ draft. \r\n\r\nThis issue is the counterpart to Issue [8](https://github.com/SpencerDawkins/sdp-roq/issues/8) in the [sdp-roq](https://github.com/SpencerDawkins/sdp-roq) Github repo.",
      "createdAt": "2024-06-21T13:59:39Z",
      "updatedAt": "2024-07-20T04:36:58Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 226,
      "id": "I_kwDOFUmh7s6QTRvz",
      "title": "How to maintain RTCP bandwidth limits?",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/226",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The [RTP specification](https://datatracker.ietf.org/doc/html/rfc3550) includes mechanisms for [estimating and limiting RTCP bandwidth usage](https://datatracker.ietf.org/doc/html/rfc3550#section-6.2). \r\n\r\nCurrently the RTP over QUIC (RoQ) specification does not discuss how to maintain RTCP bandwidth limits.  In particular, if RTCP is transported over QUIC streams rather than datagrams, retransmission of RTCP would occur \"under the covers\", making it difficult to use the existing estimation and limitation mechanisms. ",
      "createdAt": "2024-07-19T22:01:08Z",
      "updatedAt": "2024-11-04T10:06:48Z",
      "closedAt": "2024-10-20T19:00:06Z",
      "comments": [
        {
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems, there are two cases to consider: 1. unreliable datagrams and 2. reliable streams.\n\n1. This would work as normal RTCP packets without retransmissions, the data rate pushed to the network layer would be roughly the same and the computation could remain unchanged.  We could consider the QUIC per datagram packet overhead but this is hard to estimate as there would be ACKs in the opposite direction (of unknown frequency) and we don't quite know the header overhead as this may or may not be shared with other frames.\n\nIt seems we need to define a reference point for RTCP rate calculation.  RFC 3550 chooses to include UDP and IP headers but I am not so sure about RTP over TCP as RFC 4571 seems to be silent about this.  We know we will run on top of UDP, so UDP and IP headers could also be included and so could be QUIC short headers and the fixed overhead of a datagram frame.  The rest is too fuzzy to characterize but we could indicate this to be a lower bound and it would certainly reflect what can be attributed to sending datagrams.\n\n2. Using QUIC streams is somewhat like TCP.  All bets are off as we have absolutely no idea how packetization will happen and what the associated overhead would be.  Hence, we should probably define the reference point to be above QUIC and just count what goes in terms of RTCP packets.  One could construct a \"virtual RTCP rate\" assuming the same overhead as for 1. to be consistent.\n\nIn either case, we may leverage information available from the QUIC stack, such as RTT and precise loss information.  This just would mean that the mean RTCP packet size, avg_rtcp_size in RFC 3550, would be effectively smaller as fewer information needs to be conveyed inside RTCP.\n\nOne could think of QUIC stack implementations to assess and export their induced overhead at some granularity to obtain an overhead estimate from which one could compute a scaling factor for RTCP bandwidth.  Not sure this is worth it.\n\nFinally, the RTCP bandwidth is most crucial for distributed interval computation in groups, which we don't have at this point with TCP or with QUIC.",
          "createdAt": "2024-07-21T15:04:14Z",
          "updatedAt": "2024-07-21T15:04:14Z"
        },
        {
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "body": "The problem of unknown overhead would also apply for retransmissions in case of using QUIC streams, but I think the same considerations for a reference point would apply.\n",
          "createdAt": "2024-07-21T15:05:17Z",
          "updatedAt": "2024-07-21T15:05:17Z"
        },
        {
          "author": "alvestrand",
          "authorAssociation": "NONE",
          "body": "In what case would violating the RTCP bandwidth limit actually matter?\r\nRTCP overhead on the sender->receiver path (SR and friends)?\r\nRTCP overhead on the receiver->sender path (RR and friends)?\r\nIt has always seemed to be a bit strange to me that we consider these two together in a point-to-point connection.\r\n(Multicast is different)",
          "createdAt": "2024-11-04T10:06:46Z",
          "updatedAt": "2024-11-04T10:06:46Z"
        }
      ]
    },
    {
      "number": 230,
      "id": "I_kwDOFUmh7s6cGDrr",
      "title": "Disambiguate \"Packet\" in the terminology section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/issues/230",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "I'd like to include \"Packet\" as one of the terms we describe as ambiguous when unqualified in this draft, and propose that unqualified \"packet\" always refers to a QUIC packet. I believe that's the way we use unqualified \"packet\" in -12. \r\n\r\nThis is a helpful change for me, in writing [SDP Offer/Answer for RTP over QUIC (RoQ)](https://spencerdawkins.github.io/sdp-roq/draft-dawkins-avtcore-sdp-roq.html).",
      "createdAt": "2024-10-28T15:54:02Z",
      "updatedAt": "2025-02-06T21:05:04Z",
      "closedAt": "2025-02-06T21:05:04Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI4OTU5NzUz",
      "title": "Draft section about used RTP/RTCP packets and restrictions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/1",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-03T09:13:51Z",
      "updatedAt": "2021-05-17T10:29:16Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "15dfd07af0ac380d51b42c952e096d2ee41e3c7e",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "rtcp-restrictions",
      "headRefOid": "e691a73184a513899fe992c574057897fa342577",
      "closedAt": "2021-05-08T15:47:21Z",
      "mergedAt": "2021-05-08T15:47:21Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "c416b71a37b9ff8891c9ba62af876c9e9c25334c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ1NzY5NzY2",
      "title": "Add identifiers to the cc interface",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/2",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-17T11:08:02Z",
      "updatedAt": "2021-05-17T16:53:53Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "386a04a2a6985f77ba9e9e4b4d46f8ba3b890ac8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "add-interface-identifiers",
      "headRefOid": "cb6e602846ddc421cad78b5dae14d2f065b7e35a",
      "closedAt": "2021-05-17T16:31:42Z",
      "mergedAt": "2021-05-17T16:31:42Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3fdbd66070a57196e538e1c4eaa389d262d47ebe"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY2MDA0MzA4",
      "title": "Update draft-engelbart-rtp-over-quic.md",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/3",
      "state": "MERGED",
      "author": "joerg-ott",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi Mathis, some thoughts on SDP signalling and a concrete example are in now. The detailed protocol procedures would likely be quite lengthy, so for an initial draft to see what people think, this might be good enough.",
      "createdAt": "2021-06-09T15:06:48Z",
      "updatedAt": "2021-06-09T16:53:49Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "79e265cabab1ee3f33e7cf696ba733bd871ab467",
      "headRepository": "joerg-ott/rtp-over-quic-draft",
      "headRefName": "patch-1",
      "headRefOid": "93749c47fdcc372668de6d4e81cdb6f3626688c8",
      "closedAt": "2021-06-09T16:53:49Z",
      "mergedAt": "2021-06-09T16:53:49Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "cb8fdaa379c3f9dea77140481c7f1649fabe0049"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgwNjgxMjk1",
      "title": "Fix typos and clarify some terminology",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/4",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-30T09:18:32Z",
      "updatedAt": "2022-03-04T09:35:59Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "f7bd274edc900fb100e7a6cd749a98f457831150",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "terminology",
      "headRefOid": "137b2a4313d2445adfffa77e6fdf60c92eca8b5e",
      "closedAt": "2021-07-11T16:59:30Z",
      "mergedAt": "2021-07-11T16:59:30Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3f76be963765d4267472d6fbbfa863c040303266"
      },
      "comments": [
        {
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "body": "Quick note: in a few places, we may need to speak of \"RTP and RTCP packets\" instead of just \"RTP packets\".\r\nAnd I noticed: \"A RTP packet\" -> \"An RTP packet\"",
          "createdAt": "2021-07-11T16:34:15Z",
          "updatedAt": "2021-07-11T16:34:15Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> Quick note: in a few places, we may need to speak of \"RTP and RTCP packets\" instead of just \"RTP packets\".\r\n> And I noticed: \"A RTP packet\" -> \"An RTP packet\"\r\n\r\nMakes sense. I'll merge this PR first and then create another one for these changes. ",
          "createdAt": "2021-07-11T16:59:24Z",
          "updatedAt": "2021-07-11T16:59:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzNjA1MDM4",
          "commit": {
            "abbreviatedOid": "137b2a4"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-11T16:33:06Z",
          "updatedAt": "2021-07-11T16:33:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzNjA1MzE1",
          "commit": {
            "abbreviatedOid": "137b2a4"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-11T16:37:01Z",
          "updatedAt": "2021-07-11T16:37:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3MzgwNzA3",
      "title": "Always name both, RTP and RTCP where applicable",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/5",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-11T18:57:12Z",
      "updatedAt": "2022-03-04T09:35:56Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3f76be963765d4267472d6fbbfa863c040303266",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "always-name-rtp-and-rtcp",
      "headRefOid": "fff6f1b82db8b5e6844fcc5bf79002e96f0ac908",
      "closedAt": "2021-07-12T10:22:18Z",
      "mergedAt": "2021-07-12T10:22:18Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "4f0fea14d24c04f29aa3fcafe0e4f79c5400c042"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzODQxNTgy",
          "commit": {
            "abbreviatedOid": "fff6f1b"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-12T08:20:58Z",
          "updatedAt": "2021-07-12T08:20:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3NjU4MzI0",
      "title": "Update outdated Draft/RFC references",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/6",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-12T09:15:38Z",
      "updatedAt": "2022-03-04T09:35:55Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3f76be963765d4267472d6fbbfa863c040303266",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "update-references",
      "headRefOid": "15f11672d191f67668d8f0fb76be4d4a5eaf4f71",
      "closedAt": "2021-07-12T10:25:39Z",
      "mergedAt": "2021-07-12T10:25:39Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "e3a010e93ca98f3728f88125b02dc24567d59720"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 7,
      "id": "PR_kwDOFUmh7s40AhbR",
      "title": "Restructure to focus on possible CC schemes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/7",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-06T22:25:47Z",
      "updatedAt": "2022-05-20T08:08:28Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "f6d8759952dd0467d94a90af3cdb242047ac2d48",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "restructure",
      "headRefOid": "f579bd940804a8ff627aba79e9080845ee43e5be",
      "closedAt": "2022-03-07T17:22:13Z",
      "mergedAt": "2022-03-07T17:22:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "f579bd940804a8ff627aba79e9080845ee43e5be"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 8,
      "id": "PR_kwDOFUmh7s43e6Ao",
      "title": "Update congestion control and RTCP sections",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/8",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-09T08:01:31Z",
      "updatedAt": "2022-05-20T08:08:28Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0fc59ccb6beec441751e338c93cf6f00b22ad8bc",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "03-updates",
      "headRefOid": "1f2fbc66d74f92fc40536a9be6b1ce93220c7715",
      "closedAt": "2022-05-12T06:46:45Z",
      "mergedAt": "2022-05-12T06:46:45Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2f9992fd4237f1ecfed20eeeee3332019344e989"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "PR_kwDOFUmh7s43oL2r",
      "title": "Rtp over quic streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/9",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-11T07:45:02Z",
      "updatedAt": "2022-05-20T08:08:28Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2f9992fd4237f1ecfed20eeeee3332019344e989",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "rtp-over-quic-streams",
      "headRefOid": "a4a771f55a825fe6d7a51b7d8ba550b27f66c2c3",
      "closedAt": "2022-05-12T06:49:02Z",
      "mergedAt": "2022-05-12T06:49:02Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "5566b2ff06e22076423b0a8299c02a793826f805"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "PR_kwDOFUmh7s44LJBs",
      "title": "Remove SDP section and fix some small issues",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/10",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-20T08:42:44Z",
      "updatedAt": "2022-07-19T07:32:34Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "5566b2ff06e22076423b0a8299c02a793826f805",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "04-updates",
      "headRefOid": "146a67e11b0daf16dc076f382d3ffe359885cdfd",
      "closedAt": "2022-06-24T07:30:05Z",
      "mergedAt": "2022-06-24T07:30:05Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "22e9908ca3a81b5d070c5215e720392e408e5bee"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "PR_kwDOFUmh7s46QnSp",
      "title": "Update draft-engelbart-rtp-over-quic.md",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/12",
      "state": "MERGED",
      "author": "joerg-ott",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Various extensions: Scope, ALPN, Connection sharing, Discussion, various bits.",
      "createdAt": "2022-06-23T17:13:27Z",
      "updatedAt": "2022-06-24T07:20:10Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "04-updates",
      "baseRefOid": "2822ebc362f1c780cf5ec6a628048f4297b4f52b",
      "headRepository": "joerg-ott/rtp-over-quic-draft",
      "headRefName": "patch-3",
      "headRefOid": "c2277e23e182749891134a20f39fb3adf8009653",
      "closedAt": "2022-06-24T07:20:10Z",
      "mergedAt": "2022-06-24T07:20:09Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "66b788f2a38b4b5665947ed48cf3bc1b0551570f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "PR_kwDOFUmh7s46avDw",
      "title": "Clarify stream types and explain stream closing",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/17",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This PR clarifies which stream types are used (#14) and adds an explicit requirement to close streams once a packet was completely sent. Maybe we can also add considerations about stream concurrency (#15) here?",
      "createdAt": "2022-06-27T13:43:48Z",
      "updatedAt": "2022-09-23T07:22:48Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "clarify-stream-usage",
      "headRefOid": "cda9b732f0efbc9cb80f3d5a0dd271cbd491055e",
      "closedAt": "2022-09-23T07:18:16Z",
      "mergedAt": "2022-09-23T07:18:16Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3dc40e5272c11761dadf086c4aa09ccac3e9fdda"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "PR_kwDOFUmh7s47ZFKY",
      "title": "Update adopted name",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/18",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-07-14T09:23:11Z",
      "updatedAt": "2022-09-12T13:52:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "22e9908ca3a81b5d070c5215e720392e408e5bee",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "update-adopted-name",
      "headRefOid": "6274d14609a982be97c5f8749be2ef82929a577c",
      "closedAt": "2022-07-19T07:36:44Z",
      "mergedAt": "2022-07-19T07:36:44Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d556493e4c9539aa8613f81599e9f200e68a3d75"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "PR_kwDOFUmh7s48NSGD",
      "title": "Clarify which flow id to use for retransmissions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/19",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #16 ",
      "createdAt": "2022-07-27T20:53:15Z",
      "updatedAt": "2022-09-23T07:22:50Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "clarify-retransmission-flow-id",
      "headRefOid": "33019b0e75bbaea289c40182e2b2ee5baad27e2a",
      "closedAt": "2022-09-12T13:54:22Z",
      "mergedAt": "2022-09-12T13:54:22Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "8b1c3e1a4dd08c56d933e79fbbecf30eb4ffa088"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 28,
      "id": "PR_kwDOFUmh7s48jk1c",
      "title": "Remove TODO because it was done by adding sec. 8.3",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/28",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #20 ",
      "createdAt": "2022-08-03T07:49:30Z",
      "updatedAt": "2022-09-12T13:52:02Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "remove-shared-connection-todo",
      "headRefOid": "bda42b73707548953173646721be3925a7e9c5b1",
      "closedAt": "2022-09-12T13:45:26Z",
      "mergedAt": "2022-09-12T13:45:26Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "53acd6ef5e4f0247c4ee50eab0de921d4c8388c7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 30,
      "id": "PR_kwDOFUmh7s48okeT",
      "title": "Remove note about possible use of RTCP in QUIC CC",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/30",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #23 ",
      "createdAt": "2022-08-04T09:21:08Z",
      "updatedAt": "2022-09-12T13:51:48Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "delete-rtcp-quic-cc-note",
      "headRefOid": "77aff38d80ee441c98455424d1e5e3fd5c0f3828",
      "closedAt": "2022-09-12T13:46:33Z",
      "mergedAt": "2022-09-12T13:46:33Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2c8f9243df75eecdd180e79544cf294990fbd396"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Also fixes #11 ",
          "createdAt": "2022-08-04T09:22:43Z",
          "updatedAt": "2022-08-04T09:22:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 32,
      "id": "PR_kwDOFUmh7s48qrHe",
      "title": "Delete note because it won't be a problem",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/32",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "closes #22 ",
      "createdAt": "2022-08-04T17:10:24Z",
      "updatedAt": "2022-09-12T13:51:46Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2c8f9243df75eecdd180e79544cf294990fbd396",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "delete-delay-based-cc-note",
      "headRefOid": "04ba7637bfd1e38f8ea439b2831fd79d1ec45352",
      "closedAt": "2022-09-12T13:51:06Z",
      "mergedAt": "2022-09-12T13:51:06Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "710f7cf91c079d10da8819655f47711687aade15"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 33,
      "id": "PR_kwDOFUmh7s4-w8lx",
      "title": "Clarify what *adequate congestion control* means",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/33",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Reference RFC 9002 and 8085 to clarify what adequate congestion control means. closes #26 ",
      "createdAt": "2022-09-12T09:17:13Z",
      "updatedAt": "2022-09-23T07:22:40Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d556493e4c9539aa8613f81599e9f200e68a3d75",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "cite-cc-requirements",
      "headRefOid": "a6eaa3ffe0b7e3890a0b3270c1748f8cb3637f64",
      "closedAt": "2022-09-23T07:19:09Z",
      "mergedAt": "2022-09-23T07:19:08Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "PR_kwDOFUmh7s4-yJAB",
      "title": "Stream concurrency considerations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/34",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-12T13:17:02Z",
      "updatedAt": "2022-10-24T14:28:41Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "stream-concurrency-considerations",
      "headRefOid": "1bfbfdfb99bd9db7734530440fc7a6eef12b7fdc",
      "closedAt": "2022-10-24T14:28:41Z",
      "mergedAt": "2022-10-24T14:28:40Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "413d581274edc938e14112cbb917c7557091cf48"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 36,
      "id": "PR_kwDOFUmh7s4-y4Ln",
      "title": "State requirements instead of certain algorithms",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/36",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-12T15:37:16Z",
      "updatedAt": "2022-10-24T14:41:47Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "cc-requirements",
      "headRefOid": "95797c0a352853695d88558a36135ed0f863c8fa",
      "closedAt": "2022-10-24T14:41:46Z",
      "mergedAt": "2022-10-24T14:41:46Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "651d67471b525e2343e7a2d9e9fa08fc35070e97"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 37,
      "id": "PR_kwDOFUmh7s4_Ls2d",
      "title": "Add recommendation to expose estimated bandwidth",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/37",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #35 ",
      "createdAt": "2022-09-19T09:10:17Z",
      "updatedAt": "2022-09-23T07:22:31Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "8b1c3e1a4dd08c56d933e79fbbecf30eb4ffa088",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "add-bandwidth-estiation-api",
      "headRefOid": "f10ba95ccd7b7eda4b32ac155f1e853d7451e688",
      "closedAt": "2022-09-22T08:50:13Z",
      "mergedAt": "2022-09-22T08:50:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "f1afdd8ff421a4d143a238427d0c5730c3b4cb21"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 38,
      "id": "PR_kwDOFUmh7s4_LtF9",
      "title": "Relax CC API configuration requirement",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/38",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "resolve #27 ",
      "createdAt": "2022-09-19T09:11:12Z",
      "updatedAt": "2022-10-24T15:00:36Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "api-for-congestion-controller-configuration",
      "headRefOid": "7527d2080b19e5d4587019e33df1bf0e20b197f4",
      "closedAt": "2022-10-24T15:00:34Z",
      "mergedAt": "2022-10-24T15:00:34Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "8e4b8d8cca656b8faa2881aa8de87d0c507bc9ea"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 40,
      "id": "PR_kwDOFUmh7s4_eh7c",
      "title": "Add topology subsection",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/40",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-23T07:11:45Z",
      "updatedAt": "2022-10-24T15:26:29Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d562b3b4786f7cf566efab3afa98bc27156dd2a7",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "rtp-topology-considerations",
      "headRefOid": "ff1e84968415e0dac3c289d5e028ff8e126ac385",
      "closedAt": "2022-10-24T15:26:28Z",
      "mergedAt": "2022-10-24T15:26:28Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "a1326e571e772fb6bad0924ab54fe4f7151500df"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thanks!\r\n\r\nI added another commit with the changes you suggested. I added a sentence about forwarding RESET_STREAM frames to section 6.1 because I think it might be confusing to reference the concept of closing streams via RESET_STREAM frames early in the document (even before the mapping to streams is introduced).\r\nAlternatively, we could move the topology considerations section to the back of the document.",
          "createdAt": "2022-09-29T10:20:59Z",
          "updatedAt": "2022-09-29T10:20:59Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "\"Once the RTP packet has been completely transmitted, the sender MUST gracefully close the stream.\"\r\n\r\n[BA] How does the translator know that the RTP packet has been completely transmitted?  It could know if it receives a FIN, or alternatively if there is a length field at the beginning of the packet. But what happens if it never receives the full length (or a RESET_STREAM)?\r\n\r\nIf the translator implements \"cut through\" behavior, rather than \"store and forward\", sending what it receives (including a FIN or a RESET_STREAM) it would seem that the above text isn't necessary.  The translator could function, even in situations where it wouldn't know if the RTP packet has been completely transmitted. ",
          "createdAt": "2022-09-29T14:10:00Z",
          "updatedAt": "2022-09-29T14:13:37Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I am not sure I understand your question. I added the sentence in https://github.com/mengelbart/rtp-over-quic-draft/pull/17 to make sure a sender closes the stream after each packet so that a receiver knows when the packet was completely received. We may delete it again if we decide to add a length field, but I'd like to keep it for now. If a translator never receives the full length there will be a RESET_STREAM, which it then has to forward:\r\n\r\n> A translators that translates between two endpoints, which are both connected via QUIC, MUST forward RESET\\_STREAM frames received from one end to the other end, unless it is forwarding the RTP packets on QUIC datagrams.\r\n",
          "createdAt": "2022-09-30T07:51:16Z",
          "updatedAt": "2022-09-30T07:51:16Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5Ct9xS",
          "commit": {
            "abbreviatedOid": "ae86df3"
          },
          "author": "aboba",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "\"the translator either may need to rewrite\"\r\n\r\n[BA] Can we delete the \"either\"?  Also, you might want to clarify that you are referring to a \"transport translator\" that could need codec-specific knowledge to do the packetization from frame/stream to datagram transport. \r\n\r\nWhat happens if a translator receives a RESET_STREAM frame?  Is it still required to do a graceful close?  Maybe just require the translator to echo the behavior that it sees (e.g. if it receives a graceful close, then send one, if it receives a RESET_STREAM, then send that along, unless it is forwarding datagrams). \r\n\r\n",
          "createdAt": "2022-09-24T21:54:03Z",
          "updatedAt": "2022-09-24T21:55:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "PR_kwDOFUmh7s5A6nIu",
      "title": "Add length field and allow multiple packets per stream",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/43",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-17T10:15:36Z",
      "updatedAt": "2022-10-24T15:03:44Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "651d67471b525e2343e7a2d9e9fa08fc35070e97",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "length-field",
      "headRefOid": "410ae215371184370dc8a719a7a21e9540857640",
      "closedAt": "2022-10-24T15:03:43Z",
      "mergedAt": "2022-10-24T15:03:43Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d562b3b4786f7cf566efab3afa98bc27156dd2a7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 44,
      "id": "PR_kwDOFUmh7s5A6v0x",
      "title": "Allow mixing of streams and datagrams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/44",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-17T10:43:59Z",
      "updatedAt": "2022-10-24T14:30:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2910050f62e48360cdcb9042a5689b56f5e0c6e3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "mix-streams-and-datagrams",
      "headRefOid": "8202836850710f6992d18848f678b2bc50cfe22e",
      "closedAt": "2022-10-24T14:30:03Z",
      "mergedAt": "2022-10-24T14:30:03Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "dd403df25b65ac476b981d57210909f21205be70"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 46,
      "id": "PR_kwDOFUmh7s5CIK_j",
      "title": "WIP: Rely on WebTransport for multiplexing",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/46",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This PR is a first draft to integrate WebTransport as an abstraction layer on top of QUIC to provide multiplexing.",
      "createdAt": "2022-11-03T11:13:02Z",
      "updatedAt": "2023-05-11T16:09:50Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ab2718838fee503cca66f98eaeb96f2fede4f1b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/webtransport-multiplexing",
      "headRefOid": "5c2551fc826b227e7a0c3be5e3a87907b7763209",
      "closedAt": "2022-12-21T15:28:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "PR_kwDOFUmh7s5F96PE",
      "title": "Add new multiplexing subsection using flow IDs",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/54",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-12-21T15:28:28Z",
      "updatedAt": "2023-01-17T09:58:26Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ab2718838fee503cca66f98eaeb96f2fede4f1b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/flow-id-multiplexing",
      "headRefOid": "b24f20edd9f04e668ee0a6c43f47b2c680f0dcdf",
      "closedAt": "2023-01-17T09:58:25Z",
      "mergedAt": "2023-01-17T09:58:25Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "99a1494c2c913bd234bb77016e89d30e09e35aa2"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Has been proposed on mailing list. Question from @aboba, discussed with @mengelbart. OK to merge. ",
          "createdAt": "2023-01-13T16:08:31Z",
          "updatedAt": "2023-01-13T16:08:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 56,
      "id": "PR_kwDOFUmh7s5HT6_A",
      "title": "Clarify highest sequence number mapping",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/56",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-13T09:04:45Z",
      "updatedAt": "2023-05-11T16:09:55Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ab2718838fee503cca66f98eaeb96f2fede4f1b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/highest-sequence-nr",
      "headRefOid": "842c0164f9ec95191056e4ff2a9c9098b6b64e86",
      "closedAt": "2023-01-23T15:19:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Included in #60 ",
          "createdAt": "2023-01-23T15:19:31Z",
          "updatedAt": "2023-01-23T15:19:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDOFUmh7s5HT7Kg",
      "title": "Generalize which packets should be included",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/57",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "RTP packets can now also be sent in streams, thus it makes sense to say RTP packet (which could be in a datagram or stream) instead of datagram frame here.",
      "createdAt": "2023-01-13T09:05:24Z",
      "updatedAt": "2023-05-11T16:09:53Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ab2718838fee503cca66f98eaeb96f2fede4f1b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/fraction-lost",
      "headRefOid": "d0e586ee6465509d6b42aa5081d3fc073c556502",
      "closedAt": "2023-01-17T09:39:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Will be solved in #60 ",
          "createdAt": "2023-01-17T09:39:57Z",
          "updatedAt": "2023-01-17T09:39:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDOFUmh7s5HgED1",
      "title": "Address many/most of comments from @goelvidhi",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/60",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "This should be worth reviewing now, while I work on larger topics. \r\n\r\nComments and corrections are graciously welcomed. \r\n\r\nfixes #53 ",
      "createdAt": "2023-01-16T23:11:21Z",
      "updatedAt": "2023-01-23T15:51:33Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "99a1494c2c913bd234bb77016e89d30e09e35aa2",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "53-comments",
      "headRefOid": "d5f3d0f52256b01f836aee3fc21876e0ffc22c28",
      "closedAt": "2023-01-23T15:51:32Z",
      "mergedAt": "2023-01-23T15:51:32Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "3aae64deaee45942de470598192db9a44e8b063a"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I have a couple of open questions in the comments on this PR for you - do you think this PR is ready to commit, so we can focus on more specific issues (some of which I've opened in the last day or two)?",
          "createdAt": "2023-01-20T17:22:53Z",
          "updatedAt": "2023-01-20T17:22:53Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thanks, @SpencerDawkins! I think I replied to all questions, and I think we can discuss the congestion control vs. rate adaptation question in #61, and we can merge this PR.",
          "createdAt": "2023-01-23T15:25:22Z",
          "updatedAt": "2023-01-23T15:25:22Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I found one typo, and corrected it. I'm merging now. ",
          "createdAt": "2023-01-23T15:51:05Z",
          "updatedAt": "2023-01-23T15:51:05Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5KkxGZ",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-17T09:03:46Z",
          "updatedAt": "2023-01-17T09:38:38Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "additional",
              "createdAt": "2023-01-17T09:03:46Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            },
            {
              "originalPosition": 134,
              "body": "Should we also reference [Section 6 of RFC 9002](https://www.rfc-editor.org/rfc/rfc9002.html#section-6) here?\r\n```suggestion\r\n    but can detect lost packets based on the Gap numbers contained in QUIC ACK frames {{Section 6 of !RFC9002}}.\r\n```",
              "createdAt": "2023-01-17T09:20:20Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            },
            {
              "originalPosition": 169,
              "body": "```suggestion\r\nfor QUIC is an alogrithm similar to TCP NewReno {{!RFC9002}}, but senders are free to choose\r\n```\r\n`!` makes it a normative reference, `?` for informative.",
              "createdAt": "2023-01-17T09:22:16Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            },
            {
              "originalPosition": 108,
              "body": "```suggestion\r\n    packets that were sent after the RTP packet, were already acknowledged.\r\n```\r\n\r\nIn streams, the RTP packet can be spread over many frames.",
              "createdAt": "2023-01-17T09:29:01Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            },
            {
              "originalPosition": 116,
              "body": "In another PR I added some more text to explain what the highest sequence number is in RTP:\r\n```\r\n  * Highest Sequence Number received*: In RTCP, this field is a 32-bit field\r\n    that contains the highest sequence number a receiver received in an RTP\r\n    packet and the count of sequence number cycles the receiver has observed. A\r\n    sender sends RTP packets in QUIC packets and receives acknowledgments for\r\n    the QUIC packets. By keeping a mapping from a QUIC packet to the RTP packets\r\n    encapsulated in that QUIC packet, the sender can infer the highest sequence\r\n    number and number of cycles seen by the receiver from QUIC acknowledgments.\r\n```\r\n\r\nDoes it make sense to add this explanation, and if yes, should we add it to this PR?",
              "createdAt": "2023-01-17T09:38:21Z",
              "updatedAt": "2023-01-17T09:38:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5KqgK3",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T00:28:43Z",
          "updatedAt": "2023-01-18T00:28:44Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "I think we should add this explanation. (Whether it is done here or in a separate PR, authors can decide that.)",
              "createdAt": "2023-01-18T00:28:43Z",
              "updatedAt": "2023-01-18T00:28:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5Kqgf6",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T00:30:51Z",
          "updatedAt": "2023-01-18T00:30:51Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "This reference and text is confusing. The text says TCP Reno but then it refers to QUIC Reno. I would just change this to, `The default congestion control specified for QUIC is Reno {{!RFC 9002}}`",
              "createdAt": "2023-01-18T00:30:51Z",
              "updatedAt": "2023-01-18T00:30:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5KqgnW",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "goelvidhi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-18T00:31:35Z",
          "updatedAt": "2023-01-18T00:31:35Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "replace congestion control with rate adaptation?",
              "createdAt": "2023-01-18T00:31:35Z",
              "updatedAt": "2023-01-18T00:31:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LN3NV",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T14:32:20Z",
          "updatedAt": "2023-01-19T14:32:20Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Corrected.",
              "createdAt": "2023-01-19T14:32:20Z",
              "updatedAt": "2023-01-19T14:32:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LOIUL",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T15:07:43Z",
          "updatedAt": "2023-01-19T15:07:43Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "@goelvidhi is right - this text/reference **is** scrambled. My thoughts are\r\n\r\n- TCP NewReno is [RFC6582]\r\n- the default QUIC congestion controller is [RFC9002] \r\n- [RFC9002] says \r\n> This document specifies a sender-side congestion controller for QUIC similar to TCP NewReno [RFC6582].\r\n\r\nSo, putting all this together, I get \r\n\r\n> The default congestion control specified for QUIC in {{RFC9002}} is similar to TCP NewReno {{RFC6582}}\r\n\r\nwhich (IIUC) gives the references for QUIC's default congestion controller and TCP NewReno correctly. \r\n\r\nPlease let me know if this is a Really Bad Idea.",
              "createdAt": "2023-01-19T15:07:43Z",
              "updatedAt": "2023-01-19T15:07:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LOJbh",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T15:10:08Z",
          "updatedAt": "2023-01-19T15:10:08Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "Fixed. ",
              "createdAt": "2023-01-19T15:10:08Z",
              "updatedAt": "2023-01-19T15:10:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LOPJC",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T15:22:17Z",
          "updatedAt": "2023-01-19T15:22:18Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "@mengelbart, I agree with @goelvidhi about adding this text. I put it in #60, so if it's also in another PR (which I haven't looked for yet), that should also be fine. ",
              "createdAt": "2023-01-19T15:22:18Z",
              "updatedAt": "2023-01-19T15:22:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LVlVc",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-20T16:21:26Z",
          "updatedAt": "2023-01-20T16:21:27Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "This is, of course, going to be maximally confusing to the reader, because RFC 8888 **says** it's enabling congestion control, but I think this is a good change to make for consistency in RTP-over-QUIC. \r\n\r\nLooking more closely at this text, RFC 8888 isn't technically part of \"RTP\", because it doesn't update any other RFC, so I think this is more accurate: \r\n\r\n> RTP itself does not specify a congestion control algorithm, but {{!RFC8888}} defines an RTCP\r\n> feedback message intended to enable rate adaptation for interactive real-time traffic using RTP,\r\n> and successful rate adaptation will accomoplish congestion control as well.\r\n> Various rate adaptation algorithms for real-time media are defined in separate RFCs\r\n> (e.g. SCReAM {{!RFC8298}} and NADA {{!RFC8698}}).\r\n\r\nAnd, looking more closely at the Abstract and Introduction, I think I should be naming both congestion control and rate adaptation in both places, and then favoring the use of rate adaptation thereafter. \r\n\r\nPlease let me know if this seems wrong or unhelpful. ",
              "createdAt": "2023-01-20T16:21:26Z",
              "updatedAt": "2023-01-20T16:21:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LckYt",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-23T15:11:11Z",
          "updatedAt": "2023-01-23T15:11:11Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "Sounds good to me.",
              "createdAt": "2023-01-23T15:11:11Z",
              "updatedAt": "2023-01-23T15:11:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5Lcn1Z",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-23T15:18:46Z",
          "updatedAt": "2023-01-23T15:18:46Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Sounds mostly fine to me, but I wonder if we need the part \"and successful rate adaptation will accomoplish congestion control as well.\"? I think it might bring up the question of how exactly we define both and what the difference is.",
              "createdAt": "2023-01-23T15:18:46Z",
              "updatedAt": "2023-01-23T15:18:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5LcpEK",
          "commit": {
            "abbreviatedOid": "5e0f0b8"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-23T15:21:24Z",
          "updatedAt": "2023-01-23T15:21:24Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "Oh, I just saw #61 is about this question. If we have some text early in the document that defines both terms, the question might have been answered already.",
              "createdAt": "2023-01-23T15:21:24Z",
              "updatedAt": "2023-01-23T15:21:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOFUmh7s5JzKQ7",
      "title": "Add Scoping description for Abstract and Introduction",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/63",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "First draft of updated Abstract and Introduction sections.\r\n\r\nObviously a close read from reviewers will be useful, but I'd especially call attention to whether the abstract and first part of the Introduction correctly summarize the document (my impression is that the scope of the document has increased over time, but the abstract and Introduction might not have captured the new scope). \r\n\r\nCloses #58.",
      "createdAt": "2023-02-12T19:38:03Z",
      "updatedAt": "2023-02-20T08:46:25Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2853821a8d8d121809381041786178157c36863e",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-58",
      "headRefOid": "503d7fea280f75eddf319589da78ac46f1742e83",
      "closedAt": "2023-02-20T08:46:24Z",
      "mergedAt": "2023-02-20T08:46:24Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "157005404bf8dcf5b7cfd0305e8379454bdadd24"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5NMohN",
          "commit": {
            "abbreviatedOid": "8a01814"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-13T08:39:47Z",
          "updatedAt": "2023-02-13T08:42:22Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nThis document does not cover signaling for session setup. SDP for RTP-over-QUIC is defined in separate documents such as {{?I-D.draft-dawkins-avtcore-sdp-rtp-quic}}, and can be carried in any signaling protocol that can carry SDP, including the Session Initiation Protocol (SIP) ({{?RFC3261}}), Real-Time Protocols for Browser-Based Applications (RTCWeb) ({{?RFC8825}}), or WebRTC-HTTP Ingestion Protocol (WHIP) ({{?I-D.draft-ietf-wish-whip}}).\r\n```",
              "createdAt": "2023-02-13T08:39:47Z",
              "updatedAt": "2023-02-13T08:42:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOFUmh7s5Jzl0X",
      "title": "First draft of definitions for congestion control and rate adaptation",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/64",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "This is a starting place for several related issues (#61, #62, and #59). \r\n\r\nCloses #61 ",
      "createdAt": "2023-02-13T02:12:34Z",
      "updatedAt": "2023-02-20T08:25:15Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3aae64deaee45942de470598192db9a44e8b063a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-61",
      "headRefOid": "38208ae4366856d8af03d9a25f65763e1936d712",
      "closedAt": "2023-02-20T08:25:13Z",
      "mergedAt": "2023-02-20T08:25:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2853821a8d8d121809381041786178157c36863e"
      },
      "comments": [
        {
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "body": "The above definitions state that rate adaptation is \"distinct\" from congestion control. But the distinction mentioned only covers the case in which one choose across multiple media flows and some aggregate congestion control can be performed. This appears to be a special case. Rate adaptation is generally one way to achieve congestion control, it would seem, and maybe in some cases the only one. Needs more thinking.",
          "createdAt": "2023-02-17T13:11:19Z",
          "updatedAt": "2023-02-17T13:11:19Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> The above definitions state that rate adaptation is \"distinct\" from congestion control. But the distinction mentioned only covers the case in which one choose across multiple media flows and some aggregate congestion control can be performed. This appears to be a special case. Rate adaptation is generally one way to achieve congestion control, it would seem, and maybe in some cases the only one. Needs more thinking.\r\n\r\n@joerg-ott, I agree. I've rephrased this in my latest commit. \r\n\r\nWe will definitely need more thinking here - I see that Christian @Huitema has a [specific proposal for congestion response in MOQ](https://mailarchive.ietf.org/arch/msg/moq/sWDaR6lRu3tBLOvHkth-sipbf4Q/). That may not be directly applicable to RTP-over-QUIC, but it's a good example of the kind of this we should also consider in your draft. \r\n\r\nBut given that we have other issues for adding specific descriptions of rate control and this PR only targeted adding definitions, I think this PR is ready to merge. ",
          "createdAt": "2023-02-19T13:12:17Z",
          "updatedAt": "2023-02-19T13:12:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 66,
      "id": "PR_kwDOFUmh7s5KSPO6",
      "title": "Adding ACKs for Bernard and Sergio",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/66",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-02-19T13:29:48Z",
      "updatedAt": "2023-02-20T08:24:09Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3aae64deaee45942de470598192db9a44e8b063a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-55",
      "headRefOid": "1f5c8ac696100a566e47b2a7e193111c813309fc",
      "closedAt": "2023-02-20T08:24:08Z",
      "mergedAt": "2023-02-20T08:24:08Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "05e5c1ba8f73d9d397a8d0b44ffec761690eaa60"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 71,
      "id": "PR_kwDOFUmh7s5M78fH",
      "title": "Add @mengelbart RTCP analysis",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/71",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "It is likely that these new sections/tables need to be more carefully integrated into the previous text on RTCP. \r\n\r\nclose #48 ",
      "createdAt": "2023-03-27T05:55:49Z",
      "updatedAt": "2023-04-27T07:05:41Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "157005404bf8dcf5b7cfd0305e8379454bdadd24",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-48",
      "headRefOid": "426ca2b6c2d9de95f505db7f341063641214d73a",
      "closedAt": "2023-04-27T07:05:40Z",
      "mergedAt": "2023-04-27T07:05:40Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3624f2fa943fa8b7c8f491d36c908525e0b8ed32"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We should add \"header extensions\" to the section title (@SpencerDawkins agrees). ",
          "createdAt": "2023-04-19T17:04:42Z",
          "updatedAt": "2023-04-19T17:04:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I still need to work on Section 6.3. RTCP Control Packet Types - several of these packet types have \"\"partly\" or \"possibly\" under \"replaced by QUIC\", because they have multiple reports, and the answer to \"replaced by QUIC\" varies among the reports. My plan is to break those cases into one row per report, so the ability to map to/from QUIC is clearer. \r\n\r\nI don't think that will take long, but I think we should wait to merge until I can finish that. ",
          "createdAt": "2023-04-25T00:41:09Z",
          "updatedAt": "2023-04-25T00:41:09Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I think it's OK for us to merge this PR. There's still more analysis to do, but I'd like to land this PR and work on a couple of issues that I still haven't touched. ",
          "createdAt": "2023-04-26T23:28:11Z",
          "updatedAt": "2023-04-26T23:28:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5SlRpS",
          "commit": {
            "abbreviatedOid": "b1d8152"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Some of the information in the new tables in sections 6.3 and 6.4 duplicates what is written in sections 6.1 and 6.2. It could be helpful to have subsections for the details of each packet type and then reference the subsection from the tables. That would also make the tables easier to read.",
          "createdAt": "2023-04-14T13:51:44Z",
          "updatedAt": "2023-04-14T16:16:41Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Should we rename the section from just *RTCP* to *RTCP and RTP Header Extensions* if we add the subsection on header extensions?",
              "createdAt": "2023-04-14T13:51:44Z",
              "updatedAt": "2023-04-14T16:16:41Z"
            },
            {
              "originalPosition": 85,
              "body": "This table contains only *no*s and does not add anything that cannot be found in the IANA registry. I think we can replace it with a more general statement that payload-specific feedback types are not suitable to be replaced by the QUIC state.",
              "createdAt": "2023-04-14T13:54:39Z",
              "updatedAt": "2023-04-14T16:16:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5TGKMY",
          "commit": {
            "abbreviatedOid": "b1d8152"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T14:22:54Z",
          "updatedAt": "2023-04-20T14:22:54Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I agree. I'm making this change. ",
              "createdAt": "2023-04-20T14:22:54Z",
              "updatedAt": "2023-04-20T14:22:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5TGVb4",
          "commit": {
            "abbreviatedOid": "b1d8152"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-20T14:41:54Z",
          "updatedAt": "2023-04-20T14:41:54Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I think this is a good suggestion - I added \"Because QUIC is a generic transport protocol, QUIC cannot replace the following Payload-specific RTP Feedback (PSFB) feedback\" at the beginning of the section, but I left the list of feedback types and their documents in the text, just to make what we considered, clear to the reader. \r\n\r\nDoes that make sense?",
              "createdAt": "2023-04-20T14:41:54Z",
              "updatedAt": "2023-04-20T14:41:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5TpFvt",
          "commit": {
            "abbreviatedOid": "b1d8152"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-27T06:27:27Z",
          "updatedAt": "2023-04-27T06:27:28Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Yes, that sounds good. Thanks!",
              "createdAt": "2023-04-27T06:27:27Z",
              "updatedAt": "2023-04-27T06:27:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 72,
      "id": "PR_kwDOFUmh7s5M8bB2",
      "title": "Add details on supported topologies",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/72",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Note: we have introduced a MUST in this PR, so the guidance isn't entirely \"informational\". \r\n\r\ncloses #47 ",
      "createdAt": "2023-03-27T07:43:47Z",
      "updatedAt": "2023-04-27T06:26:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "157005404bf8dcf5b7cfd0305e8379454bdadd24",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-47",
      "headRefOid": "e7f6496014e9f0f08c26a187b2be2c8317d96bec",
      "closedAt": "2023-04-27T06:26:03Z",
      "mergedAt": "2023-04-27T06:26:03Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "7271014e241950bafb3a8982decd7aacb3963c42"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We're assuming that each topology is considered on its own. If (for example) Topo-Media-Translator  is also doing Topo-Trn-Translator, look at both rows in the table. But we note that with Topo-Back-To-Back, all bets are off ... ",
          "createdAt": "2023-04-19T16:33:21Z",
          "updatedAt": "2023-04-19T16:33:21Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I think this PR is ready to merge. ",
          "createdAt": "2023-04-20T14:13:16Z",
          "updatedAt": "2023-04-20T14:13:16Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - this is definitely ready to merge now. ",
          "createdAt": "2023-04-26T23:35:20Z",
          "updatedAt": "2023-04-26T23:35:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5SmTHO",
          "commit": {
            "abbreviatedOid": "a43ccbf"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "In my local rendering, the notes get squeezed into the table with very narrow columns, which makes it hard to read. Is there a better format we could use instead of a table, or maybe we could replace the footnotes with subsections that we can reference from the table?",
          "createdAt": "2023-04-14T16:19:53Z",
          "updatedAt": "2023-04-14T16:22:46Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Should we add this to the security considerations as well?",
              "createdAt": "2023-04-14T16:19:54Z",
              "updatedAt": "2023-04-14T16:22:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5Tc41b",
          "commit": {
            "abbreviatedOid": "aa52f1d"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-25T14:40:53Z",
          "updatedAt": "2023-04-25T14:40:54Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "I think this was meant to say *Burst Source* instead of *Distribution Source*. But I just re-read the text about SSM in RFC 7667, and I think we can actually drop this last part of the sentence here and also for `Note-UCast-Mcast`. I don't know why I thought *Distribution Source* and *Burst Source* could just be *logical entities*. The text says:\r\n\r\n> These sources send media to a dedicated Distribution Source, which forwards the RTP streams to the multicast group on behalf of the original RTP sources.\r\n\r\nSorry, I didn't catch that earlier!",
              "createdAt": "2023-04-25T14:40:54Z",
              "updatedAt": "2023-04-25T14:40:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 73,
      "id": "PR_kwDOFUmh7s5M8pTo",
      "title": "Add additional congestion control-related terms and definitions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/73",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #70 ",
      "createdAt": "2023-03-27T08:25:04Z",
      "updatedAt": "2023-04-14T12:25:00Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "157005404bf8dcf5b7cfd0305e8379454bdadd24",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-70",
      "headRefOid": "9b7247c9bc3738b0a363c611f051fef3989db13e",
      "closedAt": "2023-04-14T12:24:58Z",
      "mergedAt": "2023-04-14T12:24:58Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "428885d6e5ea8ed92e2feb21597758813aae42bf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5Q-zjV",
          "commit": {
            "abbreviatedOid": "9b7247c"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-27T08:51:59Z",
          "updatedAt": "2023-03-27T08:51:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 78,
      "id": "PR_kwDOFUmh7s5OV3Nh",
      "title": "Replace \"RTP over QUIC\" with RoQ acronym",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/78",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Closes #74 ",
      "createdAt": "2023-04-14T16:05:25Z",
      "updatedAt": "2023-04-27T07:14:14Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3624f2fa943fa8b7c8f491d36c908525e0b8ed32",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/acronym-roq",
      "headRefOid": "6db9f03a13d5a47b5091b7026cffc898db1206f4",
      "closedAt": "2023-04-27T07:14:13Z",
      "mergedAt": "2023-04-27T07:14:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "037be428ba688e19be178587a26b5fdce617b11b"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> Definitely - do it!\r\n> \r\n> One question - merging this won't update the text I have in my PRs. Do you think it will be easier to resolve conflicts if you merge this one first? If so, DEFINITELY - do it!\r\n> \r\n> If not, please let me know, and I'll work on rebasing my PRs (or whatever the right answer is).\r\n\r\nMerging the PRs first and now rebasing and updating this one was easier, so no need to change anything in your PRs :) Will merge this now, too.",
          "createdAt": "2023-04-27T07:14:01Z",
          "updatedAt": "2023-04-27T07:14:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5TlcJx",
          "commit": {
            "abbreviatedOid": "312aa0a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Definitely - do it! \r\n\r\nOne question - merging this won't update the text I have in my PRs. Do you think it will be easier to resolve conflicts if you merge this one first? If so, DEFINITELY - do it!\r\n\r\nIf not, please let me know, and I'll work on rebasing my PRs (or whatever the right answer is).",
          "createdAt": "2023-04-26T16:00:23Z",
          "updatedAt": "2023-04-26T16:00:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOFUmh7s5P017x",
      "title": "Explain why we aren't making BCP recommendations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/81",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "@aboba, thank you for the example in your comment on #69. That was helpful. \r\n\r\nclose #69",
      "createdAt": "2023-05-05T02:13:32Z",
      "updatedAt": "2023-05-11T07:49:34Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "037be428ba688e19be178587a26b5fdce617b11b",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-69",
      "headRefOid": "7d49c6f61c8242462ca2d721c4725afd39d0af25",
      "closedAt": "2023-05-11T07:49:33Z",
      "mergedAt": "2023-05-11T07:49:33Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "0f0023698f38b71e15fdc964c87a9cf58c5407d8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5UrQU8",
          "commit": {
            "abbreviatedOid": "7d49c6f"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-10T13:17:29Z",
          "updatedAt": "2023-05-10T13:17:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDOFUmh7s5P1CSN",
      "title": "Provide guidance for coexisting control loops",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/83",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "I want to provide a bit more description of GCC and classic response to packet loss, but I'm happy to get feedback on what I've committed so far. \r\n\r\nclose #59 ",
      "createdAt": "2023-05-05T03:51:40Z",
      "updatedAt": "2023-05-16T20:24:56Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ce5bf21aa30f3790040352c3e84942c199bc1780",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-59",
      "headRefOid": "e052610a0d9510c6f5fd2a0e50438f3d8a886649",
      "closedAt": "2023-05-16T20:24:55Z",
      "mergedAt": "2023-05-16T20:24:54Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "8dbb4db2bb1c951a00b4bb871ff94d2f809c7022"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart and @joerg-ott -\r\n\r\n> I want to provide a bit more description of GCC and classic response to packet loss, but I'm happy to get feedback on what I've committed so far.\r\n\r\nI've now done so, and I think this PR is ready for review. ",
          "createdAt": "2023-05-05T17:46:29Z",
          "updatedAt": "2023-05-05T17:46:29Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I corrected the spelling error and replied to the comment about GCC. If you think we need to discuss the GCC comment for a bit, please let me know, otherwise this PR should be ready to merge. ",
          "createdAt": "2023-05-11T01:11:07Z",
          "updatedAt": "2023-05-11T01:11:07Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @mengelbart - I worked over Section 7.4, but have one question that you're more likely to know the answer to than I am. \r\n\r\nFor the flow identifier described in the multiplexing section, I see \r\n\r\n>Each flow identifier is associated with a _stream of RTP packets_, _RTCP packets_, or a _data stream of a non-RTP protocol_\r\n\r\nIf I am **_using datagrams to carry multiple channels between two RTP endpoints_**, do we ALSO use this flow identifier to disambiguate (say) the datagrams carrying video, left-side audio, and right-side audio over the same QUIC connection?",
          "createdAt": "2023-05-12T15:47:11Z",
          "updatedAt": "2023-05-12T15:47:11Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I would expect the datagrams of the different channels to use different flow identifiers unless you send them in the same RTP session, which would require some other form of multiplexing, e.g., [RFC 8860](https://www.rfc-editor.org/rfc/rfc8860). The multiplexing section allows both, so we could use the flow identifier to disambiguate the datagrams, but we could also use the same identifier for more than one channel as long as we can still demultiplex them on the receiver side.",
          "createdAt": "2023-05-12T16:50:42Z",
          "updatedAt": "2023-05-12T16:50:42Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart, \r\n\r\n> I would expect the datagrams of the different channels to use different flow identifiers unless you send them in the same RTP session, which would require some other form of multiplexing, e.g., [RFC 8860](https://www.rfc-editor.org/rfc/rfc8860). The multiplexing section allows both, so we could use the flow identifier to disambiguate the datagrams, but we could also use the same identifier for more than one channel as long as we can still demultiplex them on the receiver side.\r\n\r\nIt's multiplexing all the way down, isn't it? Like \"[turtles all the way down](https://en.wikipedia.org/wiki/Turtles_all_the_way_down#:~:text=The%20saying%20alludes%20to%20the,larger%20turtles%20that%20continues%20indefinitely.)\". \r\n\r\n- I do want to check whether there's a list of levels of multiplexing in the draft, because that would be helpful, but \r\n- I want even more to make sure there's a list, where we can put a reference to the World Turtle. :grinning:",
          "createdAt": "2023-05-16T13:02:59Z",
          "updatedAt": "2023-05-16T13:02:59Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "There is [RFC 8872](https://datatracker.ietf.org/doc/html/rfc8872), which might help. We'd also need to reference the multiplexing section where the flow ID is explained. And maybe we should add a reference to 8872 in that section...",
          "createdAt": "2023-05-16T13:28:12Z",
          "updatedAt": "2023-05-16T13:28:12Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I just noticed this text in 8.2: \r\n\r\n> Disable Congestion Controller: If congestion control is to be implemented at the application layer as described in Section 7.2, and the application layer is trusted to apply adequate congestion control as described in Section 7 of [RFC9002] and Section 3.1 of [RFC8085], **it is RECOMMENDED to allow the application to disable QUIC layer congestion control entirely.**\r\n\r\nI need to remove this mention of disabling QUIC layer congestion control before we merge the PR. ",
          "createdAt": "2023-05-16T15:59:26Z",
          "updatedAt": "2023-05-16T15:59:26Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We'll add this reference and RFC 8872 in another PR. \r\n\r\n> I would expect the datagrams of the different channels to use different flow identifiers unless you send them in the same RTP session, which would require some other form of multiplexing, e.g., [RFC 8860](https://www.rfc-editor.org/rfc/rfc8860). The multiplexing section allows both, so we could use the flow identifier to disambiguate the datagrams, but we could also use the same identifier for more than one channel as long as we can still demultiplex them on the receiver side.\r\n\r\n",
          "createdAt": "2023-05-16T16:50:26Z",
          "updatedAt": "2023-05-16T16:50:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5UrUXN",
          "commit": {
            "abbreviatedOid": "9f1bec5"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-10T13:25:29Z",
          "updatedAt": "2023-05-10T13:28:36Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "If this is a normative reference, would it be helpful to reference NADA or SCReAM instead of the GC draft?",
              "createdAt": "2023-05-10T13:25:29Z",
              "updatedAt": "2023-05-10T13:28:36Z"
            },
            {
              "originalPosition": 92,
              "body": "`mazimizing` -> `maximizing`",
              "createdAt": "2023-05-10T13:28:22Z",
              "updatedAt": "2023-05-10T13:28:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5UuzxQ",
          "commit": {
            "abbreviatedOid": "9f1bec5"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T00:56:07Z",
          "updatedAt": "2023-05-11T00:56:07Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "This is a reasonable question. I think the answer is that GCC targets transport protocols that are not aware that they are carrying media, while NADA and SCReAM target RTP applications that are aware they are performing rate adaptation for media, so the thing to do in this transport protocol section, is to cite GCC.\r\n\r\nDoes that make sense?",
              "createdAt": "2023-05-11T00:56:07Z",
              "updatedAt": "2023-05-11T00:56:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5UwVRV",
          "commit": {
            "abbreviatedOid": "519846f"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T07:48:52Z",
          "updatedAt": "2023-05-11T07:48:53Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "To me, all three seem to target RTP applications, and the GCC draft references multiple RTP header extensions and RTCP feedback messages which were explicitly designed for GCC.\r\n\r\nAnother alternative to mention could be BBR. However, I don't know if that is a good recommendation for media. I think it has been mentioned somewhere that BBRs probing phases are problematic for real-time media.\r\n\r\nBBR also (still?) seems to be a draft, so we might not want to use it as a normative reference, either. I think we have this problem with other references, too, but I'd like to avoid adding more normative references to draft documents if possible (at least if the documents are expired and don't seem to be actively developed any longer). Regardless of which algorithm we reference here, does the reference have to be normative?",
              "createdAt": "2023-05-11T07:48:52Z",
              "updatedAt": "2023-05-11T07:48:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5U1UW3",
          "commit": {
            "abbreviatedOid": "9f1bec5"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T19:06:25Z",
          "updatedAt": "2023-05-11T19:06:25Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "@mengelbart - I'm replying here, just to preserve our helpful discussion which was also happening in Slack. Here's what I've got, point by point. \r\n\r\n> To me, all three seem to target RTP applications, and the GCC draft references multiple RTP header extensions and RTCP feedback messages which were explicitly designed for GCC.\r\n\r\nI think we're struggling a bit, because the draft is not internally consistent (yet) - for example, if we are writing a specification that assumes QUIC implementations know that our packets are media (perhaps because the connection uses rtp-mux-quic as its ALPN, rather than h3, or some other non-media ALPN), that's different from assuming that QUIC implementations don't know that our packets are media, and have to use a congestion controller-rate adapter that works for any packets, without special knowledge. \r\n\r\nAs I said in SLACK, if we CAN have real-time and non-real-time packets in the same QUIC connection, that has different implications. So, we need to be looking for inconsistencies. \r\n\r\n> Another alternative to mention could be BBR. However, I don't know if that is a good recommendation for media. I think it has been mentioned somewhere that BBRs probing phases are problematic for real-time media.\r\n\r\nYes, exactly. The idea is that any probing congestion controller probes by sending \"more data than it did the last RTT\", until it detects increasing delay, or actual packet loss. If the media congestion controller doesn't need to probe for bandwidth, or doesn't do that often, the media traffic won't experience increasing delays or packet loss. \r\n\r\n> BBR also (still?) seems to be a draft, so we might not want to use it as a normative reference, either. I think we have this problem with other references, too, but I'd like to avoid adding more normative references to draft documents if possible (at least if the documents are expired and don't seem to be actively developed any longer). Regardless of which algorithm we reference here, does the reference have to be normative?\r\n\r\nRight. So the point for normative references is that people must have access to them, to implement YOUR specification. What I THINK we are doing, is to say \"use a media-centric rate adaptation mechanism, and here are three that could meet your needs\". IMO, all three of these are informational, not normative (because you don't have to read any of them, you just need to understand what makes a rate adaptation mechanism media-centric). \r\n\r\nIf you think it would help, we can add [RFC 8836 Congestion Control Requirements for Interactive Real-Time Media](https://www.rfc-editor.org/rfc/rfc8836.html). I'm still not convinced that would be normative, but it might be helpful to the reader. \r\n\r\nGot any thoughts about any of this? I'll be typing, but I'm happy to be corrected, especially while I haven't merged any of this into Main yet!\r\n",
              "createdAt": "2023-05-11T19:06:25Z",
              "updatedAt": "2023-05-11T19:06:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5U1exg",
          "commit": {
            "abbreviatedOid": "9f1bec5"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-11T19:38:19Z",
          "updatedAt": "2023-05-11T19:38:19Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "That all makes sense. \r\n\r\n> I think we're struggling a bit, because the draft is not internally consistent (yet) - for example, if we are writing a specification that assumes QUIC implementations know that our packets are media (perhaps because the connection uses rtp-mux-quic as its ALPN, rather than h3, or some other non-media ALPN), that's different from assuming that QUIC implementations don't know that our packets are media, and have to use a congestion controller-rate adapter that works for any packets, without special knowledge.\r\n\r\nI think that's why we use `RECOMMEND` above. We don't know if the QUIC stack is aware of what is being sent over it and if the application has any control over the congestion control used in the QUIC stack. If the app is in control, we know what is being sent and can decide to use real-time CC. We can't do much if neither the app can choose a congestion controller nor the QUIC stack knows about the payload.\r\n\r\n> As I said in SLACK, if we CAN have real-time and non-real-time packets in the same QUIC connection, that has different implications. So, we need to be looking for inconsistencies.\r\n\r\nAgree. I think we should add more clarification to section 7.4 about the implications for congestion control when sharing a connection between real-time and non-real-time streams.\r\n\r\n> IMO, all three of these are informational, not normative (because you don't have to read any of them, you just need to understand what makes a rate adaptation mechanism media-centric).\r\n\r\nHaving an informational reference to any of the three algorithms should be fine, I think :) And adding a reference to RFC 8836 also sounds helpful. ",
              "createdAt": "2023-05-11T19:38:19Z",
              "updatedAt": "2023-05-11T19:38:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDOFUmh7s5QXrjy",
      "title": "Add considerations for STOP\\_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/88",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-12T09:31:23Z",
      "updatedAt": "2023-05-18T09:02:53Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "8dbb4db2bb1c951a00b4bb871ff94d2f809c7022",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/45/stop-sending",
      "headRefOid": "47913e23d69c6a1f3a19905ce5ff16ad631fe884",
      "closedAt": "2023-05-18T09:02:52Z",
      "mergedAt": "2023-05-18T09:02:52Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "9890c6fca2fd1ebea225c3f0127381007ccf532a"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "close #45 ",
          "createdAt": "2023-05-12T09:50:56Z",
          "updatedAt": "2023-05-12T09:52:04Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> The sending RTP application SHOULD not interpret the reception of STOP_SENDING as an indication that the receiver lost interest in the media stream as a whole, but rather that a part of the media stream was not received timely and some recovery is probably necessary.\r\n\r\nSounds good. I will change it.\r\n\r\n> I was confused here. Is this saying the (sending RTP application) MUST NOT retransmit media frames on the new stream, or MUST NOT retransmit QUIC frames on the new stream?\r\n\r\nThis should be media frames, I will add it to clarify. \r\n\r\n> Do we have a complete list of QUIC extension RFCs and drafts we think might be useful in ROQ? That would be a fine thing to add.\r\n\r\nThat is a good idea, I opened #92 ",
          "createdAt": "2023-05-16T15:26:44Z",
          "updatedAt": "2023-05-16T15:26:44Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I am not sure I understand your comment here:\r\n\r\n> I think (but could be wrong) that we are complicating our work by saying \"this is how ROQ works\", and then having to clarify that \"this is a QUIC streams thing (like STOP_SENDING), and the rules are different if you're using QUIC datagrams (as below), and (of course) it's legal for ROQ endpoints to use both\".\r\n> \r\n> But that's a question for another issue. On this issue ...\r\n\r\nWould you mind opening that issue?",
          "createdAt": "2023-05-16T15:29:18Z",
          "updatedAt": "2023-05-16T15:29:18Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Preferring \"RTP sender\", rather than \"sender\". ",
          "createdAt": "2023-05-16T16:19:51Z",
          "updatedAt": "2023-05-16T16:19:51Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am not sure I understand your comment here:\r\n> \r\n>> I think (but could be wrong) that we are complicating our work by saying \"this is how ROQ works\", and then having to clarify that \"this is a QUIC streams thing (like STOP_SENDING), and the rules are different if you're using QUIC datagrams (as below), and (of course) it's legal for ROQ endpoints to use both\".\r\n>>\r\n>> But that's a question for another issue. On this issue ...\r\n>\r\n> Would you mind opening that issue?\r\n\r\nLet's wait to think about this some more, but I'll open an issue for it when it becomes an issue. :grinning:",
          "createdAt": "2023-05-16T16:37:28Z",
          "updatedAt": "2023-05-16T16:37:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5VJ0n0",
          "commit": {
            "abbreviatedOid": "6dd350a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for working through the comments about this. \r\n\r\nI think (but could be wrong) that we are complicating our work by saying \"this is how ROQ works\", and then having to clarify that \"this is a QUIC streams thing (like STOP\\_SENDING), and the rules are different if you're using QUIC datagrams (as below), and (of course) it's legal for ROQ endpoints to use both\". \r\n\r\nBut that's a question for another issue. On **this issue** ... \r\n\r\n> QUIC allows an application to abort reading the stream and specify an error code\r\n> {{Section 3.5 of !RFC9000}}. The QUIC transport can signal this to the sending\r\n> side by sending a STOP\\_SENDING frame. The sender SHOULD not interpret the\r\n> reception of STOP\\_SENDING as an indication that the receiver lost interest in\r\n> the media stream as a whole, but rather that a part of the media stream was not\r\n> received timely and some recovery is necessary. \r\n\r\nHmmm. Is this a normative requirement on QUIC, beyond RFC 9000/RFC 9221? I think we might express this better as \r\n\r\nThe **sending RTP application** SHOULD not interpret the reception of STOP\\_SENDING as an indication that the receiver lost interest in the media stream as a whole, but rather that a part of the media stream was not received timely and some recovery **is probably** necessary.\r\n\r\n> The recovery may be supported by\r\n> dropping some parts of the media stream entirely and restarting to send new\r\n> media frames on new QUIC streams. While STOP\\_SENDING includes an error code, it\r\n> does not allow the receiving side to inform the sender where exactly it wishes\r\n> to restart receiving media. A sender that receives STOP\\_SENDING MUST NOT\r\n> transmit any frames already sent on the QUIC stream, on which STOP\\_SENDING was\r\n> received, on a new QUIC stream. \r\n\r\nI was confused here. Is this saying the (sending RTP application) MUST NOT retransmit **media** frames on the new stream, or MUST NOT retransmit QUIC frames on the new stream?\r\n\r\n> A sender SHOULD instead continue to send media\r\n> frames on new QUIC streams starting with the first frame that was not\r\n> transmitted on the stream that received STOP\\_SENDING.\r\n\r\nSkipping down to \r\n\r\n> **Editor's note:** A receiver cannot cancel a certain frame but still receive\r\n> retransmissions for a frame the was following on the same stream using\r\n> STOP\\_SENDING, because STOP\\_SENDING does not include an offset which would\r\n> allow signaling where retransmissions should continue. If this is a required\r\n> feature for RoQ, it could be implemented using an extended STOP\\_SENDING frame\r\n> as, for example, proposed in {{?I-D.draft-thomson-quic-enough-00}}\r\n\r\nDo we have a complete list of QUIC extension RFCs and drafts we think might be useful in ROQ? That would be a fine thing to add. ",
          "createdAt": "2023-05-16T13:51:21Z",
          "updatedAt": "2023-05-16T13:51:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 89,
      "id": "PR_kwDOFUmh7s5QZkdU",
      "title": "Add example for MAX_STREAMS and hint for signaling",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/89",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-12T15:41:55Z",
      "updatedAt": "2023-05-18T09:03:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0f0023698f38b71e15fdc964c87a9cf58c5407d8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/49/max-streams",
      "headRefOid": "6d1afac99e3b4ca70a916b5490f7db2f535b3f22",
      "closedAt": "2023-05-18T09:03:03Z",
      "mergedAt": "2023-05-18T09:03:03Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "6a957b4d1a504a3d647e30cb9948748c4ae37f56"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 90,
      "id": "PR_kwDOFUmh7s5Qf_Yy",
      "title": "Remove obsolete discussion about flow IDs",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/90",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Multiplexing was discussed at an interim meeting in december 2022 and on the mailing list and an extended section explaining multiplexing using flow IDs was added in PR #54.",
      "createdAt": "2023-05-15T10:49:36Z",
      "updatedAt": "2023-05-16T16:12:20Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0f0023698f38b71e15fdc964c87a9cf58c5407d8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/remove-flow-id-discussion",
      "headRefOid": "0b5c35d96982c643818ba2dc18c161dafa2eee8c",
      "closedAt": "2023-05-16T16:12:19Z",
      "mergedAt": "2023-05-16T16:12:19Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "ce5bf21aa30f3790040352c3e84942c199bc1780"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 91,
      "id": "PR_kwDOFUmh7s5QnZQg",
      "title": "Define error codes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/91",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Actual codes are still missing to avoid redefining them multiple times if we add more codes.",
      "createdAt": "2023-05-16T13:19:57Z",
      "updatedAt": "2023-07-31T14:29:43Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "9dc75df5291583c21308ddf97051e7f34144773b",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/76/error-codes",
      "headRefOid": "4c555030ab436e1f0a5f2b8a4ff134b041dd97bb",
      "closedAt": "2023-07-31T14:29:42Z",
      "mergedAt": "2023-07-31T14:29:42Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "17eaa8bf67885375ca62118cfe76d46ba0bdd785"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR has a starting point - next steps are \r\n\r\n- present to WG and ask for comments\r\n- add error codes to relevant sections of the draft",
          "createdAt": "2023-05-16T16:57:33Z",
          "updatedAt": "2023-05-16T16:57:33Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I added text to the rest of the draft to explain which error codes should be used. Some error codes are not yet mentioned in the text, and I am not sure if we really need them:\r\n\r\n* ROQ_GENERAL_PROTOCOL_ERROR\r\n* ROQ_INTERNAL_ERROR\r\n* ROQ_PACKET_ERROR\r\n\r\nIt may be enough to have one of them, or it may be helpful to have the option to be more specific.\r\n\r\n(The PR is now based on #98 and should only be merged after that PR is merged, too)",
          "createdAt": "2023-07-03T12:28:48Z",
          "updatedAt": "2023-07-03T12:28:48Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "@LPardue and I agreed on merging this PR first and then defining IANA procedures and real error codes in a follow-up PR.",
          "createdAt": "2023-07-31T14:16:39Z",
          "updatedAt": "2023-07-31T14:16:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5b66HI",
          "commit": {
            "abbreviatedOid": "aef3eff"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice work! I apologize for the number of comments ...",
          "createdAt": "2023-07-23T00:36:18Z",
          "updatedAt": "2023-07-23T01:58:49Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I know we talked about this before, but I'm now thinking more clearly. \r\n\r\n> When a RoQ sender receives a STOP\\_SENDING frame, the RoQ sender MUST open one \r\n> or more new QUIC streams to send new media frames. \r\n\r\nTo be pedantic, this is probably \r\n\r\n> When a RoQ sender receives a STOP\\_SENDING frame, the RoQ sender MUST open one\r\n> or more new QUIC streams **before sending** new media frames. ",
              "createdAt": "2023-07-23T00:36:18Z",
              "updatedAt": "2023-07-23T01:58:49Z"
            },
            {
              "originalPosition": 65,
              "body": "Hmmm. RFC 9000 says this:\r\n\r\n> An endpoint MUST treat the receipt of a frame of unknown type as a connection error of type FRAME_ENCODING_ERROR.\r\n\r\nWe just had a conversation about whether a \"frame of known type defined for an extension that has not been negotiated\" would be treated as \"a frame of unknown type\" or some other kind of error, but the high order bit is that I don't think the RTP receiver will ever see that datagram - the QUIC receiver will have already punted it as a connection error. ",
              "createdAt": "2023-07-23T01:08:40Z",
              "updatedAt": "2023-07-23T01:58:49Z"
            },
            {
              "originalPosition": 81,
              "body": "I think this is \"Either peer MAY close the connection for a variety of reasons.\"",
              "createdAt": "2023-07-23T01:11:18Z",
              "updatedAt": "2023-07-23T01:58:49Z"
            },
            {
              "originalPosition": 113,
              "body": "> : A receiving endpoint stopped reading a frame from a stream and requests new\r\n> frames be sent on new streams using STOP\\_SENDING \r\n\r\nI think that's technically correct, but if the following is also correct, it might be clearer. \r\n\r\n> : A receiving endpoint is using STOP\\_SENDING on the current stream to request new\r\n> frames be sent on new streams. ",
              "createdAt": "2023-07-23T01:18:15Z",
              "updatedAt": "2023-07-23T01:58:49Z"
            },
            {
              "originalPosition": 119,
              "body": "Perhaps \r\n\r\n> : An endpoint was unable to handle a flow identifier, e.g., because it was not\r\n> signalled or **because the endpoint** does not support multiplexing using arbitrary flow identifiers.",
              "createdAt": "2023-07-23T01:20:26Z",
              "updatedAt": "2023-07-23T01:58:49Z"
            },
            {
              "originalPosition": 125,
              "body": ":exploding_head: I'm lost on this one. Does \r\n\r\n> the connection properties that were negotiated when the connection was\r\n> established using transport parameters.\r\n\r\nrefer to QUIC transport parameters? If so, it would be good to say that, but we are using \"parameters\" to refer to ROC parameters, so I'm not sure what's being described. \r\n\r\nPlease advise. ",
              "createdAt": "2023-07-23T01:28:44Z",
              "updatedAt": "2023-07-23T01:58:49Z"
            },
            {
              "originalPosition": 109,
              "body": "The use of this error code in the document, in \r\n\r\n> To send RTP/RTCP packets over QUIC streams, a sender MUST open a\r\n> new unidirectional QUIC stream. Streams are unidirectional because there is no\r\n> synchronous relationship between sent and received RTP/RTCP packets. A peer that\r\n> receives a bidirectional stream with a flow identifier that is associated with\r\n> an RTP or RTCP stream, SHOULD stop reading from the stream and send a\r\n> STOP\\_SENDING frame with the application protocol error code set to\r\n> ROQ\\_STREAM\\_CREATION\\_ERROR.\r\n\r\ndescribes this situation as a fundamental protocol violation. I read \r\n\r\n> ROQ\\_STREAM\\_CREATION\\_ERROR (0x????):\r\n> : The endpoint detected that its peer created a stream that **it will not accept.**\r\n\r\nas more of a decision by the endpoint, rather than what the endpoint does to conform to the protocol specification. \r\n\r\nMaybe something like \r\n\r\n> ROQ\\_STREAM\\_CREATION\\_ERROR (0x????):\r\n> : The endpoint detected that its peer created a stream that **violates the ROQ protocol.**",
              "createdAt": "2023-07-23T01:54:21Z",
              "updatedAt": "2023-07-23T01:58:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5b68lE",
          "commit": {
            "abbreviatedOid": "aef3eff"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-23T03:21:26Z",
          "updatedAt": "2023-07-23T03:21:26Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "That makes sense, but I will change this in #106 because it also changes this sentence.",
              "createdAt": "2023-07-23T03:21:26Z",
              "updatedAt": "2023-07-23T03:21:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5b68q8",
          "commit": {
            "abbreviatedOid": "aef3eff"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-23T03:29:42Z",
          "updatedAt": "2023-07-23T03:29:42Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "I think we are talking about two different error cases. One problem is a peer sending a datagram frame in a connection that did not negotiate the use of QUIC datagrams. In that case, I agree that the QUIC receiver will react first, and the RTP receiver will never know about it. The case I intended to cover is that the two peers used some out-of-band signaling before setting up the QUIC connection, and in that signaling, they agreed to use QUIC datagrams, but then during the QUIC handshake, one of the peers does not send the transport parameter to negotiate datagrams. In that QUIC connection, datagrams are not allowed, so the peer that was expecting to be allowed to use datagrams can immediately close the connection. ",
              "createdAt": "2023-07-23T03:29:42Z",
              "updatedAt": "2023-07-23T03:29:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5b68wp",
          "commit": {
            "abbreviatedOid": "aef3eff"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-23T03:37:54Z",
          "updatedAt": "2023-07-23T03:37:55Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Yes, it refers to QUIC transport parameters. This was meant for the case I mentioned in a comment above, where peers agree on using QUIC datagrams out-of-band, but then one of them does not allow datagrams during the QUIC handshake. In that case, the other peer might like to say: \"Hey, we agreed on using datagrams, but now you don't allow me to use them so I just close the connection with a ROQ_SIGNALING_ERROR\". Does it help to say \"... established using QUIC transport parameters\"?",
              "createdAt": "2023-07-23T03:37:54Z",
              "updatedAt": "2023-07-23T03:37:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5cDpi1",
          "commit": {
            "abbreviatedOid": "9c22bf1"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-25T00:37:53Z",
          "updatedAt": "2023-07-25T00:37:54Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "@mengelbart's explanation makes sense to me",
              "createdAt": "2023-07-25T00:37:53Z",
              "updatedAt": "2023-07-25T00:37:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5cDqIT",
          "commit": {
            "abbreviatedOid": "9c22bf1"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-25T00:42:29Z",
          "updatedAt": "2023-07-25T00:42:29Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "It might help to rename the error to be like \"ROQ_REQUIREMENT_UNMET\" or \"ROQ_EXPECTATION_UNMET\" that would more clearly articulate the intent. I'd then change the text to say something like\r\n\r\n> Expectiations of the QUIC transport set by RoQ out-of-band signalling were not met by the QUIC connection.",
              "createdAt": "2023-07-25T00:42:29Z",
              "updatedAt": "2023-07-25T00:42:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5cDrLo",
          "commit": {
            "abbreviatedOid": "9c22bf1"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "This is all going in the correct direction. However some things need tweaking before you merge:\r\n\r\n* Define a new RoQ Error Code IANA registry e.g. like HTTP/3's https://www.iana.org/assignments/http3-parameters/http3-parameters.xhtml#http3-parameters-error-codes. Note that this will need to have registration procedures and you'll want to consider about greasing the code point space\r\n\r\n* Pick real values for the error codes. This is harder when you're not done and those errors might need to change. One technique is to pick values in the upper code space and then prior to publication switch them to lower values. But that might risk more churn than is really worth it.",
          "createdAt": "2023-07-25T00:50:20Z",
          "updatedAt": "2023-07-25T00:50:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDOFUmh7s5Q0CDI",
      "title": "Moving RTCP replacement section below congestion control section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/94",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #82 \r\n\r\nI still wonder about moving the streams and datagrams subsections of what is now Section 7 out - they may have more to do with congestion control than replacing RTCP feedback. But we can merge this one, and then talk about additional editing that may be required. ",
      "createdAt": "2023-05-18T14:33:30Z",
      "updatedAt": "2023-05-18T18:33:30Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "6a957b4d1a504a3d647e30cb9948748c4ae37f56",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-82",
      "headRefOid": "9a457a1684744520fb055b10660f9bda71df20bd",
      "closedAt": "2023-05-18T18:33:29Z",
      "mergedAt": "2023-05-18T18:33:29Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5VbbBM",
          "commit": {
            "abbreviatedOid": "9a457a1"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-18T18:33:24Z",
          "updatedAt": "2023-05-18T18:33:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 96,
      "id": "PR_kwDOFUmh7s5Q_R3C",
      "title": "Fix normative language about STOP_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/96",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-22T08:12:43Z",
      "updatedAt": "2023-07-18T13:54:33Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/normative-language-stop-sending",
      "headRefOid": "2412b01b874d39560a4a519ae94250def296672c",
      "closedAt": "2023-07-10T16:38:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart is working on PR #98 which should replace this PR when it is merged. \r\n\r\nWe're not working on this PR further, so please look at #98 instead. ",
          "createdAt": "2023-06-16T15:14:35Z",
          "updatedAt": "2023-06-16T15:14:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5Vo1eP",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T14:28:50Z",
          "updatedAt": "2023-05-22T15:56:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I know this seems ridiculous, but \"SHOULD\" and \"SHOULD NOT\" are defined terms in BCP14, and \"SHOULD not\" is not. Although \"SHOULD not\" would be clear to many readers, it's not actual requirements language. :innocent:",
              "createdAt": "2023-05-22T14:28:50Z",
              "updatedAt": "2023-05-22T15:56:58Z"
            },
            {
              "originalPosition": 20,
              "body": "This might be clearer as two sentences: \r\n\r\n\"In\r\nthis case, the late data could also delay **any** following media frames due to\r\nhead-of-line blocking **within a single QUIC stream**. The **RTP** sender can avoid these delays by transmitting new media\r\nframes on new QUIC streams.\" \r\n\r\nI put what seemed like significant changes in bold, so you could spot them more easily. Please let me know if I misunderstand your intended meaning. ",
              "createdAt": "2023-05-22T14:46:02Z",
              "updatedAt": "2023-05-22T15:56:58Z"
            },
            {
              "originalPosition": 22,
              "body": "I made this more complicated than it needed to be. See if this is easier to understand. \r\n\r\n\"A QUIC sender that receives STOP\\_SENDING on a QUIC stream MUST NOT\r\nretransmit any media frames already sent on that QUIC stream, on any QUIC stream.\"",
              "createdAt": "2023-05-22T15:03:05Z",
              "updatedAt": "2023-05-22T15:56:58Z"
            },
            {
              "originalPosition": 17,
              "body": "OK, this is super awkward. I think we've gotten confused about the difference between what a **QUIC receiver** thinks it means when it sends \"STOP\\_SENDING\", and what an **RTP receiver** thinks it means. \r\n\r\nFrom [RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000#name-solicited-state-transitions): \r\n\r\n> If the stream is in the \"Recv\" or \"Size Known\" state, the transport SHOULD signal this by sending a STOP_SENDING frame to prompt closure of the stream in the opposite direction. This typically indicates that the receiving application is no longer reading data it receives from the stream, but it is not a guarantee that incoming data will be ignored.\r\n\r\nSo, it looks like the application HAS lost interest - because the media frames are arriving late enough that they are not useful. The application is sending \"STOP\\_SENDING\" to trigger an automatic \"RESET\\_STREAM\".\r\n\r\nWhat's confusing, is that the **RTP receiver** - the application - hasn't lost interest in the **media** - it's lost interest in **getting outdated and unusable media frames.** The RTP receiver wants the RTP sender to start over, with the most current media frames, on a stream that doesn't already hold additional outdated frames. \r\n\r\nDoes that make sense?\r\n\r\nAssuming so, the text in this part of the document should reflect that distinction. ",
              "createdAt": "2023-05-22T15:27:06Z",
              "updatedAt": "2023-05-22T15:56:58Z"
            },
            {
              "originalPosition": 25,
              "body": "Are we mandating that RTP senders open a new stream and continue sending? \r\n\r\nIf we are, and a RTP receiver really has stopped caring about this RTP stream, how does it \"turn the RTP sender off\"? \r\n\r\nI think we're basically telling a RTP receiver that wants to \"skip forward to usable media frames\", to transmit a \"STOP\\_SENDING\" frame, triggering a \"STREAM_RESET\", and then to carry out another SDP exchange so the RTP sender **knows** that it should continue by sending the newest media frames on a new QUIC stream.\r\n\r\nDo you see another way to ensure that the Right Thing happens?\r\n\r\nDoes that make sense?",
              "createdAt": "2023-05-22T15:55:14Z",
              "updatedAt": "2023-05-22T15:56:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5VqAdZ",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T17:08:36Z",
          "updatedAt": "2023-05-22T17:08:37Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Yes, that sounds correct.",
              "createdAt": "2023-05-22T17:08:36Z",
              "updatedAt": "2023-05-22T17:08:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5VqGD6",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T17:22:02Z",
          "updatedAt": "2023-05-22T17:22:02Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "> Are we mandating that RTP senders open a new stream and continue sending?\r\n\r\nYes, I think that is what we should do.\r\n\r\n> If we are, and a RTP receiver really has stopped caring about this RTP stream, how does it \"turn the RTP sender off\"?\r\n\r\nI don't think using STOP_SENDING is the right tool for this. Instead, it would probably require some signaling.\r\n\r\n> I think we're basically telling a RTP receiver that wants to \"skip forward to usable media frames\", to transmit a \"STOP_SENDING\" frame, triggering a \"STREAM_RESET\", and then to carry out another SDP exchange so the RTP sender **knows** that it should continue by sending the newest media frames on a new QUIC stream.\r\n>\r\n> Do you see another way to ensure that the Right Thing happens?\r\n\r\nI don't understand why we would carry out another SDP exchange here. The sender should take STOP_SENDING as a signal that the receiver is still interested in the media stream in general, but wants to start over with new media frames on new QUIC streams.",
              "createdAt": "2023-05-22T17:22:02Z",
              "updatedAt": "2023-05-22T17:22:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5VqK2b",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T17:32:42Z",
          "updatedAt": "2023-05-22T17:32:43Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think we don't need any requirements language here, do we?",
              "createdAt": "2023-05-22T17:32:42Z",
              "updatedAt": "2023-05-22T17:32:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5VqLbd",
          "commit": {
            "abbreviatedOid": "2412b01"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-22T17:33:19Z",
          "updatedAt": "2023-05-22T17:33:19Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Sounds good!",
              "createdAt": "2023-05-22T17:33:19Z",
              "updatedAt": "2023-05-22T17:33:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDOFUmh7s5TMUqU",
      "title": "Fix reference to variable length integer encoding",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/97",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-16T13:36:39Z",
      "updatedAt": "2023-07-10T16:39:01Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/varint-reference",
      "headRefOid": "62f13d83c65a40377f6e525df79ae6e22d52d5a2",
      "closedAt": "2023-07-10T16:39:00Z",
      "mergedAt": "2023-07-10T16:39:00Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "f09a2b523932612817fe08821d7cc09dd55e5d67"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 98,
      "id": "PR_kwDOFUmh7s5TMiWM",
      "title": "Clarify behaviour of STOP_SENDING and RESET_STREAM",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/98",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Second attempt to clarify the behaviour of STOP_SENDING and RESET_STREAM. I hope this is easier to understand than the current text and #96. It also adds subsections to add more structure to the whole subsection.",
      "createdAt": "2023-06-16T14:10:21Z",
      "updatedAt": "2023-07-10T16:29:21Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/stop-sending-2",
      "headRefOid": "4dd4ef703836c64cdfd2769db8c91be6e3111aaf",
      "closedAt": "2023-07-10T16:29:20Z",
      "mergedAt": "2023-07-10T16:29:20Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "800fd223a9fa4daa5048bfa3ae6c1ad45e1817c0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5auVUy",
          "commit": {
            "abbreviatedOid": "4dd4ef7"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I sent some comments via email, but I think the current text is close enough to merge for IETF 117.",
          "createdAt": "2023-07-10T13:29:31Z",
          "updatedAt": "2023-07-10T13:29:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDOFUmh7s5UhgmP",
      "title": "Add green metadata to RTCP considerations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/99",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "fix #79 ",
      "createdAt": "2023-07-03T12:55:23Z",
      "updatedAt": "2023-07-23T20:44:49Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/79-green-metadata-rtcp",
      "headRefOid": "f610b7cf1e3510204321409a1dd6a857c7f5ef15",
      "closedAt": "2023-07-23T20:44:49Z",
      "mergedAt": "2023-07-23T20:44:49Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "5dabd5d69037e6239c2a0d3bd0ca6643f299dbdc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 100,
      "id": "PR_kwDOFUmh7s5UiUz6",
      "title": "Add a list of considered header extensions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/100",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #95 ",
      "createdAt": "2023-07-03T15:09:41Z",
      "updatedAt": "2023-07-23T23:03:44Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "aa288626a71f637a3ec8ab7863a3340c6b8578a5",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/95-rtp-header-extensions",
      "headRefOid": "0439b9ed19d00cf9d0f5c4943a3ddea6c66d3ac0",
      "closedAt": "2023-07-23T23:03:43Z",
      "mergedAt": "2023-07-23T23:03:43Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "9dc75df5291583c21308ddf97051e7f34144773b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 101,
      "id": "PR_kwDOFUmh7s5Uiejl",
      "title": "Add an appendix to list optional QUIC extensions",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/101",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #92 ",
      "createdAt": "2023-07-03T15:33:40Z",
      "updatedAt": "2023-07-23T20:53:13Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/92-list-quic-extensions",
      "headRefOid": "253f0f68ad116dcfce8d721b6b2b36b1d19c67bf",
      "closedAt": "2023-07-23T20:53:12Z",
      "mergedAt": "2023-07-23T20:53:12Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "c1b269a91e6e18d27e69aedfaed1c77a9fc72cd6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 102,
      "id": "PR_kwDOFUmh7s5Ul4NN",
      "title": "Add considerations for aggregating frames",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/102",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #85 ",
      "createdAt": "2023-07-04T08:30:32Z",
      "updatedAt": "2023-07-10T16:29:52Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/85-frame-aggregation",
      "headRefOid": "117bf7d0ce7f21b576db5fd71a341bdcdd2ba858",
      "closedAt": "2023-07-10T16:29:51Z",
      "mergedAt": "2023-07-10T16:29:51Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "5ee2df7bae1af902318cd3caf76db6b502ba820c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5aMVK8",
          "commit": {
            "abbreviatedOid": "117bf7d"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-04T16:32:10Z",
          "updatedAt": "2023-07-04T16:32:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDOFUmh7s5VFxsc",
      "title": "Add @spencerdawkins as third author",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/105",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Just FYI, it's fine with me (and perhaps preferable for @adoba and @JonathanLennox, since WG chairs are responsible for assigning authors/editors to working group drafts) if you wait to merge this PR, and we present it as an open issue at IETF 117. \r\n\r\nBut at least it's in the repo now. \r\n\r\nclose #104 ",
      "createdAt": "2023-07-10T13:51:11Z",
      "updatedAt": "2023-07-10T19:45:59Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "1e00eecd41353312fd66ab66b2536bc377d0d5c3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-104",
      "headRefOid": "e69f5ffdf1d45f579773262f335567f28085d6d9",
      "closedAt": "2023-07-10T19:42:08Z",
      "mergedAt": "2023-07-10T19:42:08Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "46c8dc0bfa9f60564a6717977c10c94687337ebd"
      },
      "comments": [
        {
          "author": "JonathanLennox",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As chair, I'm happy to have Spencer be a co-author of this draft.",
          "createdAt": "2023-07-10T17:43:12Z",
          "updatedAt": "2023-07-10T17:43:12Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thanks, @JonathanLennox , I submitted another version, including this PR :)",
          "createdAt": "2023-07-10T19:45:58Z",
          "updatedAt": "2023-07-10T19:45:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5av5er",
          "commit": {
            "abbreviatedOid": "e69f5ff"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-10T16:28:57Z",
          "updatedAt": "2023-07-10T16:28:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "PR_kwDOFUmh7s5VGzgr",
      "title": "Add proposal from e-mail discussion",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/106",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-10T16:37:26Z",
      "updatedAt": "2023-07-23T20:56:39Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "open-new-stream-after-stop-sending",
      "headRefOid": "069d01a8edcaf07b6b058c2abed9d646cf068feb",
      "closedAt": "2023-07-23T20:56:38Z",
      "mergedAt": "2023-07-23T20:56:38Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "e5b77f3cc371f9a6e6e3afa3dad395ee03b388ec"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 108,
      "id": "PR_kwDOFUmh7s5Vzakn",
      "title": "Add references to close stream and enough drafts",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/108",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Add references and a paragraph to explain how the CLOSE_STREAM and ENOUGH frames could be used.\r\n\r\nClose #103 ",
      "createdAt": "2023-07-18T16:07:30Z",
      "updatedAt": "2023-07-23T23:01:18Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/103-close-stream-enough",
      "headRefOid": "9a849041eac94e2685c35034f637040f2a729c2b",
      "closedAt": "2023-07-23T23:01:17Z",
      "mergedAt": "2023-07-23T23:01:17Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d4e110464ecb592363d18d7064df24b2f26297c4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 109,
      "id": "PR_kwDOFUmh7s5V7Z0F",
      "title": "Add motivations section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/109",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "@mengelbart and @gchandok - I'm sure I'm leaving motivations out, so I'd appreciate your comments on this PR even more than usual!\r\n\r\ncloses #77 ",
      "createdAt": "2023-07-19T19:37:05Z",
      "updatedAt": "2023-07-23T21:35:46Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-77",
      "headRefOid": "49f76a05e20812b25c86e5abbb0b05ccc3f5bb99",
      "closedAt": "2023-07-23T21:35:45Z",
      "mergedAt": "2023-07-23T21:35:45Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "aa288626a71f637a3ec8ab7863a3340c6b8578a5"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Just FYI, I went back and thought about the motivations we had for QUIC when we chartered it for HTTP/3, and remembered that some of those motivations also apply for RTP. I also added cross-references to sections later in the document, to make me feel better about not including more details in the motivations themselves. \r\n\r\nShould I add a note that other people likely have other motivations in mind, and it would be great to add them?",
          "createdAt": "2023-07-23T00:24:22Z",
          "updatedAt": "2023-07-23T00:24:22Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 110,
      "id": "PR_kwDOFUmh7s5V7eyS",
      "title": "Clean up \"RTP-over-QUIC\" terminology",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/110",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "I also added \"(RoQ)\" to the document title, to make this easier to spot for readers. \r\n\r\nfixes #107 ",
      "createdAt": "2023-07-19T19:53:33Z",
      "updatedAt": "2023-07-23T21:01:51Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ee91e1f83f52a833a843aeda7cdbed06b4f7001d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-107",
      "headRefOid": "72e7c42677ce00d6fddf488792af04a96b976d59",
      "closedAt": "2023-07-23T21:01:51Z",
      "mergedAt": "2023-07-23T21:01:50Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d63930b23f69915675615a4e2fb5852da535de52"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5btYHc",
          "commit": {
            "abbreviatedOid": "72e7c42"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-20T07:33:23Z",
          "updatedAt": "2023-07-20T07:33:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 119,
      "id": "PR_kwDOFUmh7s5XwzNX",
      "title": "fix typo, UTP->UDP",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/119",
      "state": "MERGED",
      "author": "danwing",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-08-11T22:21:35Z",
      "updatedAt": "2023-08-12T07:30:58Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "17eaa8bf67885375ca62118cfe76d46ba0bdd785",
      "headRepository": "danwing/rtp-over-quic-draft",
      "headRefName": "typo",
      "headRefOid": "2360e33d2bf5666589e404f237b3a7f6ae9fca2d",
      "closedAt": "2023-08-12T07:30:58Z",
      "mergedAt": "2023-08-12T07:30:58Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "37090ca2ea9f361aee5cfdd7fcb2c001ca5f3751"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5d3u0y",
          "commit": {
            "abbreviatedOid": "2360e33"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks @danwing!",
          "createdAt": "2023-08-12T07:30:36Z",
          "updatedAt": "2023-08-12T07:30:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "PR_kwDOFUmh7s5ZCJuJ",
      "title": "Move RTCP tables to appendix and reference section 8",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/120",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-08-29T13:02:44Z",
      "updatedAt": "2023-09-22T07:46:09Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "feda06569c34b2f31c8acf72027bcd2491dbf274",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/80-rtcp-tables-appendix",
      "headRefOid": "029a37862c77ecd9a9c0105b240c76d68ba5bdcb",
      "closedAt": "2023-09-22T07:46:08Z",
      "mergedAt": "2023-09-22T07:46:08Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "40be8b623b2cead67158ec8584e732155057627a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5hSCOW",
          "commit": {
            "abbreviatedOid": "a18316a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-18T23:18:33Z",
          "updatedAt": "2023-09-19T12:55:18Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "> considered lost. {{Section 6.2.1. of !RFC4585}} recommends to use this feature\r\n> **only, if** the underlying protocol cannot provide similar feedback. QUIC does not\r\n\r\nI'd suggest \"only if\" here. ",
              "createdAt": "2023-09-18T23:18:33Z",
              "updatedAt": "2023-09-19T12:55:18Z"
            },
            {
              "originalPosition": 36,
              "body": "> Some of the standard\r\n> report blocks which can be implemented in extended reports can be implemented in\r\n> QUIC, too. \r\n\r\nI'm not sure if \"standard report blocks\" is the right term here. (\"Standard\" has so many meanings in IETF specifications!)\r\n\r\nIs this saying \r\n\r\n> Some of the statistics that are defined as extended report blocks can be derived from QUIC, too. ",
              "createdAt": "2023-09-18T23:29:33Z",
              "updatedAt": "2023-09-19T12:55:18Z"
            },
            {
              "originalPosition": 67,
              "body": "I'd suggest enclosing {{Section 6 of !RFC9002}} in parentheses, as \"({{Section 6 of !RFC9002}}).\"",
              "createdAt": "2023-09-18T23:32:33Z",
              "updatedAt": "2023-09-19T12:55:18Z"
            },
            {
              "originalPosition": 286,
              "body": "Two things for this text: \r\n\r\n> Several but not all of these control packets and their attributes can be mapped\r\n> from QUIC, as described in {{transport-layer-feedback}}. *Mappable from QUIC*\r\n> has one of three values: *yes*, *QUIC extension required*, and *no*.\r\n\r\nI THINK this paragraph applies to more subsections than **## RTCP Control Packet Types {#control-packets}**.\r\n\r\nAlso, I'm also seeing **partly** and **possibly** in this section, but I'm not seeing **QUIC extension required**.",
              "createdAt": "2023-09-19T12:53:12Z",
              "updatedAt": "2023-09-19T12:55:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5hdDz1",
          "commit": {
            "abbreviatedOid": "a18316a"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-20T08:26:28Z",
          "updatedAt": "2023-09-20T08:26:28Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "Thanks! I moved the paragraph to the section introduction so it applies to all the following subsections. I also replaced *QUIC extension required* with *possibly* and *partly*, including short explanations and updated the table values to match their respective descriptions.",
              "createdAt": "2023-09-20T08:26:28Z",
              "updatedAt": "2023-09-20T08:26:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 121,
      "id": "PR_kwDOFUmh7s5ZVCfe",
      "title": "Distinguish between adapting media stream contents and media stream \u2026",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/121",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "\u2026rate adaptation\r\n\r\nAlso corrected (I think) formats of multiple references to compact header extensions and SDES compact header extensions.\r\n\r\ncloses #116 ",
      "createdAt": "2023-09-01T11:09:42Z",
      "updatedAt": "2023-09-15T15:08:44Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "37090ca2ea9f361aee5cfdd7fcb2c001ca5f3751",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-116",
      "headRefOid": "88dd572ed45950637ebcf328700cc6c89045ce7a",
      "closedAt": "2023-09-15T15:08:43Z",
      "mergedAt": "2023-09-15T15:08:43Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "feda06569c34b2f31c8acf72027bcd2491dbf274"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5hE9jO",
          "commit": {
            "abbreviatedOid": "88dd572"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-15T10:47:13Z",
          "updatedAt": "2023-09-15T10:47:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "PR_kwDOFUmh7s5ZWO7i",
      "title": "Describe considerations for streams, datagrams, and a mixture",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/123",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #93 \r\n\r\nNote that the \"- No link definition for link ID 'rfcnnnn' warnings are fixed in  PR #121",
      "createdAt": "2023-09-01T14:52:42Z",
      "updatedAt": "2023-09-15T15:07:17Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "37090ca2ea9f361aee5cfdd7fcb2c001ca5f3751",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-93",
      "headRefOid": "feef2b167cd03e43d01b7653c538324f6bc8a416",
      "closedAt": "2023-09-15T15:07:16Z",
      "mergedAt": "2023-09-15T15:07:16Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "e487461701ad44d64aea12192b879f3ba1867a22"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5hE_Qa",
          "commit": {
            "abbreviatedOid": "3191129"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-15T10:52:17Z",
          "updatedAt": "2023-09-15T10:52:23Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n* DATAGRAM frames belong to a QUIC connection as a whole. There is no QUIC-level way to multiplex/demultiplex DATAGRAM frames within a single QUIC connection. Any multiplexing identifiers must be added, interpreted, and removed by an application, and they will be sent as part of the payload of the DATAGRAM frame itself.\r\n```",
              "createdAt": "2023-09-15T10:52:17Z",
              "updatedAt": "2023-09-15T10:52:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5hE_yt",
          "commit": {
            "abbreviatedOid": "3191129"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-09-15T10:53:37Z",
          "updatedAt": "2023-09-15T10:53:37Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I think adding that it is part of the payload makes it clear that it will not be in any header field of the frame, like the length would be, for example.",
              "createdAt": "2023-09-15T10:53:37Z",
              "updatedAt": "2023-09-15T10:53:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 124,
      "id": "PR_kwDOFUmh7s5a-uJo",
      "title": "Remove suppressing RTCP",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/124",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "RoQ should not change rules for QUIC or RTCP feedback. RTCP can be enhanced and bandwidth reduced, but everything should still look like valid QUIC and RTP/RTCP implementations.",
      "createdAt": "2023-09-22T11:00:14Z",
      "updatedAt": "2023-09-25T16:22:37Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ae0803dce52fdc17cabe6a804ad4814dc01c2ff8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/117-enhancing-instead-of-suppressing-rtcp",
      "headRefOid": "a374d8de0644ab41c96b9cc555d1e7f59704ca2d",
      "closedAt": "2023-09-25T16:22:36Z",
      "mergedAt": "2023-09-25T16:22:36Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "40cb17987fa31dd5c32c10ce5c0a9a1b46912373"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5h5JXg",
          "commit": {
            "abbreviatedOid": "6fe697a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-25T14:55:39Z",
          "updatedAt": "2023-09-25T15:25:25Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I might suggest\r\n\r\n> bandwidth to deliver **equivalent** control information **at more than one level of the protocol stack**.",
              "createdAt": "2023-09-25T14:55:39Z",
              "updatedAt": "2023-09-25T15:25:26Z"
            },
            {
              "originalPosition": 17,
              "body": "I think \r\n\r\n>for replacing some of the RTCP packet types by mapping the contents to QUIC\r\n>connection statistics. \r\n\r\nshould also say something like \r\n\r\n> for replacing some of the RTCP packet types by mapping the contents to QUIC\r\n> connection statistics, **and reducing the transmission frequency and bandwidth requirements for some RTCP packet types that must be transmitted periodically.**  ",
              "createdAt": "2023-09-25T15:17:06Z",
              "updatedAt": "2023-09-25T15:25:26Z"
            },
            {
              "originalPosition": 21,
              "body": "> The mechanisms described in this section can only be used for enhancing\r\n> the **statsitics** provided by RTCP while simultaneously reducing the bandwidth\r\n> overhead required by certain RTCP packets. \r\n\r\n **statsitics** should be  **statistics**.\r\n\r\nI'm struggling a bit with \"can only be used for\". Perhaps this would be better?\r\n\r\n> The mechanisms described in this section can **enhance**\r\n> the **statistics** provided by RTCP **and reduce** the bandwidth\r\n> overhead required by certain RTCP packets.",
              "createdAt": "2023-09-25T15:24:56Z",
              "updatedAt": "2023-09-25T15:25:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 125,
      "id": "PR_kwDOFUmh7s5a_UmQ",
      "title": "Add multihop topologies considerations for RTCP",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/125",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-22T13:00:48Z",
      "updatedAt": "2023-09-25T16:17:23Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "40be8b623b2cead67158ec8584e732155057627a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/75-multihop-topology-considerations-for-rtcp",
      "headRefOid": "39d5bf1e35ee1d53ec3a16c1d744ff0bfbd87723",
      "closedAt": "2023-09-25T16:17:22Z",
      "mergedAt": "2023-09-25T16:17:22Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "ae0803dce52fdc17cabe6a804ad4814dc01c2ff8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5h5bQK",
          "commit": {
            "abbreviatedOid": "ca629e4"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-09-25T15:27:22Z",
          "updatedAt": "2023-09-25T16:03:01Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I'd suggest \r\n\r\n> only **some** of the links",
              "createdAt": "2023-09-25T15:27:22Z",
              "updatedAt": "2023-09-25T16:03:01Z"
            },
            {
              "originalPosition": 7,
              "body": "Just for completeness, \r\n\r\n> Other links may be using RTP over UDP, **or over some other supported RTP encapsulation protocol,** ",
              "createdAt": "2023-09-25T15:34:56Z",
              "updatedAt": "2023-09-25T16:03:01Z"
            },
            {
              "originalPosition": 8,
              "body": "Again, for completeness, \r\n\r\n> participants **might be using implementations that don't support RoQ at all.** \r\n\r\n(the problem isn't that the participants aren't aware of RoQ, but that the implementations aren't aware. :wink:",
              "createdAt": "2023-09-25T15:40:04Z",
              "updatedAt": "2023-09-25T16:03:01Z"
            },
            {
              "originalPosition": 11,
              "body": "I'd suggest \r\n\r\n> participants using **RoQ** **might** not be aware **that other**\r\n> participants are not using **RoQ**",
              "createdAt": "2023-09-25T15:43:55Z",
              "updatedAt": "2023-09-25T16:03:01Z"
            },
            {
              "originalPosition": 18,
              "body": "This is all correct, but perhaps \r\n\r\n> There are two\r\n> ways to solve this problem: **if the middlebox** translating between RoQ and\r\n> RTP over **other RTP transport** protocols such as UDP or TCP **provides Back-to-Back RTP sessions as described in {{Section 3.2.2 of !RFC7667}}, this middlebox** can add RTCP packets for the\r\n> participants not using RoQ by using the statistics **the middlebox** gets from QUIC and the\r\n> mappings described in the following sections. **If the middlebox does not provide Back-to-Back RTP sessions,** participants may\r\n> use additional signalling to let the RoQ participants know what RTCP is\r\n> required.\r\n\r\nwould be better?",
              "createdAt": "2023-09-25T16:02:48Z",
              "updatedAt": "2023-09-25T16:03:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 130,
      "id": "PR_kwDOFUmh7s5bOphe",
      "title": "Fix a reference",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/130",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-26T13:01:12Z",
      "updatedAt": "2023-10-10T07:35:36Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "40cb17987fa31dd5c32c10ce5c0a9a1b46912373",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/reference",
      "headRefOid": "24352bd0ba909737de6117f621803583ad4f4407",
      "closedAt": "2023-10-10T07:35:35Z",
      "mergedAt": "2023-10-10T07:35:35Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "0821d79533383533e6563295167104c799df46ae"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 132,
      "id": "PR_kwDOFUmh7s5cPRDJ",
      "title": "Improve BYE to CONNECTION_CLOSE mapping considerations",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/132",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-09T09:42:20Z",
      "updatedAt": "2023-10-16T13:33:23Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "e1ef3dc5050f7e83bfcff945e07e1af78ae5594d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/129-bye-connection_close-mapping",
      "headRefOid": "9cbb3195288eea6f68b25e6ac34bf9f9d46556fe",
      "closedAt": "2023-10-16T13:33:22Z",
      "mergedAt": "2023-10-16T13:33:22Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "478c72c3ab7f3c147a02d1b92f123b89166cf540"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5j1gdv",
          "commit": {
            "abbreviatedOid": "3ce3b74"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-12T19:09:59Z",
          "updatedAt": "2023-10-12T19:22:36Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I'd suggest rephrasing this sentence as \r\n\r\n> However, if the\r\n> participant only wishes to leave one RTP session while continuing to use the QUIC\r\n> connection, the *BYE* packet MUST be used, because the QUIC CONNECTION_CLOSE \r\n> would close the entire QUIC connection for all other QUIC streams and datagrams.",
              "createdAt": "2023-10-12T19:09:59Z",
              "updatedAt": "2023-10-12T19:22:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5j43eZ",
          "commit": {
            "abbreviatedOid": "3ce3b74"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T07:09:19Z",
          "updatedAt": "2023-10-13T07:09:20Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I would like to avoid the normative *MUST* in *the BYE packet MUST be used*, because that is not a requirement of RFC 3550 in the first place (*[A participant [...] MAY leave the group without sending a BYE at all.](https://www.rfc-editor.org/rfc/rfc3550#section-6.3.7)*). How about this:\r\n\r\n> However, if the\r\n> participant only wishes to leave one RTP session while continuing to use the QUIC\r\n> connection, it has to use the BYE packet because the QUIC CONNECTION_CLOSE\r\n> would close the entire QUIC connection for all other QUIC streams and datagrams.",
              "createdAt": "2023-10-13T07:09:19Z",
              "updatedAt": "2023-10-13T07:09:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5kDFjW",
          "commit": {
            "abbreviatedOid": "3ce3b74"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-15T00:26:18Z",
          "updatedAt": "2023-10-15T00:26:19Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Hi, @mengelbart - we're getting close to converging. \r\n\r\nThe point I was struggling with, is that if you don't send a BYE packet, the sender would continue to send RTP media until the sender detects that the receiver is no longer sending RRs, and \"times the receiver out\". I agree with you, that inserting a MUST is adding a requirement that isn't in RTP today, so I guess the assumption is that the receiver has some reason for not using BYE, and I shouldn't complain about that. \r\n\r\nI do think it's worth pointing out that we're allowing multiplexing of RTP/RTCP and other protocols in a single QUIC connection, so maybe it's better to also allow for the case where the participant is leaving the RTP session, but is continuing to use the QUIC connection for \"something else\", by saying something like \r\n\r\n> However, if the\r\n> participant wishes to **use this QUIC\r\n> connection for any other multiplexed traffic**, the participant has to use the BYE packet because the QUIC CONNECTION_CLOSE\r\n> would close the entire QUIC connection for all other QUIC streams and datagrams.\r\n\r\nDoes that make sense?\r\n",
              "createdAt": "2023-10-15T00:26:19Z",
              "updatedAt": "2023-10-15T00:26:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5kIsQX",
          "commit": {
            "abbreviatedOid": "3ce3b74"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-16T13:32:06Z",
          "updatedAt": "2023-10-16T13:32:07Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "That sounds good. I updated the PR with your proposal and will merge it now.",
              "createdAt": "2023-10-16T13:32:07Z",
              "updatedAt": "2023-10-16T13:32:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 133,
      "id": "PR_kwDOFUmh7s5cWGOU",
      "title": "Move RTCP mappings requiring extensions to appendix",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/133",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #127 \r\n\r\nThis PR does not yet remove the references to the timestamp extensions from section 7. (*Congestion Control and Rate Adaptation*). I am planning to do that in a PR for #128.",
      "createdAt": "2023-10-10T07:51:40Z",
      "updatedAt": "2023-10-23T14:12:43Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0821d79533383533e6563295167104c799df46ae",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/127-normative-references",
      "headRefOid": "e6b7337f76c0e7a01d10a2f7826df1c2a61647bb",
      "closedAt": "2023-10-23T14:12:42Z",
      "mergedAt": "2023-10-23T14:12:42Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "9d13e8d0997b6fd7681eebd2bf528b19cedfc6e9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5jnjjQ",
          "commit": {
            "abbreviatedOid": "e6b7337"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-11T13:56:52Z",
          "updatedAt": "2023-10-11T13:56:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s5j1rva",
          "commit": {
            "abbreviatedOid": "e6b7337"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looked fine to me, with no changes requested. ",
          "createdAt": "2023-10-12T19:33:56Z",
          "updatedAt": "2023-10-12T19:33:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 134,
      "id": "PR_kwDOFUmh7s5cY2Tf",
      "title": "Clarify congestion and rate control",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/134",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #128 ",
      "createdAt": "2023-10-10T13:55:16Z",
      "updatedAt": "2023-10-23T14:26:28Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0b580e7bf671abd48b30990b255f3b38b5b5982d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/128-congestion-and-rate-control",
      "headRefOid": "7a03e8f0e5539b4554980a12cafa70dfff1c37f9",
      "closedAt": "2023-10-23T14:26:28Z",
      "mergedAt": "2023-10-23T14:26:28Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "0a9d21956019349cd27f203d3577956fd99531c4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5j17RB",
          "commit": {
            "abbreviatedOid": "7603ce0"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-12T20:00:44Z",
          "updatedAt": "2023-10-12T23:53:35Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "This sentence ^^ reads as if building queues are the only cause of jitter. I'd suggest phrasing this as \r\n\r\n> maximize the amount of information that is sent to a receiver without causing *buffer bloat*, when \r\n> queues build beyond a reasonable amount, or *jitter*, when interpacket arrival times fluctuate due to queuing delays. ",
              "createdAt": "2023-10-12T20:00:44Z",
              "updatedAt": "2023-10-12T23:53:35Z"
            },
            {
              "originalPosition": 27,
              "body": "I'd suggest \r\n\r\n> Rate adaptation is one way to respond to **sending rate limitations** imposed by",
              "createdAt": "2023-10-12T20:01:59Z",
              "updatedAt": "2023-10-12T23:53:35Z"
            },
            {
              "originalPosition": 86,
              "body": "Just for readability - the previous paragraphs have pointed to document sections at the end of each sentence, but this paragraph starts with the pointer to a document section. Perhaps\r\n\r\n> This document also discusses congestion control implications of using shared\r\n> or multiple separate QUIC connections to send and receive multiple independent\r\n> data streams in {{shared-connections}}.\r\n\r\nor perhaps just flip the previous paragraphs to match this one? Your call, of course. ",
              "createdAt": "2023-10-12T20:08:54Z",
              "updatedAt": "2023-10-12T23:53:35Z"
            },
            {
              "originalPosition": 159,
              "body": "I'd suggest \r\n\r\n> to avoid bursts and minimize variation in inter-packet arrival times.",
              "createdAt": "2023-10-12T23:49:13Z",
              "updatedAt": "2023-10-12T23:53:35Z"
            },
            {
              "originalPosition": 199,
              "body": "I'd suggest\r\n\r\n> when losses are no longer **being** detected)",
              "createdAt": "2023-10-12T23:52:06Z",
              "updatedAt": "2023-10-12T23:53:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5kDFnF",
          "commit": {
            "abbreviatedOid": "5f37e1f"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is ready to merge.",
          "createdAt": "2023-10-15T00:29:49Z",
          "updatedAt": "2023-10-15T00:29:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 137,
      "id": "PR_kwDOFUmh7s5cfTBV",
      "title": "Remove note referencing CLOSE_STREAM and ENOUGH",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/137",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Close #113 ",
      "createdAt": "2023-10-11T09:21:27Z",
      "updatedAt": "2023-10-11T14:02:41Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0821d79533383533e6563295167104c799df46ae",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/113-close-stream-enough",
      "headRefOid": "c59640f7b5f384f1c5cc84cd322864a0cce7ef2c",
      "closedAt": "2023-10-11T14:02:40Z",
      "mergedAt": "2023-10-11T14:02:40Z",
      "mergedBy": "joerg-ott",
      "mergeCommit": {
        "oid": "e1ef3dc5050f7e83bfcff945e07e1af78ae5594d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 138,
      "id": "PR_kwDOFUmh7s5cfYQr",
      "title": "Remove normative API requirements",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/138",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "I don't think normative SHOULD's are useful for describing API considerations. This also clarifies the datagram/stream acknowledgement mappings.\r\n\r\nAdditionally, I removed the API write functions section. I think resetting streams is a core feature of QUIC and it shouldn't be necessary to be listed explicitly. And congestion control configuration is not something that needs an API at runtime. The updates to the congestion control section in #134 should also make this more clear.",
      "createdAt": "2023-10-11T09:34:40Z",
      "updatedAt": "2023-10-23T14:59:38Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d468b6fe4a0977a651234104fd89afd30e706a80",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/131-api-considerations",
      "headRefOid": "0069229d86dac2b306ef00774bb2d6414833b523",
      "closedAt": "2023-10-23T14:59:37Z",
      "mergedAt": "2023-10-23T14:59:37Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "ea21fe4b81de53ebdd1183d6fe8f3beaab7e5f92"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5j3R8T",
          "commit": {
            "abbreviatedOid": "b7803be"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks fine. ",
          "createdAt": "2023-10-12T23:59:48Z",
          "updatedAt": "2023-10-12T23:59:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 139,
      "id": "PR_kwDOFUmh7s5cgk2m",
      "title": "Allow to resume sending datagrams after STOP_SENDING",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/139",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-11T12:35:34Z",
      "updatedAt": "2023-10-16T14:04:26Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "e1ef3dc5050f7e83bfcff945e07e1af78ae5594d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/136-stop-sending-continue-datagrams",
      "headRefOid": "47c4d1e60ba93991fe39d574f357b317a3a83dfe",
      "closedAt": "2023-10-16T14:04:25Z",
      "mergedAt": "2023-10-16T14:04:25Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "0b580e7bf671abd48b30990b255f3b38b5b5982d"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "The problem I see is with this sentence:\r\n\r\n> the RoQ sender MUST open one or more new QUIC streams before sending new media frames.\r\n\r\nTo me, this sounds like I definitely MUST continue sending new media on new streams. But I might want to continue sending the subsequent frames as datagrams instead (and never open a new QUIC stream again). We might instead add something like *STOP_SENDING is not a request to end the media stream but only an indication that a receiver stopped reading a media frame. A sender SHOULD continue sending new media frames of the same media stream. New media frames can be sent in new QUIC streams or as QUIC datagrams (see section ...).*\r\n\r\nI'm using *SHOULD* here because the sender may decide to stop the media stream for different reasons.",
          "createdAt": "2023-10-13T07:23:33Z",
          "updatedAt": "2023-10-13T07:23:33Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - we're converging. I have a somewhat different suggestion, but I agree with where you're going with this text. \r\n\r\n> STOP_SENDING is not a request **to the sender to stop sending the RTP media stream, only an indication that a receiver stopped reading the QUIC stream being used**. A sender **with additional media frames to send SHOULD continue sending them on a QUIC stream in the \"Ready\" state**. **Alternatively**, new media frames can be sent as QUIC datagrams (see section ...).\r\n\r\nDoes that make sense?",
          "createdAt": "2023-10-15T00:52:28Z",
          "updatedAt": "2023-10-15T00:53:57Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> > STOP_SENDING is not a request **to the sender to stop sending the RTP media stream, only an indication that a receiver stopped reading the QUIC stream being used**. A sender **with additional media frames to send SHOULD continue sending them on a QUIC stream in the \"Ready\" state**. **Alternatively**, new media frames can be sent as QUIC datagrams (see section ...).\r\n\r\n\r\nI updated the PR, but instead of `a QUIC stream in the \"Ready\" state`, I used `another QUIC stream,` which is closer to how it was before the change because the *Ready* state is only one of the possible states described in RFC9000. I think it could also be in the *Send* state if the other QUIC stream was used for other packets before.",
          "createdAt": "2023-10-16T13:28:25Z",
          "updatedAt": "2023-10-16T13:28:25Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, @mengelbart - I think we're converged here (on your text). I was hoping I would be able to qualify \"another QUIC stream\", but after reflection, I don't think that's necessary or helpful. \r\n\r\nDude - merge it!",
          "createdAt": "2023-10-16T13:53:59Z",
          "updatedAt": "2023-10-16T13:53:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5jnqh5",
          "commit": {
            "abbreviatedOid": "a2ac4fe"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "or as datagram(s)?",
          "createdAt": "2023-10-11T14:08:10Z",
          "updatedAt": "2023-10-11T14:08:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s5j3g2y",
          "commit": {
            "abbreviatedOid": "a2ac4fe"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Mentioning datagrams within the section discussing STOP_SENDING seems confusing, because this is in Section 5.2 (streams), and because datagrams aren't associated with a stream, STOP_SENDING and RESET_STREAM won't have any effect on whether the sender continues to send datagrams.\r\n\r\nIf you want to say the same kind of thing about datagrams that we're saying here about streams (\"don't re-send old media\"), I guess we can say that in Section 5.3, but I'm not sure I understand why we need to say anything. \r\n\r\nBut I'm not sure what you're trying to get at, with this change. I might guess, but I'd be guessing. HELP! \ud83d\ude36\r\n\r\n(Ping me on Slack if we need to talk, please!)",
          "createdAt": "2023-10-13T00:47:17Z",
          "updatedAt": "2023-10-13T00:47:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 140,
      "id": "PR_kwDOFUmh7s5cgokR",
      "title": "Add IANA considerations for error codes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/140",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "closes #76 ",
      "createdAt": "2023-10-11T12:44:57Z",
      "updatedAt": "2023-10-23T14:09:55Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0b580e7bf671abd48b30990b255f3b38b5b5982d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/finish-error-codes",
      "headRefOid": "8fb68afd6e27c636b259e1663cf5ab819596a394",
      "closedAt": "2023-10-23T14:09:54Z",
      "mergedAt": "2023-10-23T14:09:54Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "a5398b587f5373b42e1adb608257880948ec93a6"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart, this seems ready to merge - thank you for looking over my comments!",
          "createdAt": "2023-10-15T00:33:14Z",
          "updatedAt": "2023-10-15T00:33:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5jnsG_",
          "commit": {
            "abbreviatedOid": "487a308"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-11T14:10:48Z",
          "updatedAt": "2023-10-11T14:10:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s5j3kAE",
          "commit": {
            "abbreviatedOid": "487a308"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-13T01:02:39Z",
          "updatedAt": "2023-10-13T01:28:32Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I don't understand this part at all. There's a lot of cool stuff in 22.1, but is it all applicable to the RoQ error code registry? ",
              "createdAt": "2023-10-13T01:02:39Z",
              "updatedAt": "2023-10-13T01:28:32Z"
            },
            {
              "originalPosition": 34,
              "body": "Possibly \r\n\r\n> duplication **or interaction** with existing error codes",
              "createdAt": "2023-10-13T01:04:24Z",
              "updatedAt": "2023-10-13T01:28:32Z"
            },
            {
              "originalPosition": 51,
              "body": "Especially because we're tying this registry to QUIC practice, the initial registration should probably contain all the fields for each entry, in the order we want them to appear, as the QUIC registries [here](https://www.iana.org/assignments/quic/quic.xhtml#quic-transport-error-codes) show.",
              "createdAt": "2023-10-13T01:10:59Z",
              "updatedAt": "2023-10-13T01:28:32Z"
            },
            {
              "originalPosition": 40,
              "body": "If you want to match the [QUIC transport error code registry](https://www.iana.org/assignments/quic/quic.xhtml#quic-transport-error-codes), this should be \"CODE\". ",
              "createdAt": "2023-10-13T01:20:53Z",
              "updatedAt": "2023-10-13T01:28:32Z"
            },
            {
              "originalPosition": 41,
              "body": "> A short mnemonic for the parameter",
              "createdAt": "2023-10-13T01:22:29Z",
              "updatedAt": "2023-10-13T01:28:32Z"
            },
            {
              "originalPosition": 44,
              "body": "We might as well match this, too:\r\n\r\n> A brief description of the error code semantics, which MAY be a summary if a specification reference is provided.\r\n\r\n",
              "createdAt": "2023-10-13T01:24:04Z",
              "updatedAt": "2023-10-13T01:28:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5j72-c",
          "commit": {
            "abbreviatedOid": "487a308"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T14:31:58Z",
          "updatedAt": "2023-10-13T14:31:58Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I tried to follow what [HTTP/3](https://datatracker.ietf.org/doc/html/rfc9114#name-error-codes) and [DNS over QUIC](https://datatracker.ietf.org/doc/html/rfc9250#name-dns-over-quic-error-codes-r) did. I'm not an expert on this and it may not be applicable, but to me, it seemed to make sense to follow what other application protocol mappings to QUIC do.",
              "createdAt": "2023-10-13T14:31:58Z",
              "updatedAt": "2023-10-13T14:31:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5j75F1",
          "commit": {
            "abbreviatedOid": "487a308"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T14:36:48Z",
          "updatedAt": "2023-10-13T14:36:49Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I don't mind what we use here, but HTTP/3 uses *Name*, and DNS over QUIC uses *Error* :D ",
              "createdAt": "2023-10-13T14:36:49Z",
              "updatedAt": "2023-10-13T14:36:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5j76FE",
          "commit": {
            "abbreviatedOid": "487a308"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T14:39:07Z",
          "updatedAt": "2023-10-13T14:39:07Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Also taken from HTTP/3. I find *A name for the error code* much easier to understand, especially since the codes are not called parameters anywhere else.",
              "createdAt": "2023-10-13T14:39:07Z",
              "updatedAt": "2023-10-13T14:39:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5j7-E5",
          "commit": {
            "abbreviatedOid": "487a308"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-13T14:47:47Z",
          "updatedAt": "2023-10-13T14:47:47Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "I think all fields are included: *Name*, *Value*, *Description*, and *Specification* are in the table, *Status*, *Change Controller*, and *Contact* for all are given in the text above. HTTP/3 uses this order but the table in the registry uses a different order. I'll swap it here, so we may have the same order here and in the registry.",
              "createdAt": "2023-10-13T14:47:47Z",
              "updatedAt": "2023-10-13T14:47:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5kR99Z",
          "commit": {
            "abbreviatedOid": "d4ac416"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I see a couple of nits that would be good to fix before we call everyone's attention to the IANA section. Could you let me know in Slack when you've had a chance to fix them? ",
          "createdAt": "2023-10-17T13:51:20Z",
          "updatedAt": "2023-10-17T14:06:49Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Nit: I'd suggest adding parentheses here. \r\n\r\n> This document registers a new ALPN protocol ID **(in {{iana-alpn}})** and creates a new\r\n> registry that manages the assignment of error code points in RoQ **(in \r\n> {{iana-error-codes}}).**",
              "createdAt": "2023-10-17T13:51:21Z",
              "updatedAt": "2023-10-17T14:06:49Z"
            },
            {
              "originalPosition": 34,
              "body": "> (RoQ) Error Codes\" registry manages a 62-bit space and is listed under the **the**\r\n\r\nhas an extra \"the\". ",
              "createdAt": "2023-10-17T13:52:17Z",
              "updatedAt": "2023-10-17T14:06:49Z"
            },
            {
              "originalPosition": 51,
              "body": "As we discussed yesterday, I knew we were trying to match the QUIC error codes, but didn't realize that HTTP/3 error codes and DNS over QUIC error codes didn't match QUIC, or each other. My apologies, obviously my comment doesn't matter!",
              "createdAt": "2023-10-17T14:04:24Z",
              "updatedAt": "2023-10-17T14:13:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 143,
      "id": "PR_kwDOFUmh7s5dMWJO",
      "title": "Configure streams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/143",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #142 ",
      "createdAt": "2023-10-18T21:36:25Z",
      "updatedAt": "2023-10-23T14:23:24Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0b580e7bf671abd48b30990b255f3b38b5b5982d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-142-configure-streams",
      "headRefOid": "e91d2aff10b3c5f38fbfca9496c76275ef5eb432",
      "closedAt": "2023-10-23T14:23:23Z",
      "mergedAt": "2023-10-23T14:23:23Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "5ed81891f001e6be3e308277a4aad2c55920aaf6"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I'm looking at this text, also in {#quic-streams},\r\n\r\n> A RoQ receiver MUST be prepared to receive RTP packets on any number of QUIC streams (subject to its limit on parallel open streams) and SHOULD not make assumptions about which RTP sequence numbers are carried in which streams.\r\n> \r\n> Note: A sender may or may not decide to discontinue using a lower stream number after starting packet transmission on a higher stream number.\r\n\r\nI think this would be better as \r\n\r\n> **Because a sender can continue sending on a lower stream number after starting packet transmission on a higher stream number,** a RoQ receiver MUST be prepared to receive RoQ packets on any number of QUIC streams (subject to its limit on parallel open streams) and SHOULD not make assumptions about which RTP sequence numbers are carried in which streams.\r\n\r\nI'm not wild about  \r\n\r\n> **SHOULD** not make assumptions about which RTP sequence numbers are carried in which streams\r\n\r\nfor a couple of reasons.\r\n\r\nIs this more like \r\n\r\n> SHOULD be prepared to accept any RTP sequence number on any open stream?\r\n\r\nWe can wait to talk about the SHOULD until we work on #111, but in any event, \r\n\r\n- we should have a legitimate reason for why a RoQ receiver would choose not to accept any RTP sequence number on any open stream, given that a RoQ sender can send any RTP sequence number on any open stream, and \r\n- if a RoQ receiver makes that choice, we need to think about what happens next.\r\n\r\nIf you send me an RTP packet with sequence number 12 on stream 32, and I'm not prepared to accept it. Do I drop it? Do I need to tell you that I'm dropping it because of the stream it arrived on, so you don't look at the ACKs/RRs and decide that you need to reduce the sending rate (because you're sending RTP packets that aren't being acknowledged)? Etc.\r\n\r\n",
          "createdAt": "2023-10-23T12:34:44Z",
          "updatedAt": "2023-10-23T12:34:44Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> @mengelbart - I'm looking at this text, also in {#quic-streams},\r\n> \r\n> > A RoQ receiver MUST be prepared to receive RTP packets on any number of QUIC streams (subject to its limit on parallel open streams) and SHOULD not make assumptions about which RTP sequence numbers are carried in which streams.\r\n> > Note: A sender may or may not decide to discontinue using a lower stream number after starting packet transmission on a higher stream number.\r\n> \r\n> I think this would be better as\r\n> \r\n> > **Because a sender can continue sending on a lower stream number after starting packet transmission on a higher stream number,** a RoQ receiver MUST be prepared to receive RoQ packets on any number of QUIC streams (subject to its limit on parallel open streams) and SHOULD not make assumptions about which RTP sequence numbers are carried in which streams.\r\n\r\nSounds good to me.\r\n\r\n> I'm not wild about\r\n> \r\n> > **SHOULD** not make assumptions about which RTP sequence numbers are carried in which streams\r\n> \r\n> for a couple of reasons.\r\n> \r\n> Is this more like\r\n> \r\n> > SHOULD be prepared to accept any RTP sequence number on any open stream?\r\n> \r\n> We can wait to talk about the SHOULD until we work on #111, but in any event,\r\n> \r\n>     * we should have a legitimate reason for why a RoQ receiver would choose not to accept any RTP sequence number on any open stream, given that a RoQ sender can send any RTP sequence number on any open stream, and\r\n> \r\n>     * if a RoQ receiver makes that choice, we need to think about what happens next.\r\n> \r\n> \r\n> If you send me an RTP packet with sequence number 12 on stream 32, and I'm not prepared to accept it. Do I drop it? Do I need to tell you that I'm dropping it because of the stream it arrived on, so you don't look at the ACKs/RRs and decide that you need to reduce the sending rate (because you're sending RTP packets that aren't being acknowledged)? Etc.\r\n\r\nThese are good points. I think we want to use *MUST* instead. There should be no special treatment of RTP packets just because they arrive on a stream with a lower ID or on datagrams.\r\n",
          "createdAt": "2023-10-23T13:52:31Z",
          "updatedAt": "2023-10-23T13:52:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5kjH1L",
          "commit": {
            "abbreviatedOid": "92551ea"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-19T07:32:18Z",
          "updatedAt": "2023-10-19T07:32:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "This is a useful addition, but I suggest moving it into the MAX_STREAMS/flow control subsection to keep all the things related to that issue in one place.",
              "createdAt": "2023-10-19T07:32:18Z",
              "updatedAt": "2023-10-19T07:32:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5k30MK",
          "commit": {
            "abbreviatedOid": "92551ea"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T11:58:24Z",
          "updatedAt": "2023-10-23T11:58:24Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Agreed (thanks for the helpful suggestion). I committed a change for this. ",
              "createdAt": "2023-10-23T11:58:24Z",
              "updatedAt": "2023-10-23T11:58:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 144,
      "id": "PR_kwDOFUmh7s5dNbuC",
      "title": "Describe strategies for reacting to datagram non-support",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/144",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Please note that I moved text about QUIC implementations exposing maximum datagram sizes to the API section as well. \r\n\r\ncloses #122 \r\ncloses #13 ",
      "createdAt": "2023-10-19T01:46:57Z",
      "updatedAt": "2023-10-23T14:27:50Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0b580e7bf671abd48b30990b255f3b38b5b5982d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-122-no-datagram-support-during-handshake",
      "headRefOid": "7b8d11b975f489380126ab5fd72bb444a896ae97",
      "closedAt": "2023-10-23T14:27:49Z",
      "mergedAt": "2023-10-23T14:27:49Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "7e04a44f24d4a9cbad8755b111c6f3a1fd0f78ba"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5kjFgL",
          "commit": {
            "abbreviatedOid": "e6d3b31"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-19T07:26:59Z",
          "updatedAt": "2023-10-19T07:27:28Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I would prefer to keep the normative MUST out of here. #138 removes all the other normative SHOULDs from this section, too. I would suggest removing the MUST here and in the datagram encapsulation section. Instead, we should explain why the application should be able to learn about the maximum size and what can happen if it cannot. If the application does not know the maximum size, it may try to send datagrams that will be dropped. I think it makes sense to explain that in the datagram encapsulation section.",
              "createdAt": "2023-10-19T07:26:59Z",
              "updatedAt": "2023-10-19T07:27:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5kxtu0",
          "commit": {
            "abbreviatedOid": "e6d3b31"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-20T18:58:21Z",
          "updatedAt": "2023-10-20T18:58:22Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> I would prefer to keep the normative MUST out of here. #138 removes all the other normative SHOULDs from this section, too. I would suggest removing the MUST here and in the datagram encapsulation section. Instead, we should explain why the application should be able to learn about the maximum size and what can happen if it cannot. If the application does not know the maximum size, it may try to send datagrams that will be dropped. I think it makes sense to explain that in the datagram encapsulation section.\r\n\r\n@mengelbart - that makes sense to me, and I'll make the change you're suggesting, but I should point out that \r\n\r\n> This section provides a list of items that an application might want to export\r\nfrom an underlying QUIC implementation. It is thus **RECOMMENDED** that a QUIC\r\nimplementation exports the listed items to the application.\r\n\r\nis also BCP14-normative ... our terminology section uses the BCP14 template, and [BCP14 uses SHOULD and RECOMMENDED as synonyms](https://datatracker.ietf.org/doc/html/rfc2119#autoid-3). \r\n\r\nWould you like me to make a change there, too?",
              "createdAt": "2023-10-20T18:58:22Z",
              "updatedAt": "2023-10-20T18:58:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5k2aqT",
          "commit": {
            "abbreviatedOid": "e6d3b31"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T08:31:42Z",
          "updatedAt": "2023-10-23T08:31:43Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "No need to. It will already be changed with #138.",
              "createdAt": "2023-10-23T08:31:42Z",
              "updatedAt": "2023-10-23T08:31:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 145,
      "id": "PR_kwDOFUmh7s5dNen-",
      "title": "Move rate adaptation mention to scope",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/145",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "close #141 ",
      "createdAt": "2023-10-19T02:04:36Z",
      "updatedAt": "2023-10-23T14:08:43Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0b580e7bf671abd48b30990b255f3b38b5b5982d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-141-move-rate-adapt-to-scope",
      "headRefOid": "3511b43f16523c944e014416f6eebc4e0750f6b5",
      "closedAt": "2023-10-23T14:08:42Z",
      "mergedAt": "2023-10-23T14:08:42Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "57b12e50d36413fd7d0efc438c7fbbde132e3d43"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5kiWhv",
          "commit": {
            "abbreviatedOid": "3511b43"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-19T05:33:12Z",
          "updatedAt": "2023-10-19T05:33:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 146,
      "id": "PR_kwDOFUmh7s5dVCjT",
      "title": "Improve congestion control  and rate adaptation in motivation section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/146",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Also adding explanation of the use of congestion control and rate adaptation terms in this document.\r\n\r\ncloses #135 ",
      "createdAt": "2023-10-20T00:40:15Z",
      "updatedAt": "2023-10-23T14:42:45Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "7e04a44f24d4a9cbad8755b111c6f3a1fd0f78ba",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-135-cc-and-rate-adaptation-in-motivation-section",
      "headRefOid": "4693f44ba8cd8982046d1b663a7b0268a1558868",
      "closedAt": "2023-10-23T14:42:44Z",
      "mergedAt": "2023-10-23T14:42:44Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "d468b6fe4a0977a651234104fd89afd30e706a80"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba, could you take a look at the changes I made in the terminology section about \"congestion control\" and \"rate adaptation\" term usage? I think what I said is accurate, but I'm also wondering what else we can do. ",
          "createdAt": "2023-10-20T17:21:20Z",
          "updatedAt": "2023-10-20T17:21:20Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "NONE",
          "body": "Comments provided within the PR.\u00a0On Oct 20, 2023, at 10:21, Spencer Dawkins ***@***.***> wrote:\ufeff\r\n@aboba, could you take a look at the changes I made in the terminology section about \"congestion control\" and \"rate adaptation\" term usage? I think what I said is accurate, but I'm also wondering what else we can do.\r\n\r\n\u2014Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you were mentioned.Message ID: ***@***.***>",
          "createdAt": "2023-10-20T22:44:18Z",
          "updatedAt": "2023-10-20T22:44:18Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@aboba and @mengelbart - I think you both had valuable comments on this text:\r\n\r\n> Taken as a whole,\r\n> \r\n> * RTP stream-level rate adaptation can give a better user experience than QUIC connection-level congestion control by minimizing packet loss,\r\n> * but QUIC connection-level congestion control can respond more quickly to the end of congestion than RTP \"circuit breakers\".\r\n\r\nJust to make sure my change is consistent, I'm checking with both of you about this proposed revision (now committed).\r\n\r\n> Taken as a whole,\r\n> \r\n> * **Timely** RTP stream-level rate adaptation **will** give a better user experience by minimizing **endpoint queuing delays and** packet loss,\r\n> * but **in the presence of packet loss**, QUIC connection-level congestion control **will** respond more quickly to the end of congestion than RTP \"circuit breakers\".",
          "createdAt": "2023-10-23T13:19:22Z",
          "updatedAt": "2023-10-23T13:54:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5kycvn",
          "commit": {
            "abbreviatedOid": "ae643a4"
          },
          "author": "aboba",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Since QUIC CC is always there, there's no real choice here. You might say that \"timely rate adaptation can minimize endpoint queuing delays and loss\". ",
          "createdAt": "2023-10-20T21:58:56Z",
          "updatedAt": "2023-10-20T21:58:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s5k2jwY",
          "commit": {
            "abbreviatedOid": "ae643a4"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-10-23T08:51:16Z",
          "updatedAt": "2023-10-23T08:58:09Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "> QUIC congestion avoidance procedures (for example, the procedures defined in {{?RFC9002}}) will cause the RTP packets to be buffered and only placed on the network path as part of a response to detected loss.\r\n\r\nI don't understand the sentence why would packets be placed on the network in response to detected loss? Is there a word/fragment of the sentence missing here?",
              "createdAt": "2023-10-23T08:51:16Z",
              "updatedAt": "2023-10-23T08:58:09Z"
            },
            {
              "originalPosition": 36,
              "body": "I suggest phrasing this as *QUIC connection-level congestion control __will__ respond more quickly* to emphasize that it is not a choice between the two and that QUIC congestion control is not optional.",
              "createdAt": "2023-10-23T08:53:57Z",
              "updatedAt": "2023-10-23T08:58:09Z"
            },
            {
              "originalPosition": 51,
              "body": "In #128 I removed the {{nested-CC}} section and merged it with the one before because they became very similar. I also removed the note about bufferbloat. Maybe we can directly include that here and remove the reference to the other section?",
              "createdAt": "2023-10-23T08:57:45Z",
              "updatedAt": "2023-10-23T08:58:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5k4loS",
          "commit": {
            "abbreviatedOid": "ae643a4"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T13:29:37Z",
          "updatedAt": "2023-10-23T13:29:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "@mengelbart - you don't understand \r\n\r\n> I don't understand the sentence why would packets be placed on the network in response to detected loss? Is there a word/fragment of the sentence missing here?\r\n\r\nbecause it's wrong! This should have been something like \r\n\r\n> The result is that even if an RTP sender continues to \"send\", QUIC congestion avoidance procedures (for example, the procedures defined in {{?RFC9002}}) will cause the RTP packets to be buffered **while QUIC responds to detected packet loss**. This happens without RTP senders taking any action, **but the RTP sender has no control over this QUIC mechanism**. \r\n\r\nNow committed. ",
              "createdAt": "2023-10-23T13:29:37Z",
              "updatedAt": "2023-10-23T13:29:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5k42e7",
          "commit": {
            "abbreviatedOid": "ae643a4"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-23T13:51:53Z",
          "updatedAt": "2023-10-23T13:51:53Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Hi, @mengelbart - that sounds good, but I'm not sure whether you wanted to fix this, or have me fix it. Since we have a conference call in 9 minutes, let's fix it exactly once!",
              "createdAt": "2023-10-23T13:51:53Z",
              "updatedAt": "2023-10-23T13:51:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 148,
      "id": "PR_kwDOFUmh7s5ezFGr",
      "title": "Update error codes starting from 0x00",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/148",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "@LPardue noticed we didn't assign 0x00 to any error code. I think it would be nice to have 0x00 as NO_ERROR. I also added the real codes to the error handling section.",
      "createdAt": "2023-11-07T12:06:30Z",
      "updatedAt": "2023-11-27T09:00:08Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "ea21fe4b81de53ebdd1183d6fe8f3beaab7e5f92",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/error-codes",
      "headRefOid": "4b162adc06bfb60248f8d2ae1ddf5b5290f66e4c",
      "closedAt": "2023-11-27T09:00:07Z",
      "mergedAt": "2023-11-27T09:00:07Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d46cbffe37ae493130f63003b81727432f99df67"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5mZTWl",
          "commit": {
            "abbreviatedOid": "4b162ad"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "@LPurdue is a smart guy. That's a good thing to do. \r\n\r\nIt looks good to merge, to me!",
          "createdAt": "2023-11-07T14:54:34Z",
          "updatedAt": "2023-11-07T14:54:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s5mayS2",
          "commit": {
            "abbreviatedOid": "4b162ad"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "LGTM :shipit: ",
          "createdAt": "2023-11-07T17:28:53Z",
          "updatedAt": "2023-11-07T17:28:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 150,
      "id": "PR_kwDOFUmh7s5lamO8",
      "title": "Add missing brackets",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/150",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-30T07:59:20Z",
      "updatedAt": "2024-02-08T08:55:01Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d46cbffe37ae493130f63003b81727432f99df67",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix-missing-bracket",
      "headRefOid": "cbeee1b0fc8dd5cc2a8eee2b31ed33777a2869f6",
      "closedAt": "2024-02-08T08:55:00Z",
      "mergedAt": "2024-02-08T08:55:00Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "5f57e14312761cfc0d91e9368f817bd03637ebc6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 151,
      "id": "PR_kwDOFUmh7s5lamg2",
      "title": "The term is not used in the document",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/151",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-01-30T08:00:11Z",
      "updatedAt": "2024-02-09T08:34:30Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d46cbffe37ae493130f63003b81727432f99df67",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "remove-media-encoder-terminology",
      "headRefOid": "39701370e2ddf116dfbc5f2eaf998c996de76d2e",
      "closedAt": "2024-02-09T08:34:29Z",
      "mergedAt": "2024-02-09T08:34:29Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "0983a73e24332faba1d1d87a4dace09078aa99b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5vfqKJ",
          "commit": {
            "abbreviatedOid": "3970137"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "You are doing the right thing. ",
          "createdAt": "2024-02-08T15:38:55Z",
          "updatedAt": "2024-02-08T15:39:12Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I think it's correct that we aren't using it - I looked at a couple of other documents (RTP over TCP, etc.) and the focus is encapsulating a media stream that has already been encoded. So, yes, we should remove it!",
              "createdAt": "2024-02-08T15:38:55Z",
              "updatedAt": "2024-02-08T15:39:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 152,
      "id": "PR_kwDOFUmh7s5ljmDZ",
      "title": "Add considerations for coalescing RTP packets",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/152",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #86 ",
      "createdAt": "2024-01-31T10:53:41Z",
      "updatedAt": "2024-02-16T15:10:51Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0983a73e24332faba1d1d87a4dace09078aa99b1",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/86-coalescing-packets-considerations",
      "headRefOid": "cff17bf98b193813ca07cba82879c31873392d75",
      "closedAt": "2024-02-16T15:10:50Z",
      "mergedAt": "2024-02-16T15:10:50Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "d807482868d006a244fed082a810588a6d28b90e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5vgbM4",
          "commit": {
            "abbreviatedOid": "adfd3a7"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I provided a restructured paragraph, and made a couple of suggestions, and asked a couple of questions, but I know you'll do the right thing. ",
          "createdAt": "2024-02-08T16:58:27Z",
          "updatedAt": "2024-02-08T17:34:09Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "My understanding of the way this works, is this way - I'm trying to be distinguish between putting things into QUIC frames, and about putting QUIC frames into QUIC packets. \r\n\r\nApplications have some control over how the QUIC stack maps application data to QUIC frames, but applications cannot control how the QUIC stack maps STREAM and DATAGRAM frames to QUIC packets {{Section 13 of ?RFC9000}} and {{Section 5 of ?RFC9308}}.\r\n* When RTP payloads are carried over QUIC streams, the RTP payload is treated as an ordered byte stream that will be carried in QUIC stream frames, with no effort to match application data boundaries. \r\n* When RTP payloads are carried over QUIC DATAGRAMs, each RTP payload data unit is mapped into a QUIC DATAGRAM frame, but \r\n* QUIC implementations can include multiple STREAM frames from different streams and one or more DATAGRAM frames into a single QUIC packet, and may include other QUIC frames as well. ",
              "createdAt": "2024-02-08T16:58:27Z",
              "updatedAt": "2024-02-08T17:34:09Z"
            },
            {
              "originalPosition": 15,
              "body": "For \r\n\r\n> If there is not enough data, QUIC stacks might wait before sending out packets\r\n\r\nI'd suggest \r\n\r\n>QUIC stacks are allowed to wait for a short period of time if the queued QUIC packet is shorter than the path MTU, in order ",
              "createdAt": "2024-02-08T17:01:22Z",
              "updatedAt": "2024-02-08T17:34:09Z"
            },
            {
              "originalPosition": 18,
              "body": "I'd add \r\n\r\n> This waiting interval is under the QUIC implementation's control, and might be based on knowledge about application sending behavior or heuristics to determine whether and for how long to wait.",
              "createdAt": "2024-02-08T17:04:23Z",
              "updatedAt": "2024-02-08T17:34:09Z"
            },
            {
              "originalPosition": 25,
              "body": "Just to make sure I understand this, is the recommendation that the application queue any related small media objects with an earlier RTP timestamp than the next large media object, before they queue that large media object?\r\n\r\nI'm trying to figure out how the application can make sure that the audio frames can be included in a QUIC packet that also carries video frames. I think \"sending small objects first\" might accomplish that, but whatever we say, we need to give advice that an application developer can implement. \r\n\r\nThis only matters if we don't have lots of large objects, right? ",
              "createdAt": "2024-02-08T17:17:31Z",
              "updatedAt": "2024-02-08T17:34:09Z"
            },
            {
              "originalPosition": 28,
              "body": "I know we've talked about this before, but some application designers have control over QUIC implementations, and others do not. Is this also a reason why we want people to use \"rtp-mux-quic\"? If so, we should probably say that, someplace - maybe in a new subsection 7.x. \r\n\r\n(if your QUIC implementation accepts that ALPN string, you ought to be smart about this kind of thing)",
              "createdAt": "2024-02-08T17:30:20Z",
              "updatedAt": "2024-02-08T17:34:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5vk3ZJ",
          "commit": {
            "abbreviatedOid": "adfd3a7"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T09:05:21Z",
          "updatedAt": "2024-02-09T09:05:21Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I think any recommendation we can make depends on the level of control the application has over the QUIC stack. Queuing small objects before large ones might work but may require waiting for small objects in the application and possibly delaying large objects. Or delaying small objects to fill the packet and avoid sending small packets. There are some contradictory goals because we'd like to send audio packets as soon as possible but also try to avoid sending small packets, thus having to wait until a packet is _large enough_. It may require some research to give good recommendations here. ",
              "createdAt": "2024-02-09T09:05:21Z",
              "updatedAt": "2024-02-09T09:05:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5vk4LF",
          "commit": {
            "abbreviatedOid": "adfd3a7"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T09:07:19Z",
          "updatedAt": "2024-02-09T09:07:19Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "How is it related to the ALPN? All QUIC implementations I have worked with so far accept any ALPN string I gave them, and I don't think there is any kind of special behavior based on what the ALPN is.",
              "createdAt": "2024-02-09T09:07:19Z",
              "updatedAt": "2024-02-09T09:07:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5vk4Z7",
          "commit": {
            "abbreviatedOid": "adfd3a7"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T09:07:54Z",
          "updatedAt": "2024-02-09T09:07:54Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I just copied the whole paragraph :)",
              "createdAt": "2024-02-09T09:07:54Z",
              "updatedAt": "2024-02-09T09:07:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5vk6yS",
          "commit": {
            "abbreviatedOid": "adfd3a7"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T09:13:51Z",
          "updatedAt": "2024-02-09T09:13:52Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Yeah, so, that's the thing. I'm not sure whether having our own ALPN string will make any difference at all in practice. One might think that it would make a difference - for instance, a QUIC implementation might focus more on minimizing one-way delays, and not worry as much about probing for bandwidth - but if QUIC implementations don't make that adjustment, I probably need to rethink why we still need \"rtp-mux-quic\".\r\n\r\nNote that this is much more about me needing to think, than us needing to change anything in the spec! ",
              "createdAt": "2024-02-09T09:13:51Z",
              "updatedAt": "2024-02-09T09:13:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5vk-yD",
          "commit": {
            "abbreviatedOid": "adfd3a7"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T09:23:33Z",
          "updatedAt": "2024-02-09T09:23:33Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "We need \"rtp-mux-quic\" to tell the application on the other end that we will use the QUIC connection to send RTP packets encapsulated as described in this document.",
              "createdAt": "2024-02-09T09:23:33Z",
              "updatedAt": "2024-02-09T09:23:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5vk_VS",
          "commit": {
            "abbreviatedOid": "adfd3a7"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T09:24:55Z",
          "updatedAt": "2024-02-09T09:24:55Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "That all makes perfect sense to me. The question is, how the QUIC implementation might adjust its delay timer so that the right thing happens. \r\n\r\nBut what I was suggesting, was that if you queue up all the small frames with a timestamp earlier than the next large frame, that should minimize the chance that the QUIC implementation will emit a bunch of small packets. But this is guessing at what the QUIC implementation might do, in the absence of any defined behavior (beyond \"I might wait for a short time before sending the packet\"), and in the absence of any way to tell the QUIC implementation \"if you're waiting a short time for more frames, this stuff is audio, so please set your timer appropriately\". \r\n\r\nMaybe THIS is something the \"rtp-mux-quic\" ALPN could tell the QUIC implementation? \r\n\r\nI love heuristics about how to deal with someone else's heuristics. :grimacing:",
              "createdAt": "2024-02-09T09:24:55Z",
              "updatedAt": "2024-02-09T09:24:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5vlAzL",
          "commit": {
            "abbreviatedOid": "adfd3a7"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-09T09:28:31Z",
          "updatedAt": "2024-02-09T09:28:31Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "And now I remember that - thanks for the wake-up call!",
              "createdAt": "2024-02-09T09:28:31Z",
              "updatedAt": "2024-02-09T09:28:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 153,
      "id": "PR_kwDOFUmh7s5luVgk",
      "title": "Tighten up congestion control versus rate adaptation",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/153",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #149.\r\n\r\nNote that I also improved the related definitions in Section 2, ",
      "createdAt": "2024-02-01T16:39:03Z",
      "updatedAt": "2024-02-09T09:43:30Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "d46cbffe37ae493130f63003b81727432f99df67",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-149",
      "headRefOid": "b51bff827b9ab157f7ba3ac9a12e22151bc3a6a6",
      "closedAt": "2024-02-09T09:43:30Z",
      "mergedAt": "2024-02-09T09:43:30Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "cbb40842d638b78c88f375675942cb743c153f3a"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thanks, I think this is ready to merge.",
          "createdAt": "2024-02-09T09:20:35Z",
          "updatedAt": "2024-02-09T09:20:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5vbznf",
          "commit": {
            "abbreviatedOid": "53e04e3"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T08:43:18Z",
          "updatedAt": "2024-02-08T08:54:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think the first sentence is missing a verb. Or maybe *focused* should be *focus*?",
              "createdAt": "2024-02-08T08:43:19Z",
              "updatedAt": "2024-02-08T08:54:40Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n: A congestion control algorithm that aims at keeping queues, and thus the latency, at intermediary network elements as short as possible. Delay-based congestion control algorithms use, for example, an increasing one-way delay as a signal of impending congestion, and adjust the sending rate to prevent continued increases in one-way delay.\r\n```",
              "createdAt": "2024-02-08T08:45:13Z",
              "updatedAt": "2024-02-08T08:54:40Z"
            },
            {
              "originalPosition": 24,
              "body": "I don't think this is correct. I understood this definition as describing an application mechanism, such as adapting quantization parameters or changing resolution?",
              "createdAt": "2024-02-08T08:50:40Z",
              "updatedAt": "2024-02-08T08:54:40Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nbut this section would apply to any congestion control algorithm that meets the\r\n```\r\nI think this is the change @gchandok was initially proposing in #149.",
              "createdAt": "2024-02-08T08:54:25Z",
              "updatedAt": "2024-02-08T08:54:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5vgzKU",
          "commit": {
            "abbreviatedOid": "53e04e3"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T17:40:33Z",
          "updatedAt": "2024-02-08T17:40:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I meant something that happened over time, but that isn't clear. I'll reword. ",
              "createdAt": "2024-02-08T17:40:33Z",
              "updatedAt": "2024-02-08T17:40:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5vgzZM",
          "commit": {
            "abbreviatedOid": "53e04e3"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T17:40:53Z",
          "updatedAt": "2024-02-08T17:40:53Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Agree. I'll make this change. \r\n\r\n",
              "createdAt": "2024-02-08T17:40:53Z",
              "updatedAt": "2024-02-08T17:40:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5vg2Pj",
          "commit": {
            "abbreviatedOid": "53e04e3"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T17:47:32Z",
          "updatedAt": "2024-02-08T17:47:32Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Yes.",
              "createdAt": "2024-02-08T17:47:32Z",
              "updatedAt": "2024-02-08T17:49:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5vhBYS",
          "commit": {
            "abbreviatedOid": "53e04e3"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-08T18:09:13Z",
          "updatedAt": "2024-02-08T18:09:13Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "\"We're both correct\". These terms are super-overloaded. I'll try again, and see if I can do better. ",
              "createdAt": "2024-02-08T18:09:13Z",
              "updatedAt": "2024-02-08T18:09:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 154,
      "id": "PR_kwDOFUmh7s5mkUoK",
      "title": "Explain multiple paths more clearly",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/154",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #115 ",
      "createdAt": "2024-02-11T01:25:35Z",
      "updatedAt": "2024-02-16T15:09:49Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "cbb40842d638b78c88f375675942cb743c153f3a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-115",
      "headRefOid": "e9f248a8ab8c40b46a65bbf0d1bbc61851b0a818",
      "closedAt": "2024-02-16T15:09:48Z",
      "mergedAt": "2024-02-16T15:09:48Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "22c4e6eb04270a83e21a187f4e83dcad242b7e2e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5vwBBa",
          "commit": {
            "abbreviatedOid": "e9f248a"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-12T09:52:18Z",
          "updatedAt": "2024-02-12T09:52:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 155,
      "id": "PR_kwDOFUmh7s5mnqGi",
      "title": "Clearly list the three alternatives",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/155",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-12T10:30:30Z",
      "updatedAt": "2024-02-16T15:12:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "cbb40842d638b78c88f375675942cb743c153f3a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/84",
      "headRefOid": "c7fba873af872fbcab0788401f0ba6156a2a42ec",
      "closedAt": "2024-02-16T15:12:04Z",
      "mergedAt": "2024-02-16T15:12:04Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "cbc4f05254a7170e57e3e06e24388882fe4cbf6d"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "closes #84 ",
          "createdAt": "2024-02-12T10:30:43Z",
          "updatedAt": "2024-02-12T10:30:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 156,
      "id": "PR_kwDOFUmh7s5mn7Fp",
      "title": "Review appendix B",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/156",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "close #126 ",
      "createdAt": "2024-02-12T11:15:07Z",
      "updatedAt": "2024-02-16T15:08:37Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "cbb40842d638b78c88f375675942cb743c153f3a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/126",
      "headRefOid": "648f38c65f16a9adb65e44148bdbf9c00888ac35",
      "closedAt": "2024-02-16T15:08:36Z",
      "mergedAt": "2024-02-16T15:08:36Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "50fbdefaf511e33af2f75452bc59599c2bce245f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5v9-VJ",
          "commit": {
            "abbreviatedOid": "648f38c"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks fine to me!",
          "createdAt": "2024-02-13T17:04:14Z",
          "updatedAt": "2024-02-13T17:04:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 158,
      "id": "PR_kwDOFUmh7s5msgJ9",
      "title": "Cleanup of many SHOULDs",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/158",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #111 ",
      "createdAt": "2024-02-13T00:44:45Z",
      "updatedAt": "2024-02-20T07:45:44Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "cbb40842d638b78c88f375675942cb743c153f3a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "bcp14",
      "headRefOid": "6d4e7e159f865b6fd0637d331730d2c39ec67b3c",
      "closedAt": "2024-02-20T07:45:43Z",
      "mergedAt": "2024-02-20T07:45:43Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "da0556573cebd366d4255db8a2a23625dee1c54f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5v4m6c",
          "commit": {
            "abbreviatedOid": "1079f4c"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Thanks, I think this is ready to be merged.",
          "createdAt": "2024-02-13T08:23:40Z",
          "updatedAt": "2024-02-13T08:34:22Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I wonder if this should lead to closing the connection because it is a protocol violation? We make that change in a different PR though.",
              "createdAt": "2024-02-13T08:23:41Z",
              "updatedAt": "2024-02-13T08:34:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5v-mEh",
          "commit": {
            "abbreviatedOid": "1079f4c"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-13T18:36:09Z",
          "updatedAt": "2024-02-13T18:36:09Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Actually, you're right - we talked about that, but somehow it didn't make the transition into our shared notes from our call. Let's wait to merge until I can update the PR (I'm having odd Windows problems right now, so that may take a day or two). ",
              "createdAt": "2024-02-13T18:36:09Z",
              "updatedAt": "2024-02-13T18:36:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5wdY13",
          "commit": {
            "abbreviatedOid": "1079f4c"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-17T18:00:43Z",
          "updatedAt": "2024-02-17T18:00:44Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "@mengelbart - I think I got this one right. Please let me know! \r\n\r\nIf I did, we should be able to merge the PR. ",
              "createdAt": "2024-02-17T18:00:43Z",
              "updatedAt": "2024-02-17T18:00:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 162,
      "id": "PR_kwDOFUmh7s5nL6QM",
      "title": "Move details about ECN and L4S into Section 7.1",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/162",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #160",
      "createdAt": "2024-02-17T18:31:01Z",
      "updatedAt": "2024-02-20T14:58:37Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0ef30aa132d25d0753031a4cc393efc76db00f2c",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-160",
      "headRefOid": "911d323b912f5c89b5f873b0b8d1e32cc93545de",
      "closedAt": "2024-02-20T14:58:37Z",
      "mergedAt": "2024-02-20T14:58:37Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "4cf0be8bee712c6892b3f5abf50cabbaf35da4e2"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "This looks good to me. ",
          "createdAt": "2024-02-20T07:48:41Z",
          "updatedAt": "2024-02-20T07:48:41Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 164,
      "id": "PR_kwDOFUmh7s5nMyon",
      "title": "Add references for actual IANA registries in Appendix B",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/164",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Note that I also changed subsection titles in this document to match the titles used on each IANA registry.\r\n\r\ncloses #157 .",
      "createdAt": "2024-02-18T00:54:07Z",
      "updatedAt": "2024-02-20T08:11:19Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "cbc4f05254a7170e57e3e06e24388882fe4cbf6d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-157",
      "headRefOid": "ac762d70a09d88e6272faf076c5e25318dabf2ab",
      "closedAt": "2024-02-20T08:11:19Z",
      "mergedAt": "2024-02-20T08:11:19Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "0ef30aa132d25d0753031a4cc393efc76db00f2c"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Looks good, I think we can merge this.",
          "createdAt": "2024-02-20T07:51:43Z",
          "updatedAt": "2024-02-20T07:51:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 165,
      "id": "PR_kwDOFUmh7s5nM1Os",
      "title": "Convert ambiguous \"datagrams\" and lower-case \"QUIC datagrams\" to QUIC DATAGRAMs.",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/165",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Note that we said \"datagrams are QUIC datagrams\", but a better way to handle this is to use upper-case \"DATAGRAM\" to mean QUIC DATAGRAMs.\r\n\r\nI didn't convert \"QUIC DATAGRAMs\" to something like \"DATAGRAM frames\", but that would be easy enough to do (now that I've removed most/all of the line breaks in the middle of sentences about DATAGRAMs). \r\n\r\nI note that there were some uses of terms like \"RoQ datagrams\". Please let me know if you don't think I handled them correctly. \r\n\r\ncloses #147 ",
      "createdAt": "2024-02-18T01:48:24Z",
      "updatedAt": "2024-02-21T02:19:17Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "035949f3332c438bc1753b42f3c4ad5c80ca2882",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-147",
      "headRefOid": "a4fe07eadf0b3c2999486710750190d0fa37e050",
      "closedAt": "2024-02-21T02:19:17Z",
      "mergedAt": "2024-02-21T02:19:17Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "0c57161a62be8489e35798a32192be94773b9ddc"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I think we can merge this. There are a few more cases of _RoQ datagram_, should we keep them or change them too, either in this or another PR?",
          "createdAt": "2024-02-20T08:10:26Z",
          "updatedAt": "2024-02-20T08:10:26Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think we can merge this. There are a few more cases of _RoQ datagram_, should we keep them or change them too, either in this or another PR?\r\n\r\nI think we should keep them, but I want to mention _RoQ datagram_ and _RoQ stream_ in the terminology section. Stay tuned, of course. ",
          "createdAt": "2024-02-20T15:04:10Z",
          "updatedAt": "2024-02-20T15:04:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5wvQ7m",
          "commit": {
            "abbreviatedOid": "931d572"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-20T19:44:14Z",
          "updatedAt": "2024-02-20T19:44:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 166,
      "id": "PR_kwDOFUmh7s5nVLAb",
      "title": "Add guidance on choosing streams and datagrams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/166",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #114",
      "createdAt": "2024-02-19T21:27:01Z",
      "updatedAt": "2024-02-20T18:38:07Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "cbc4f05254a7170e57e3e06e24388882fe4cbf6d",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-114",
      "headRefOid": "c197475a8eb860d01201b028946a1e21179e4d45",
      "closedAt": "2024-02-20T18:38:06Z",
      "mergedAt": "2024-02-20T18:38:06Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "035949f3332c438bc1753b42f3c4ad5c80ca2882"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - I think this is ready to review. My biggest question is \"did I put this in the right place?\". ",
          "createdAt": "2024-02-19T21:28:22Z",
          "updatedAt": "2024-02-19T21:28:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5wo7od",
          "commit": {
            "abbreviatedOid": "f9dbe02"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "I think it should be combined with section 3.1. We could move it somewhere else, but I think the text of what is now 3.1 should be close to the text added in this PR.",
          "createdAt": "2024-02-20T08:38:18Z",
          "updatedAt": "2024-02-20T08:53:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nAs noted in {{streams-and-datagrams}}, this specification does not take a position on using QUIC streams, QUIC DATAGRAMs, or some mixture of both, for any particular RoQ use case or application. It does seem useful to include observations that might guide implementers who will need to make choices about that.\r\n```",
              "createdAt": "2024-02-20T08:38:18Z",
              "updatedAt": "2024-02-20T08:53:33Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nOne implementation goal might be to minimize processing overhead, for applications that are migrating from RTP over UDP to RoQ. These applications don't rely on any transport protocol behaviors beyond UDP, which can be described as \"nothing beyond IP, except multiplexing\". They might be motivated by one or more of the advantages of encapsulating RTP in QUIC that are described in {{motivations}}, but they do not need any of the advantages that would apply when encapsulating RTP in QUIC streams. For these applications, simply placing each RTP packet in a QUIC DATAGRAM frame when it becomes available would be sufficient, with no QUIC streams at all.\r\n```",
              "createdAt": "2024-02-20T08:39:12Z",
              "updatedAt": "2024-02-20T08:53:33Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nAs noted in {{multiplexing}}, all RoQ streams and datagrams begin with a flow identifier. This allows a RoQ sender to begin by encapsulating related RTP packets in a stream and then switch to carrying them in QUIC DATAGRAMs, or vice versa. RoQ receivers need to be prepared to accept any valid RTP packet with a given flow identifier, whether it started by being encapsulated in QUIC streams or in QUIC DATAGRAMs, and RoQ receivers need to be prepared to accept RTP flows that switch from QUIC stream encapsulation to QUIC DATAGRAMs, or vice versa.\r\n```",
              "createdAt": "2024-02-20T08:42:00Z",
              "updatedAt": "2024-02-20T08:53:33Z"
            },
            {
              "originalPosition": 16,
              "body": "I think we don't need this paragraph. As noted before, a sender always has the option to switch between streams and datagrams, not only when connection migration happens. Also, a receiver must also always be prepared for receiving RTP in streams or datagrams.",
              "createdAt": "2024-02-20T08:47:57Z",
              "updatedAt": "2024-02-20T08:53:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5wuCY9",
          "commit": {
            "abbreviatedOid": "f9dbe02"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T17:59:50Z",
          "updatedAt": "2024-02-20T17:59:50Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "That's ... fair. I added this paragraph, and then realized that the sender was always in charge, not only during connection migration, but thought that distinguishing the two cases was useful. Actually, it's not. \t:thinking:",
              "createdAt": "2024-02-20T17:59:50Z",
              "updatedAt": "2024-02-20T17:59:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 167,
      "id": "PR_kwDOFUmh7s5nYdBG",
      "title": "Remove double period and space",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/167",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-20T11:13:31Z",
      "updatedAt": "2024-02-20T17:26:57Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0ef30aa132d25d0753031a4cc393efc76db00f2c",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/double-period",
      "headRefOid": "35035cf3fb69537b5542dec8cf2acb2ecfdca3b4",
      "closedAt": "2024-02-20T17:26:56Z",
      "mergedAt": "2024-02-20T17:26:56Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "00d0b28cfd648aa8e708f5cb785a5f4dd2b03b05"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5wtzWC",
          "commit": {
            "abbreviatedOid": "35035cf"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-20T17:26:47Z",
          "updatedAt": "2024-02-20T17:26:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 169,
      "id": "PR_kwDOFUmh7s5nYmmK",
      "title": "Clean up some terminology that is not actually used",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/169",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "*Delay-based* is not used and *Low-latency congestion control algorithm* is used only once. This commit moves the explanation to where it is used to avoid confusion, where a reader did not see the definition, because it is hidden in the terminology section.\r\n\r\n*Loss-based* is not used in the document.\r\n\r\n*QUIC congestion controller* is not used in the document.\r\n\r\n*RTP congestion controller* is not used in the document.\r\n\r\nIt was helpful to define these terms when writing the document, but I think listing them in the terminology section without using them may be more confusing than helpful.",
      "createdAt": "2024-02-20T11:36:58Z",
      "updatedAt": "2024-02-21T02:32:01Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "035949f3332c438bc1753b42f3c4ad5c80ca2882",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/remove-unused-terminology",
      "headRefOid": "18bf17476ea905f8918a06c110cd2231d97a77ab",
      "closedAt": "2024-02-21T02:32:00Z",
      "mergedAt": "2024-02-21T02:32:00Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "367d337650e91a231d4cfd8d44a67545c75541b7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5wt3rb",
          "commit": {
            "abbreviatedOid": "088cebe"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-20T17:35:53Z",
          "updatedAt": "2024-02-20T17:36:02Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I'd suggest \"might use, for example\", because I don't know that's true for all of them, but otherwise, this looks lovely. \r\n\r\nOne minor point - you said \"hidden in the terminology section\", and IIRC, I started adding subsections as part of the Introduction, before I realized that (in total) the terminology section would appear after NINE subsections. Does it make sense to you to move Section 1.2 (\"Motivations\") into its own top-level section, following the terminology section? ",
              "createdAt": "2024-02-20T17:35:53Z",
              "updatedAt": "2024-02-20T17:36:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5wvcpu",
          "commit": {
            "abbreviatedOid": "088cebe"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T20:05:04Z",
          "updatedAt": "2024-02-20T20:05:04Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Thanks, I updated the PR.\r\n\r\nYes, we could do that. But let's make a separate PR for that. I can prepare it.",
              "createdAt": "2024-02-20T20:05:04Z",
              "updatedAt": "2024-02-20T20:05:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 170,
      "id": "PR_kwDOFUmh7s5nZQHE",
      "title": "Remove out of context cross-reference",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/170",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-20T13:19:32Z",
      "updatedAt": "2024-02-20T17:38:35Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0ef30aa132d25d0753031a4cc393efc76db00f2c",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/remove-out-of-context-sentence",
      "headRefOid": "50d770f2fda609fe5dc3c11eb2c74190ac5eda5b",
      "closedAt": "2024-02-20T17:38:34Z",
      "mergedAt": "2024-02-20T17:38:34Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "30103adb2ae7d570fe0f5bb5d25170e4e7ccd8ee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5wt4xe",
          "commit": {
            "abbreviatedOid": "50d770f"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks fine to me. ",
          "createdAt": "2024-02-20T17:38:25Z",
          "updatedAt": "2024-02-20T17:38:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 172,
      "id": "PR_kwDOFUmh7s5nZY_I",
      "title": "Fix grammar",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/172",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-20T13:38:45Z",
      "updatedAt": "2024-02-20T17:39:46Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0ef30aa132d25d0753031a4cc393efc76db00f2c",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/incomplete-sentence",
      "headRefOid": "827559b489007b544ae2e477c2aa387a8bdabec6",
      "closedAt": "2024-02-20T17:39:46Z",
      "mergedAt": "2024-02-20T17:39:46Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "0b087fa5069125e8e77ba81d1a5bc0b0d367766e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5wt5Tv",
          "commit": {
            "abbreviatedOid": "827559b"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-20T17:39:37Z",
          "updatedAt": "2024-02-20T17:39:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 173,
      "id": "PR_kwDOFUmh7s5nZaSa",
      "title": "Remove cross reference to removed subsection",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/173",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-20T13:41:34Z",
      "updatedAt": "2024-02-20T17:40:53Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0ef30aa132d25d0753031a4cc393efc76db00f2c",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/xr-reports-reference",
      "headRefOid": "3553a4f7623d8bc6761eef6392078b1fc8dd852c",
      "closedAt": "2024-02-20T17:40:52Z",
      "mergedAt": "2024-02-20T17:40:52Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "b2521f721d68ab0f2384fb3cf10407a5286bd0d3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5wt567",
          "commit": {
            "abbreviatedOid": "3553a4f"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-20T17:40:46Z",
          "updatedAt": "2024-02-20T17:40:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 174,
      "id": "PR_kwDOFUmh7s5nZnyF",
      "title": "Remove non-RTP/RTCP protocol multiplexing",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/174",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "As discussed at the last interim meeting, this proposal removes multiplexing with non-RTP/RTCP protocols. The same features could be implemented by defining new Multiplexing schemes and respective ALPNs in other documents. That would have the advantage of not requiring a new protocol negotiation mechanism at a higher layer. It would also be easier to define multiplexing for known protocols rather than providing a general solution that works for every protocol that one might want to use.",
      "createdAt": "2024-02-20T14:12:07Z",
      "updatedAt": "2024-02-21T02:24:36Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0c57161a62be8489e35798a32192be94773b9ddc",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/remove-non-rtp-multiplexing",
      "headRefOid": "85aaa9e6b7bd1c5462a85b7dd725fc41b16c1851",
      "closedAt": "2024-02-21T02:24:35Z",
      "mergedAt": "2024-02-21T02:24:35Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "347dcf0191ce5df3c8135e9a905bbf70d71b5eec"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5wt-8L",
          "commit": {
            "abbreviatedOid": "e7b1638"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T17:52:01Z",
          "updatedAt": "2024-02-20T17:52:02Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "> Future extensions could further build on the flow identifier to multiplex RTP/RTCP with other protocols on the same connection.\r\n\r\nI think it's worth pointing out (as we have realized while working on this specification) that there's more to multiplexing than just disambiguating and demultiplexing. Perhaps \r\n\r\n> Future extensions could further build on the flow identifier to multiplex RTP/RTCP with other protocols on the same connection, **as long as these protocols can co-exist with RTP/RTCP without interfering with the ability of this connection to carry real-time media.** \r\n\r\nDoes that make sense? ",
              "createdAt": "2024-02-20T17:52:02Z",
              "updatedAt": "2024-02-20T17:52:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5wt_NR",
          "commit": {
            "abbreviatedOid": "e7b1638"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I left one comment (\"Do The Right Thing\"), but this is ready to merge without changes. ",
          "createdAt": "2024-02-20T17:52:39Z",
          "updatedAt": "2024-02-20T17:52:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s5wvfFH",
          "commit": {
            "abbreviatedOid": "e7b1638"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-20T20:10:01Z",
          "updatedAt": "2024-02-20T20:10:01Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Makes sense. I updated the PR.",
              "createdAt": "2024-02-20T20:10:01Z",
              "updatedAt": "2024-02-20T20:10:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 176,
      "id": "PR_kwDOFUmh7s5nk4mp",
      "title": "Move motivations section later in the draft",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/176",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "I actually moved it into Section 3. Let me know if that seems right.\r\n\r\ncloses #175",
      "createdAt": "2024-02-21T21:22:41Z",
      "updatedAt": "2024-02-22T15:13:13Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "367d337650e91a231d4cfd8d44a67545c75541b7",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-175",
      "headRefOid": "dd875983980503cafbbdf80d5dce2302356ffc1f",
      "closedAt": "2024-02-22T15:13:12Z",
      "mergedAt": "2024-02-22T15:13:12Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "249bfbb8e78f62077593de538fce7999ca9576c6"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "I didn't compare the old and new text, but assuming you only moved it to the new section without changing anything else, this is fine for me and can be merged.",
          "createdAt": "2024-02-22T10:54:51Z",
          "updatedAt": "2024-02-22T10:54:51Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> I didn't compare the old and new text, but assuming you only moved it to the new section without changing anything else, this is fine for me and can be merged.\r\n\r\nThat's all I did, on this one. ",
          "createdAt": "2024-02-22T15:13:07Z",
          "updatedAt": "2024-02-22T15:13:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 177,
      "id": "PR_kwDOFUmh7s5nk7l_",
      "title": "Clarify L4S dependencies for RoQ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/177",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #171",
      "createdAt": "2024-02-21T21:31:31Z",
      "updatedAt": "2024-02-22T15:10:59Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "367d337650e91a231d4cfd8d44a67545c75541b7",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "issue-171",
      "headRefOid": "0abf22637ab84ac964a93a2eef3705954961ae19",
      "closedAt": "2024-02-22T15:10:58Z",
      "mergedAt": "2024-02-22T15:10:58Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "06b7940555dcda98fe3f06e54f48b1825e87f766"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Looks good to me.",
          "createdAt": "2024-02-22T11:02:26Z",
          "updatedAt": "2024-02-22T11:02:26Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 178,
      "id": "PR_kwDOFUmh7s5oPojd",
      "title": "Add Futures section and change document category to \"exp\" (Experimental)",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/178",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "Closes #161",
      "createdAt": "2024-02-29T04:19:29Z",
      "updatedAt": "2024-02-29T15:13:54Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "249bfbb8e78f62077593de538fce7999ca9576c6",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "futures",
      "headRefOid": "80a52427970ffd981e8bb1af9a7d826e9ec43029",
      "closedAt": "2024-02-29T15:13:53Z",
      "mergedAt": "2024-02-29T15:13:53Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "97bc53ef26930af7922f3410a0e37d49f3f4fc7e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5xweZm",
          "commit": {
            "abbreviatedOid": "10d4cc5"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-29T10:37:39Z",
          "updatedAt": "2024-02-29T10:42:13Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\n* Possible guidelines for connection sharing between RoQ and non-RoQ flows, including guidance on the use of congestion control, scheduling, prioritization, and guidance on which ALPNs to use.\r\n```",
              "createdAt": "2024-02-29T10:37:39Z",
              "updatedAt": "2024-02-29T10:42:13Z"
            },
            {
              "originalPosition": 43,
              "body": "I would split this and move the part about ALPN up (see comment above). QUIC needs an ALPN, no matter whether the connection is established via ICE or not. And that ALPN could be `roq` or something else, as long as the document that specifies the ALPN clearly defines the application protocol.\r\n\r\n```suggestion\r\n* Guidance for using RoQ with NAT traversal solutions. This could use Interactive Connectivity Establishment (ICE) {{?RFC8445}} with QUIC or other NAT traversal solutions, e.g., using potential QUIC extensions.\r\n```",
              "createdAt": "2024-02-29T10:41:54Z",
              "updatedAt": "2024-02-29T10:42:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5xx5Ib",
          "commit": {
            "abbreviatedOid": "10d4cc5"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-29T13:35:46Z",
          "updatedAt": "2024-02-29T13:35:46Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "This is EXACTLY right. I'll look at the other possible topics, to see if they could/should be phrased more generally (we don't want to use specific individual drafts, we want to solve the problems those drafts are intended to solve - duh!). ",
              "createdAt": "2024-02-29T13:35:46Z",
              "updatedAt": "2024-02-29T13:35:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5xyAkK",
          "commit": {
            "abbreviatedOid": "10d4cc5"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-02-29T13:48:52Z",
          "updatedAt": "2024-02-29T13:48:52Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "This is good in theory, but in practice, \r\n\r\n> * Possible guidelines for connection sharing between RoQ and non-RoQ flows, including guidance on the use of congestion control, scheduling, prioritization, and guidance on which ALPNs to use.\r\n\r\noverlaps with \r\n\r\n> * Possible guidance for connection sharing between RoQ and non-RoQ flows.\r\n\r\nand \r\n\r\n> * Guidance for using RoQ with QUIC extensions mentioned in {{optional-extensions}} for using Interactive Connectivity Establishment (ICE) {{?RFC8445}} with QUIC, including guidance for coexistence between QUIC connections established using ALPNs and QUIC connections established using ICE.\r\n\r\nI'm going to use almost every word you suggested - I'll propose using them in different places. :upside_down_face:\r\n\r\n(which OUGHT to include at least congestion control, scheduling, prioritization).\r\n\r\nI'll also use \"guidance\" consistently (rather than a mixture of \"guidance\", \"guidelines and recommendations\", and \"guidelines\", which I intended to all mean the same thing).",
              "createdAt": "2024-02-29T13:48:52Z",
              "updatedAt": "2024-02-29T13:48:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 179,
      "id": "PR_kwDOFUmh7s5oPqdB",
      "title": "Remove speculations about ICE with QUIC",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/179",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "ICE is now mentioned in #178\r\n\r\ncloses #50",
      "createdAt": "2024-02-29T04:26:03Z",
      "updatedAt": "2024-02-29T15:15:43Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "249bfbb8e78f62077593de538fce7999ca9576c6",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "no-ICE",
      "headRefOid": "d7f68fff66db64baa9bdab9159e9b06a06da0f23",
      "closedAt": "2024-02-29T15:15:43Z",
      "mergedAt": "2024-02-29T15:15:43Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "4e95781c5f186a41c304bc581ca5b87091cc795b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5xwgvs",
          "commit": {
            "abbreviatedOid": "d7f68ff"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-29T10:42:34Z",
          "updatedAt": "2024-02-29T10:42:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 180,
      "id": "PR_kwDOFUmh7s5oTygw",
      "title": "Clarify use of the word transport parameters",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/180",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-02-29T15:33:57Z",
      "updatedAt": "2024-02-29T15:34:45Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "4e95781c5f186a41c304bc581ca5b87091cc795b",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/transport-parameters",
      "headRefOid": "7cdec058a8dbb41fa24b50bb81e4eae44e228776",
      "closedAt": "2024-02-29T15:34:44Z",
      "mergedAt": "2024-02-29T15:34:44Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "f9ef945553cadb800dc5dbaf9e4762f807fd6b64"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5xzDT7",
          "commit": {
            "abbreviatedOid": "7cdec05"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-29T15:34:29Z",
          "updatedAt": "2024-02-29T15:34:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 183,
      "id": "PR_kwDOFUmh7s5oUpJw",
      "title": "Resolve editor's notes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/183",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #182\r\n\r\nA PR for #181 will resolve one remaining Editor's note, in [12.2. ](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-12.2)[0-RTT considerations](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-0-rtt-considerations).",
      "createdAt": "2024-02-29T17:41:37Z",
      "updatedAt": "2024-03-04T16:10:14Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "f9ef945553cadb800dc5dbaf9e4762f807fd6b64",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "ed-notes",
      "headRefOid": "d7fbd338cd90b5a44aadb16c091e115bdc69a29d",
      "closedAt": "2024-03-04T16:10:13Z",
      "mergedAt": "2024-03-04T16:10:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "4b1f6221348d179058e67bc00ebe220dad54fd2a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5x4Qo6",
          "commit": {
            "abbreviatedOid": "d7fbd33"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-01T08:27:24Z",
          "updatedAt": "2024-03-01T08:27:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 184,
      "id": "PR_kwDOFUmh7s5oYUd8",
      "title": "Describe considerations for early data with 0-RTT",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/184",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #181",
      "createdAt": "2024-03-01T08:15:32Z",
      "updatedAt": "2024-03-08T15:49:17Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "f9ef945553cadb800dc5dbaf9e4762f807fd6b64",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "early-data",
      "headRefOid": "d5ec48a2268bca55ee664fa45ec34de1d0aee400",
      "closedAt": "2024-03-08T15:49:17Z",
      "mergedAt": "2024-03-08T15:49:17Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "8295ab47420724f0c512b92c1b156333d641660a"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Looking at [RFC 9000 Section 6.1](https://datatracker.ietf.org/doc/html/rfc9000#name-sending-version-negotiation), we think QUIC endpoints should (\"eventually\") stop sending 0-RTT packets and send Initial packets instead, but \"eventually\" is not a great plan for RTP. We should mention this in the RoQ specification. \r\n\r\nLooking [RFC 9001 section 4.6.1](https://datatracker.ietf.org/doc/html/rfc9001#name-enabling-0-rtt), we think that the way a QUIC endpoint knows that the other QUIC endpoint is prepared to do 0-RTT is by the presence of a max_early_data_size parameter with the sentinel value, or when the 0-RTT recipient rejects the 0-RTT packet as described in RFC 9001 Section 4.6.1.\r\n\r\nWe don't want to teach people QUIC in the RoQ specification, but this is probably obscure enough to point out to RoQ implementers. ",
          "createdAt": "2024-03-07T15:30:18Z",
          "updatedAt": "2024-03-07T15:31:35Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "We can also add a note for implementers that we aren't defining any new transport parameterrs that a QUIC implementation should remember from previous connections, so that adding connections between two endpoints with the same connection ID can be invisible to the RoQ application. If additional out of band signaling happens, that needs to be visible to the RoQ application. ",
          "createdAt": "2024-03-07T15:37:46Z",
          "updatedAt": "2024-03-07T15:37:46Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5x4SYR",
          "commit": {
            "abbreviatedOid": "c85471f"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-01T08:31:57Z",
          "updatedAt": "2024-03-01T08:32:02Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Should we add/keep the note that specific 0-RTT keying material to prevent replays across sessions could be exchanged in out-of-band signaling?",
              "createdAt": "2024-03-01T08:31:57Z",
              "updatedAt": "2024-03-01T08:32:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5x4n1p",
          "commit": {
            "abbreviatedOid": "c85471f"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-01T09:19:05Z",
          "updatedAt": "2024-03-01T09:19:06Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "That sounds reasonable to me. One additional question - are there other concerns about using 0-RTT, beyond the risk of accepting early data from replayed QUIC packets? ",
              "createdAt": "2024-03-01T09:19:06Z",
              "updatedAt": "2024-03-01T09:19:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5yEw-k",
          "commit": {
            "abbreviatedOid": "c85471f"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-04T09:40:37Z",
          "updatedAt": "2024-03-04T09:40:37Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I think another concern is that the endpoints may need to remember application-specific data. But I don't think there is anything RoQ-specific except the usual signaling for RTP session setup, which is not part of the QUIC connection setup.",
              "createdAt": "2024-03-04T09:40:37Z",
              "updatedAt": "2024-03-04T09:40:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 185,
      "id": "PR_kwDOFUmh7s5pXFMH",
      "title": "Fix some spelling mistakes",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/185",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "I chose American spelling over British (e.g., *acknowledgments* over *acknowledgements*) to be consistent, except for *cancellation* and *cancelled*, because that would mean we have to change error code names. We may still want to do that, but better in a separate PR to keep this one editorial only.",
      "createdAt": "2024-03-12T10:51:54Z",
      "updatedAt": "2024-03-18T23:05:38Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "983c242984e64f768933195fa79f9a476621ab2a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/spelling",
      "headRefOid": "e9ae1b5eea97635ac3968ad5e9b1619a86939ef4",
      "closedAt": "2024-03-18T11:07:13Z",
      "mergedAt": "2024-03-18T11:07:13Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "b711eb73e97bc298edc818a4356854489bce19a8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5zKlwp",
          "commit": {
            "abbreviatedOid": "36d551e"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "For the question about American vs. British spelling of \"acknowledgment\", for what it's worth, we have a section title in the document that uses the American spelling. If we're not matching something else (like an RFC that uses British spellings), I think the American spelling is a good place to start!",
          "createdAt": "2024-03-12T19:18:38Z",
          "updatedAt": "2024-03-12T19:21:45Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "For these 3GPP URNs, we might or might not want to change the spellings, because I think these match [entries in 3GPP documents](https://www.3gpp.org/3gpp-groups/core-network-terminals-ct/ct-wg1/uniform-resource-identifier-uri-list) that spell it as \"signalling\". I don't know if that really matters, and if it does, the RFC Editor is going to be the arbiter of taste anyway, but I should ask while I'm reviewing the PR, right? ",
              "createdAt": "2024-03-12T19:18:39Z",
              "updatedAt": "2024-03-12T19:21:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5zykGC",
          "commit": {
            "abbreviatedOid": "36d551e"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T11:06:03Z",
          "updatedAt": "2024-03-18T11:06:03Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "Good point, I reverted these and also the *Generic negative acknowledgement* above.",
              "createdAt": "2024-03-18T11:06:03Z",
              "updatedAt": "2024-03-18T11:06:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5z5WZL",
          "commit": {
            "abbreviatedOid": "36d551e"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T23:05:38Z",
          "updatedAt": "2024-03-18T23:05:38Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "Thanks! It really does take teamwork ... ",
              "createdAt": "2024-03-18T23:05:38Z",
              "updatedAt": "2024-03-18T23:05:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 186,
      "id": "PR_kwDOFUmh7s5pi3-L",
      "title": "Minor editorial tweak",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/186",
      "state": "MERGED",
      "author": "JonathanLennox",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-03-13T19:19:39Z",
      "updatedAt": "2024-11-08T03:54:29Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "8295ab47420724f0c512b92c1b156333d641660a",
      "headRepository": "JonathanLennox/rtp-over-quic-draft",
      "headRefName": "patch-1",
      "headRefOid": "c01b68173cffe49bdbcb918762c6a21831f10dc5",
      "closedAt": "2024-03-18T10:58:54Z",
      "mergedAt": "2024-03-18T10:58:54Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "983c242984e64f768933195fa79f9a476621ab2a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s5zv2Md",
          "commit": {
            "abbreviatedOid": "c01b681"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T03:40:39Z",
          "updatedAt": "2024-03-18T03:40:39Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That's an EXCELLENT point. Thanks, @JonathanLennox!",
              "createdAt": "2024-03-18T03:40:39Z",
              "updatedAt": "2024-03-18T03:40:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5zv2Ny",
          "commit": {
            "abbreviatedOid": "c01b681"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-18T03:40:46Z",
          "updatedAt": "2024-03-18T03:40:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s5zygns",
          "commit": {
            "abbreviatedOid": "c01b681"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-18T10:58:44Z",
          "updatedAt": "2024-03-18T10:58:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 189,
      "id": "PR_kwDOFUmh7s5rEzr5",
      "title": "Improve Future Directions section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/189",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #187",
      "createdAt": "2024-03-28T16:13:50Z",
      "updatedAt": "2024-04-09T18:18:33Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "b711eb73e97bc298edc818a4356854489bce19a8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix-futures",
      "headRefOid": "752902c97d5bb1304892747e9fff9aaa808dfe58",
      "closedAt": "2024-04-09T18:18:32Z",
      "mergedAt": "2024-04-09T18:18:32Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "bb1cc4be57557c06b4b18aea3ca40f2ae1156432"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s52Yu1D",
          "commit": {
            "abbreviatedOid": "752902c"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-08T11:55:10Z",
          "updatedAt": "2024-04-08T11:55:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 190,
      "id": "PR_kwDOFUmh7s5rdZlU",
      "title": "Clarify usage of \"RTP\" and \"RTCP\" in the document",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/190",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #188",
      "createdAt": "2024-04-02T16:17:21Z",
      "updatedAt": "2024-04-09T18:56:02Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "bb1cc4be57557c06b4b18aea3ca40f2ae1156432",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "clarify-rtp/rtcp",
      "headRefOid": "02fc457637ce408ac1693a8167b957239e600281",
      "closedAt": "2024-04-09T18:56:01Z",
      "mergedAt": "2024-04-09T18:56:01Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "f5fb5975661a69b728871e99e43c2fd4a7d592c2"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "I've applied @mengelbart's review comments, and am merging now. ",
          "createdAt": "2024-04-09T18:55:54Z",
          "updatedAt": "2024-04-09T18:55:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s52YveY",
          "commit": {
            "abbreviatedOid": "d66a6d7"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-08T11:56:34Z",
          "updatedAt": "2024-04-08T11:59:56Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\nAs a baseline, the document does not expect more than a standard QUIC implementation\r\n```",
              "createdAt": "2024-04-08T11:56:34Z",
              "updatedAt": "2024-04-08T11:59:56Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\n## What's in Scope for this Document {#in-scope}\r\n```",
              "createdAt": "2024-04-08T11:57:31Z",
              "updatedAt": "2024-04-08T11:59:56Z"
            },
            {
              "originalPosition": 3,
              "body": "I agree with the other changes, but I don't think it is necessary to change the title. RTCP is part of RTP in RFC 3550, which only has RTP in its title.",
              "createdAt": "2024-04-08T11:59:52Z",
              "updatedAt": "2024-04-08T11:59:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s52msH0",
          "commit": {
            "abbreviatedOid": "d66a6d7"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-09T18:28:37Z",
          "updatedAt": "2024-04-09T18:28:37Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "> I agree with the other changes, but I don't think it is necessary to change the title. RTCP is part of RTP in RFC 3550, which only has RTP in its title.\r\n\r\n@mengelbart - thank you for pushing back on this change. My intention going into this PR was to make it obvious that what we said about encapsulation applied to both RTP Data Transfer Protocol and RTP Control Protocol, but after I added the Note to the Reader about this, I ought to have reversed the proposed change to the title. \r\n\r\nAnd I am slightly cursing under my breath that \"RTCP\" caught on, but \"RTDTP\" never did! :face_with_spiral_eyes:",
              "createdAt": "2024-04-09T18:28:37Z",
              "updatedAt": "2024-04-09T18:28:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 191,
      "id": "PR_kwDOFUmh7s5sKxue",
      "title": "I missed one lower-case \"document\"",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/191",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-09T19:03:17Z",
      "updatedAt": "2024-04-09T19:04:06Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "f5fb5975661a69b728871e99e43c2fd4a7d592c2",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "SillyEditorialError",
      "headRefOid": "3030946f75ad3107db02443e782a411935a30e1f",
      "closedAt": "2024-04-09T19:04:05Z",
      "mergedAt": "2024-04-09T19:04:05Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "0cdb3e990828de45d45430c25126e977396d3cc3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 192,
      "id": "PR_kwDOFUmh7s5sbCjW",
      "title": "Apply clean-up comments",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/192",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #163",
      "createdAt": "2024-04-12T01:34:49Z",
      "updatedAt": "2024-04-15T22:33:20Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "0cdb3e990828de45d45430c25126e977396d3cc3",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "clean-up",
      "headRefOid": "3fee951388e9b7b5ab02ebbc275ffc4b627acd93",
      "closedAt": "2024-04-15T22:33:20Z",
      "mergedAt": "2024-04-15T22:33:20Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "866afdb7ba16a1e39c77fa372e83a6acf9b25a74"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s53KkP4",
          "commit": {
            "abbreviatedOid": "f5edea5"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-13T13:04:31Z",
          "updatedAt": "2024-04-13T13:16:12Z",
          "comments": [
            {
              "originalPosition": 357,
              "body": "I think *handshake* is better, because it is used in ClientHello and ServerHello.",
              "createdAt": "2024-04-13T13:04:31Z",
              "updatedAt": "2024-04-13T13:16:12Z"
            },
            {
              "originalPosition": 510,
              "body": "```suggestion\r\nIf a RoQ sender discovers that a packet is no longer needed and knows that the packet has not yet been successfully and completely transmitted, it can use RESET\\_STREAM to tell the RoQ receiver that the RoQ sender is discarding the packet.\r\n```",
              "createdAt": "2024-04-13T13:07:38Z",
              "updatedAt": "2024-04-13T13:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s53WFSG",
          "commit": {
            "abbreviatedOid": "f5edea5"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-15T22:26:07Z",
          "updatedAt": "2024-04-15T22:26:07Z",
          "comments": [
            {
              "originalPosition": 357,
              "body": "You're right about that. ",
              "createdAt": "2024-04-15T22:26:07Z",
              "updatedAt": "2024-04-15T22:26:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 198,
      "id": "PR_kwDOFUmh7s5skV0E",
      "title": "Add pacing recommendation reference to RFC9002",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/198",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-13T14:01:47Z",
      "updatedAt": "2024-04-17T13:42:40Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "7af76888e3d5344543b884cf95bbd59b2ac55fed",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/add-pacing-reference",
      "headRefOid": "6741f12916c7545192690f172c87c0e9fa974d39",
      "closedAt": "2024-04-17T13:42:40Z",
      "mergedAt": "2024-04-17T13:42:40Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "45ecc98c22189e9c9daab98e3a6497c88f8be235"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s53cFZD",
          "commit": {
            "abbreviatedOid": "a0c3e83"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-16T14:38:57Z",
          "updatedAt": "2024-04-16T14:39:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I don't think this is quite right, because RFC9002 is only one congestion control algorithm (that's why I didn't look there, for a reference for what QUIC recommends :upside_down_face:) - RFC9000 calls {{Section 7.7 of !RFC9002}} an exemplary congestion control algorithm. \r\n\r\nI think it is good to add a reference to RFC9002 here, but maybe something like \r\n\r\n> The currently proposed congestion control algorithms for real-time communications (e.g., SCReAM and NADA) provide such pacing mechanisms, and the QUIC exemplary congestion control algorithm ({{Section 7.7 of !RFC9002}}) recommends pacing for senders.",
              "createdAt": "2024-04-16T14:38:57Z",
              "updatedAt": "2024-04-16T14:39:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s53dMQ_",
          "commit": {
            "abbreviatedOid": "a0c3e83"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-16T16:36:14Z",
          "updatedAt": "2024-04-16T16:36:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Sounds good, I'll update it!",
              "createdAt": "2024-04-16T16:36:14Z",
              "updatedAt": "2024-04-16T16:36:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 199,
      "id": "PR_kwDOFUmh7s5skWD_",
      "title": "Replace RoQ/non-RoQ with real-time non-real-time",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/199",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "closes #197 ",
      "createdAt": "2024-04-13T14:05:36Z",
      "updatedAt": "2024-04-16T16:26:35Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "f9d71a5c1ee909bc96b9a88807b0e5e6bd347b40",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/rt-non-rt",
      "headRefOid": "7fd3897151c1c639c534acde9977663dddf901c1",
      "closedAt": "2024-04-16T16:26:34Z",
      "mergedAt": "2024-04-16T16:26:34Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "7af76888e3d5344543b884cf95bbd59b2ac55fed"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s53WKVd",
          "commit": {
            "abbreviatedOid": "7fd3897"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for handling this one!",
          "createdAt": "2024-04-15T22:44:53Z",
          "updatedAt": "2024-04-15T22:44:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 200,
      "id": "PR_kwDOFUmh7s5s01Nw",
      "title": "This clarifies and corrects uses of \"peer\" and \"receiver\"",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/200",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #195",
      "createdAt": "2024-04-16T16:23:28Z",
      "updatedAt": "2024-04-17T13:39:11Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "866afdb7ba16a1e39c77fa372e83a6acf9b25a74",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix-peers",
      "headRefOid": "58b49bce60246359e4a75da1e15e7969029d845f",
      "closedAt": "2024-04-17T13:39:10Z",
      "mergedAt": "2024-04-17T13:39:10Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "622fc1715afa2300d870a0ba8843041e410d371c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s53dPDN",
          "commit": {
            "abbreviatedOid": "58b49bc"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-16T16:42:28Z",
          "updatedAt": "2024-04-16T16:42:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 201,
      "id": "PR_kwDOFUmh7s5s07Ze",
      "title": "Remove reference to NATs/Firewalls",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/201",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-16T16:38:55Z",
      "updatedAt": "2024-04-16T19:08:41Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "7af76888e3d5344543b884cf95bbd59b2ac55fed",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/nats-and-firewalls",
      "headRefOid": "97d99873379948f44c917819b2a3a2d1b1a87e98",
      "closedAt": "2024-04-16T19:08:40Z",
      "mergedAt": "2024-04-16T19:08:40Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3ff14581dc6c2a5baa13f09a9b0c6efc221fd845"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s53d6-U",
          "commit": {
            "abbreviatedOid": "97d9987"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is perfect. ",
          "createdAt": "2024-04-16T18:20:35Z",
          "updatedAt": "2024-04-16T18:20:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 202,
      "id": "PR_kwDOFUmh7s5s1rZT",
      "title": "Clarify usage of \"peer-to-peer\" term",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/202",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #194",
      "createdAt": "2024-04-16T18:58:09Z",
      "updatedAt": "2024-04-17T13:44:03Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "7af76888e3d5344543b884cf95bbd59b2ac55fed",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix-peer-to-peer",
      "headRefOid": "73a67dc99b2d0b4e3c52978bce438e34259d6fa0",
      "closedAt": "2024-04-17T13:44:03Z",
      "mergedAt": "2024-04-17T13:44:02Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "4b1bc7bd1f61aa7b5779c0e4752f7b7233e50a04"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s53eP9-",
          "commit": {
            "abbreviatedOid": "73a67dc"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-16T19:09:37Z",
          "updatedAt": "2024-04-16T19:09:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 204,
      "id": "PR_kwDOFUmh7s5tEeTF",
      "title": "Clarify new QUIC streams may be client- or server-initiated",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/204",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [
        "NextInterim"
      ],
      "body": "fixes #203\r\n\r\nI also scanned for usages of the words \"client\" and \"server\" in the document. I didn't define these terms in Section 2, but I did make sure that they are qualified when they appear in the document. ",
      "createdAt": "2024-04-18T16:00:24Z",
      "updatedAt": "2024-04-19T02:21:25Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "4b1bc7bd1f61aa7b5779c0e4752f7b7233e50a04",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix-QUIC-client-server",
      "headRefOid": "2314e69ff743553627eaacfb5ddb662a36605639",
      "closedAt": "2024-04-19T02:21:25Z",
      "mergedAt": "2024-04-19T02:21:25Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "7f9671dff72619cbe0b1affb2403a234176c293b"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "This looks good to me, thanks!",
          "createdAt": "2024-04-18T20:10:46Z",
          "updatedAt": "2024-04-18T20:10:46Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s53ywWS",
          "commit": {
            "abbreviatedOid": "2314e69"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-18T20:10:55Z",
          "updatedAt": "2024-04-18T20:10:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 205,
      "id": "PR_kwDOFUmh7s5tXB_A",
      "title": "Replace DTLS with SRTP",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/205",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "From [RFC 9147](https://www.rfc-editor.org/rfc/rfc9147#section-3)\r\n\r\n> telephony utilizes DTLS for key establishment and the Secure Real-time Transport Protocol (SRTP) for protection of data\r\n\r\nI think it is better to reference SRTP here.",
      "createdAt": "2024-04-22T14:34:29Z",
      "updatedAt": "2024-04-23T16:16:32Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "29e44e8e6fb49a64515976e7aec244d16792e871",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/dtls-srtp",
      "headRefOid": "5dd83f1a97dce656c36333271aae176dd0242fc0",
      "closedAt": "2024-04-23T16:16:32Z",
      "mergedAt": "2024-04-23T16:16:32Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "94a4ff1dcca26999edd3f5e89ec5ae8621001fc0"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart - thanks for pushing back on this one. I rephrased this text during my lightning-round review, and I think I said too much, to make my point, which was intended to be \r\n\r\n- we've used UDP since forever, but\r\n- we've been adding underlying transports for nearly that long. \r\n\r\nSo, I'm thinking that instead of \r\n\r\n> The Real-time Transport Protocol (RTP) [[RFC3550](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC3550)] is generally used to carry real-time media for conversational media sessions, such as video conferences, across the Internet. Since RTP requires real-time delivery and is tolerant to packet losses, the default underlying transport protocol has historically been UDP [[RFC0768](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC0768)]. More recently, DTLS [RFC9147] has been used as an underlying transport in order to secure the media exchange, and other transport protocols such as TCP [RFC9293] and TLS [RFC8446] have been used as fallbacks, when UDP is blocked for some reason.\r\n\r\nI SHOULD have said \r\n\r\n> The Real-time Transport Protocol (RTP) [[RFC3550](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC3550)] is generally used to carry real-time media for conversational media sessions, such as video conferences, across the Internet. Since RTP requires real-time delivery and is tolerant to packet losses, the default underlying transport protocol has historically been UDP [[RFC0768](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC0768)], **but a large variety of other underlying transport protocols have been defined for various reasons (e.g., securing media exchange, or providing a fallback when UDP is blocked along a network path). This document describes RTP over QUIC, providing one more underlying transport protocol. The reasons for using QUIC as an underlying transport protocol are given in {{motivations}}}.**",
          "createdAt": "2024-04-23T15:29:16Z",
          "updatedAt": "2024-04-23T15:29:16Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thanks, that sounds good. I updated the PR and will merge it now.",
          "createdAt": "2024-04-23T16:16:19Z",
          "updatedAt": "2024-04-23T16:16:19Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 206,
      "id": "PR_kwDOFUmh7s5tXE9i",
      "title": "Fix 5-tuple sentence",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/206",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "At least one *(* is missing, but since 5-tuple is explained before, I think we can just omit it.",
      "createdAt": "2024-04-22T14:40:27Z",
      "updatedAt": "2024-04-23T16:07:14Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "7f9671dff72619cbe0b1affb2403a234176c293b",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/5-tuple",
      "headRefOid": "08991d29a2141df5ed15efb1c957b0ea7548a261",
      "closedAt": "2024-04-23T16:07:14Z",
      "mergedAt": "2024-04-23T16:07:14Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "038f64f16a4b4aa32c06c728a871c86dcbce3334"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s54QlAi",
          "commit": {
            "abbreviatedOid": "08991d2"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Oh, yes. PLEASE make this change! The repetition is painful to read. ",
          "createdAt": "2024-04-23T15:31:25Z",
          "updatedAt": "2024-04-23T15:31:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 207,
      "id": "PR_kwDOFUmh7s5tX9gC",
      "title": "Fix target bitrate font/style",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/207",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-22T16:27:27Z",
      "updatedAt": "2024-04-23T16:07:43Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "7f9671dff72619cbe0b1affb2403a234176c293b",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/target-bitrate",
      "headRefOid": "64839d57f0e34e2c8687682e180f0d62076d5306",
      "closedAt": "2024-04-23T16:07:43Z",
      "mergedAt": "2024-04-23T16:07:43Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "8dcf7bacbac15abbfeb6ff983d3d90be0a53cee0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s54QrGu",
          "commit": {
            "abbreviatedOid": "64839d5"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Yes. This term appears as a variable in SCReAM, but doesn't even appear in NADA, so we can't reasonably use the term in this form. Good catch!",
          "createdAt": "2024-04-23T15:41:17Z",
          "updatedAt": "2024-04-23T15:41:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 208,
      "id": "PR_kwDOFUmh7s5tYUDX",
      "title": "Finish intro sentence",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/208",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-22T17:16:34Z",
      "updatedAt": "2024-04-23T16:10:54Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "8dcf7bacbac15abbfeb6ff983d3d90be0a53cee0",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/future-work-intro",
      "headRefOid": "87209cf604c1d39be9fed97ca5a9ec7e905c7698",
      "closedAt": "2024-04-23T16:10:53Z",
      "mergedAt": "2024-04-23T16:10:53Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "29e44e8e6fb49a64515976e7aec244d16792e871"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s54QwLX",
          "commit": {
            "abbreviatedOid": "9da4c92"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I shortened this a bit, but you're right - the sentence just trailed off, because it was followed by a bulleted list, but then I added subsection headers, which made that look wrong. ",
          "createdAt": "2024-04-23T15:50:02Z",
          "updatedAt": "2024-04-23T15:52:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThis document describes RoQ in sufficient detail that an implementer can build a RoQ application, but we recognize that additional work is likely, after we have sufficient experience with RoQ to guide that work ({{futures-impl-deploy}}) and and as new QUIC extensions become available ({{futures-new-ext}}).\r\n```",
              "createdAt": "2024-04-23T15:50:02Z",
              "updatedAt": "2024-04-23T15:52:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 209,
      "id": "PR_kwDOFUmh7s5tf5pd",
      "title": "Remove duplicate *and*",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/209",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-23T16:33:29Z",
      "updatedAt": "2024-04-23T16:33:36Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "94a4ff1dcca26999edd3f5e89ec5ae8621001fc0",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/double-and",
      "headRefOid": "e92942cf15218f1092f0c4a210f4db37d8d52034",
      "closedAt": "2024-04-23T16:33:35Z",
      "mergedAt": "2024-04-23T16:33:35Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "45980a4fcf7b3d692a28b517ce98be587adacdb7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 211,
      "id": "PR_kwDOFUmh7s5tv5cd",
      "title": "Correct link and title for IEEE 1733",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/211",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "fixes #210",
      "createdAt": "2024-04-25T16:23:11Z",
      "updatedAt": "2024-04-25T17:08:25Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "45980a4fcf7b3d692a28b517ce98be587adacdb7",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix-1733",
      "headRefOid": "51ece9a292f3c61eedf57f55c744e014d52bb854",
      "closedAt": "2024-04-25T17:08:24Z",
      "mergedAt": "2024-04-25T17:08:24Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "719b42390e3162c866c9cf9ef3e947b47beed802"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s54llwt",
          "commit": {
            "abbreviatedOid": "51ece9a"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-25T17:08:12Z",
          "updatedAt": "2024-04-25T17:08:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 212,
      "id": "PR_kwDOFUmh7s5t-x8p",
      "title": "Fix a race condition cause by out of band signaling",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/212",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Signaling flow IDs may happen out-of-band and cause a race condition when flow IDs are received before signaling is complete.\r\n\r\nThe solution is modeled after WebTransport's handling of incoming streams and datagrams described in https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3-09#section-4.5",
      "createdAt": "2024-04-29T08:32:26Z",
      "updatedAt": "2024-05-03T10:37:36Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "b683d1c84254a97108d9dc5cf02cff3fc836a03a",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/unknown-flow-id-race-condition",
      "headRefOid": "0ad8e290f35b992fc2448c7b3f5dcb6e4d848085",
      "closedAt": "2024-05-03T10:37:36Z",
      "mergedAt": "2024-05-03T10:37:36Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "66d7e8d1d47ec02bf533de927ecd15c4b213d9b8"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "> I'm slightly concerned that we're still finding \"QUIC datagram(s)\" in the text - I thought I'd upshifted all of those in a previous PR. Maybe I missed some?\r\n\r\nI think I introduced some new ones in this PR. I updated it and also applied the other suggestions you made.",
          "createdAt": "2024-05-03T10:37:25Z",
          "updatedAt": "2024-05-03T10:37:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s55UUeo",
          "commit": {
            "abbreviatedOid": "669407a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm slightly concerned that we're still finding \"QUIC datagram(s)\" in the text - I thought I'd upshifted all of those in a previous PR. Maybe I missed some? ",
          "createdAt": "2024-05-02T10:27:18Z",
          "updatedAt": "2024-05-03T10:27:50Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "My comments below assume that buffering RoQ streams and RoQ datagrams carrying real-time RTP payloads is the Right Thing To Do. We can talk about whether that's desirable, because buffering real-time RTP will cause the RTP session to start out with an overestimated RTT and will introduce jitter as the RTP sender responds to the actual RTT after the RTP receiver starts to provide feedback, but we should at least think about that, because RTP is designed to tolerate packet loss, so admitting a burst of RTP packets to an application when the receiver finally knows what to do with the flow identifier might not be our best option. \r\n\r\nMy comments also assume that some RoQ receivers might buffer RoQ streams and datagrams while signaling completes, and others might not, so I introduced \"buffering endpoint\", to make that distinction. ",
              "createdAt": "2024-05-02T10:27:18Z",
              "updatedAt": "2024-05-02T11:30:32Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nor datagram with a given flow identifier can arrive before the signaling\r\n```",
              "createdAt": "2024-05-02T10:28:30Z",
              "updatedAt": "2024-05-02T11:30:32Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nfinished. In that case, an endpoint cannot associate the stream or\r\n```",
              "createdAt": "2024-05-02T10:29:13Z",
              "updatedAt": "2024-05-02T11:30:32Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\ndatagram with the corresponding RTP stream. The endpoint can buffer streams\r\n```",
              "createdAt": "2024-05-02T10:33:23Z",
              "updatedAt": "2024-05-02T11:30:32Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nthe corresponding RTP stream. To avoid resource exhaustion, the buffering endpoint MUST\r\n```\r\nFor this to be a normative SHOULD, we should have some situation in mind where it makes sense for a receiver to buffer streams and datagrams without setting a limit. Do we have such a situation in mind? ",
              "createdAt": "2024-05-02T10:37:11Z",
              "updatedAt": "2024-05-02T11:30:32Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nstreams exceeds the limit on buffered streams, the endpoint MUST send a STOP_SENDING with the\r\n```",
              "createdAt": "2024-05-02T10:38:41Z",
              "updatedAt": "2024-05-02T11:30:32Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nto send STOP_SENDING. If the number of buffered datagrams exceeds the limit on buffered datagrams, the\r\n```",
              "createdAt": "2024-05-02T10:39:38Z",
              "updatedAt": "2024-05-02T11:30:32Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nendpoint MUST drop a datagram. It is an implementation's choice which datagram\r\n```",
              "createdAt": "2024-05-02T10:40:12Z",
              "updatedAt": "2024-05-02T11:30:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 213,
      "id": "PR_kwDOFUmh7s5t-yZX",
      "title": "Apply J\u00f6rg's review comments",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/213",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-29T08:33:34Z",
      "updatedAt": "2024-05-03T10:27:15Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "719b42390e3162c866c9cf9ef3e947b47beed802",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/joerg-review-comments",
      "headRefOid": "d3f6423c99fe32eb90f2d4387a267bf1e70b6ae7",
      "closedAt": "2024-05-03T10:19:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s55VCVd",
          "commit": {
            "abbreviatedOid": "d3f6423"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "See comments in #214 for overlapping PRs.",
          "createdAt": "2024-05-02T12:02:52Z",
          "updatedAt": "2024-05-02T12:02:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 214,
      "id": "PR_kwDOFUmh7s5t-0D_",
      "title": "Fix streams terminology",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/214",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Using *STREAM frames* the same way we use *DATAGRAM frames* created some issues. For example, the stream encapsulation section could be misunderstood as *every QUIC stream frame starts with a flow identifier*, which is incorrect. I hope this PR makes it more clear.\r\n\r\nThis PR should wait for #213 before we merge it.",
      "createdAt": "2024-04-29T08:37:45Z",
      "updatedAt": "2024-05-03T13:56:16Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "719b42390e3162c866c9cf9ef3e947b47beed802",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/streams-terminology",
      "headRefOid": "613e56ac80fe0d9471994d9fdcc6b95b32b74a02",
      "closedAt": "2024-05-03T10:19:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s55UdOE",
          "commit": {
            "abbreviatedOid": "613e56a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "If I understand correctly, we are moving from the term \"congestion avoidance\" to \"congestion control\" in this document. That's fine, but I'd suggest adding that to the Note to the Reader about this, replacing \r\n\r\n> Note to the Reader: the meaning of the terms \"congestion control\" and \"rate adaptation\" in the IETF community have evolved over the decades since \"slow start\" and \"congestion avoidance\" were added as mandatory to implement in TCP, in Section 4.2.2.15 of [RFC1122].  \r\n\r\nwith \r\n\r\n> Note to the Reader: the meaning of the terms **\"congestion avoidance\",** \"congestion control\", and \"rate adaptation\" in the IETF community have evolved over the decades since \"slow start\" and \"congestion avoidance\" were added as mandatory to implement in TCP, in Section 4.2.2.15 of [RFC1122]. ",
          "createdAt": "2024-05-02T10:46:19Z",
          "updatedAt": "2024-05-02T11:26:37Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nThis prevents a sender from overwhelming the capacity of a path between a sender and a receiver, which might cause intermediaries on the path to drop packets before they arrive at the receiver.\r\n```",
              "createdAt": "2024-05-02T10:46:19Z",
              "updatedAt": "2024-05-02T11:25:28Z"
            },
            {
              "originalPosition": 107,
              "body": "```suggestion\r\nSome of these differences can be detected by QUIC itself, while other differences must be described to QUIC based on policy, etc. Possible RTP implementation strategies for path selection and utilization are not discussed in this document. Path scheduling APIs to let applications control these mechanisms are a topic for future research and might need further specification in future documents.\r\n```",
              "createdAt": "2024-05-02T10:49:39Z",
              "updatedAt": "2024-05-02T11:25:28Z"
            },
            {
              "originalPosition": 125,
              "body": "```suggestion\r\nThere is no default relative priority between DATAGRAM frames with respect to each other, and there is no default priority between DATAGRAM frames and QUIC STREAM frames. QUIC implementations can present an API to allow applications to assign relative priorities within a QUIC connection, but this is not mandated by the standard and might not be present in all implementations.\r\n```",
              "createdAt": "2024-05-02T10:51:41Z",
              "updatedAt": "2024-05-02T11:25:28Z"
            },
            {
              "originalPosition": 237,
              "body": "```suggestion\r\nis delivered to the receiving application in order, so that a receiving application can read a complete RTP packet from\r\n```",
              "createdAt": "2024-05-02T10:55:53Z",
              "updatedAt": "2024-05-02T11:25:28Z"
            },
            {
              "originalPosition": 249,
              "body": "Why is this changed to a normative \"MAY\"? But if we are thinking about normative behavior, why would an endpoint not close the connection immediately? It seems odd to notice a mismatch at signaling time, but not give the peer endpoint any indication that all is not right, until the peer endpoint tries to use the QUIC extension. My understanding of [Section 12.4 in RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000#name-frames-and-frame-types) is that the result would be a connection error of type FRAME_ENCODING_ERROR, and that doesn't point directly to a signaling/negotiation mismatch, which is the real problem. ",
              "createdAt": "2024-05-02T11:11:13Z",
              "updatedAt": "2024-05-02T11:25:28Z"
            },
            {
              "originalPosition": 338,
              "body": "```suggestion\r\nacknowledged after all STREAM frames that carried parts of the RTP packet were\r\n```",
              "createdAt": "2024-05-02T11:14:00Z",
              "updatedAt": "2024-05-02T11:25:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s55dtol",
          "commit": {
            "abbreviatedOid": "613e56a"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-03T10:14:09Z",
          "updatedAt": "2024-05-03T10:14:09Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "At the end of [section 3.2](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-3.2), we say that an application can use streams instead. FRAME_ENCODING_ERROR would only happen if the QUIC stack is sending datagrams even though the datagram extension was not negotiated at connection establishment. In that case, I would expect the QUIC stack to return an error when the application is trying to send datagrams.",
              "createdAt": "2024-05-03T10:14:09Z",
              "updatedAt": "2024-05-03T10:14:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s55fI_l",
          "commit": {
            "abbreviatedOid": "613e56a"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-03T13:56:15Z",
          "updatedAt": "2024-05-03T13:56:16Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "> At the end of [section 3.2](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#section-3.2), we say that an application can use streams instead. FRAME_ENCODING_ERROR would only happen if the QUIC stack is sending datagrams even though the datagram extension was not negotiated at connection establishment. In that case, I would expect the QUIC stack to return an error when the application is trying to send datagrams.\r\n\r\nOh, right. This is a variation of the same conversation we were having at the Hackathon in San Francisco - sorry for MY confusion. \r\n\r\nOne thing that doesn't help me stay unconfused, is that we are talking about a specific extension here, but the text sounds more general. At the end of [Section 3.2](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-rtp-with-quic-streams-quic-), we explain this more clearly than we're saying in this text. The point in Section 3.2 is \"you have a decision to make. How badly do you need to use DATAGRAMs?\" \r\n\r\n```suggestion\r\nIf the DATAGRAM extension was negotiated using a signaling protocol, but was not also negotiated during the resulting QUIC handshake, an endpoint can close the connection with the ROQ\\_EXPECTATION\\_UNMET error code.\r\n```\r\n\r\n",
              "createdAt": "2024-05-03T13:56:15Z",
              "updatedAt": "2024-05-03T13:56:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 215,
      "id": "PR_kwDOFUmh7s5uHdsR",
      "title": "Move the error handling section before the sections on considerations for Congestion Control, API, etc.",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/215",
      "state": "CLOSED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-04-30T09:18:36Z",
      "updatedAt": "2024-05-03T10:27:15Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "719b42390e3162c866c9cf9ef3e947b47beed802",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/swap-error-section",
      "headRefOid": "b246e459e63106721969c4b8e71c8e4737882e0c",
      "closedAt": "2024-05-03T10:20:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s55U6T1",
          "commit": {
            "abbreviatedOid": "b246e45"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm approving just the parts of this PR that moves the error handling section, and I agree moving it is an excellent thing to do. \r\n\r\nI'm seeing some of the same changes here as in https://github.com/mengelbart/rtp-over-quic-draft/pull/214/files, and I commented on some of those changes there. Could you make sure that the resulting merged document reflects my comments in 214?\r\n\r\n(I'm really confused, because the commit names in this PR sound like they should have been in #213 and/or #214. I'm going to look at #213 now, and if I see anything that makes me more confused, or less confused, I'll circle back here and tell you)",
          "createdAt": "2024-05-02T11:44:11Z",
          "updatedAt": "2024-05-02T11:44:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 216,
      "id": "PR_kwDOFUmh7s5udRSY",
      "title": "Review comments from J\u00f6rg",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/216",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This replaces #213, #214, and #215. It includes all of those commits plus some changes following @SpencerDawkins comments in those PRs. Sorry for the mixup...",
      "createdAt": "2024-05-03T10:19:16Z",
      "updatedAt": "2024-05-03T10:25:37Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "719b42390e3162c866c9cf9ef3e947b47beed802",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/joerg-review-comments2",
      "headRefOid": "1457cd1deda2bac712082431d7f11929f6467836",
      "closedAt": "2024-05-03T10:25:36Z",
      "mergedAt": "2024-05-03T10:25:36Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "b683d1c84254a97108d9dc5cf02cff3fc836a03a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 217,
      "id": "PR_kwDOFUmh7s5ueg3O",
      "title": "Remove sentence that should have been removed PR 212",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/217",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-03T13:56:05Z",
      "updatedAt": "2024-05-03T14:02:42Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "66d7e8d1d47ec02bf533de927ecd15c4b213d9b8",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/remove-old-unknown-flow-id-error",
      "headRefOid": "670938fc6721b1742271d9b76c8155a43b8172e5",
      "closedAt": "2024-05-03T14:02:41Z",
      "mergedAt": "2024-05-03T14:02:41Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "94d18d06e2a3be8eef6f1f7669fd178cca4439d5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s55fMDs",
          "commit": {
            "abbreviatedOid": "670938f"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-03T14:02:31Z",
          "updatedAt": "2024-05-03T14:02:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 218,
      "id": "PR_kwDOFUmh7s5ufewp",
      "title": "Clarify ROQ_EXPECTATION_UNMET usage",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/218",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-03T16:22:23Z",
      "updatedAt": "2024-05-08T07:02:29Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "94d18d06e2a3be8eef6f1f7669fd178cca4439d5",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/expectation-unmet",
      "headRefOid": "dd40c785239ed0e332ef048bd23af9543f276afc",
      "closedAt": "2024-05-08T07:02:28Z",
      "mergedAt": "2024-05-08T07:02:28Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "aac10f35930688fd06dd2509d8e796dd5d4e6fd4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s553fzJ",
          "commit": {
            "abbreviatedOid": "dd40c78"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "That's perfect! ",
          "createdAt": "2024-05-08T04:09:26Z",
          "updatedAt": "2024-05-08T04:09:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 220,
      "id": "PR_kwDOFUmh7s5wc4gs",
      "title": "Update implementation experience",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/220",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-05-24T11:18:29Z",
      "updatedAt": "2024-06-05T09:05:09Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "aac10f35930688fd06dd2509d8e796dd5d4e6fd4",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/implementation-experience",
      "headRefOid": "6a5b28517cd6e1a35e93667f97386a45ae171d54",
      "closedAt": "2024-06-05T09:05:09Z",
      "mergedAt": "2024-06-05T09:05:09Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "f411a39b67bbd78ce0abee003633524556894c0b"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "@SpencerDawkins pointed me to [RFC 7942](https://datatracker.ietf.org/doc/html/rfc7942). Following the guidance from that RFC, I moved the section to the main document, included the template for each implementation, and added a note to remove the section before publication.",
          "createdAt": "2024-05-25T10:56:14Z",
          "updatedAt": "2024-05-25T10:56:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s57-RYB",
          "commit": {
            "abbreviatedOid": "f317211"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice work!",
          "createdAt": "2024-05-27T03:17:34Z",
          "updatedAt": "2024-05-27T03:49:35Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nDescription:\r\n```",
              "createdAt": "2024-05-27T03:17:34Z",
              "updatedAt": "2024-05-27T03:49:36Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\nconnections, and managing RTP sessions. Applications choose whether to\r\n```",
              "createdAt": "2024-05-27T03:20:52Z",
              "updatedAt": "2024-05-27T03:49:36Z"
            },
            {
              "originalPosition": 94,
              "body": "```suggestion\r\n: The implementer reports they have no experience with the following:\r\n\r\n* Using RoQ with QUIC connections during path changes, whether due to QUIC connection migration or Multipath Extension for QUIC. As described in {{futures-new-ext}}, we expect future work on this topic.\r\n* Influence of default priorities of QUIC implementations between streams and\r\n  DATAGRAMs on the performance of RTCP. As described in {{futures-impl-deploy}}, we expect future work on this topic.\r\n* DATAGRAMs that are queued (and thus delayed) or dropped on expiration before\r\n  being transmitted due to congestion. As described in {{futures-impl-deploy}}, we expect future work on this topic\r\n* Translating between RoQ and RTP over UDP. As described in {{topologies}}, RoQ can be used to connect to some RTP middleboxes using some topologies, and these middleboxes might be connecting RoQ endpoints and non-RoQ endpoints, so will need to translate between RoQ and RTP over UDP. \r\n* Performance impacts of multiplexing many RTP sessions on a single QUIC connection. As described in {{futures-impl-deploy}}, we expect future work on this topic\r\n```\r\nSo, what I'm thinking is, this section could map pretty closely onto the rest of the document, and especially to {#futures}. If that makes sense, we might use {#futures} as a checklist, to name things that haven't been implemented or tested yet. \r\n\r\nDoes that make sense? ",
              "createdAt": "2024-05-27T03:45:03Z",
              "updatedAt": "2024-05-27T03:49:36Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n: The library supports sending and receiving RTP and RTCP packets using QUIC\r\nstreams and QUIC DATAGRAMs, and supports multiplexing using flow identifiers. Applications\r\n```",
              "createdAt": "2024-05-27T03:47:20Z",
              "updatedAt": "2024-05-27T03:49:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s58n4fs",
          "commit": {
            "abbreviatedOid": "6858853"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "You handled my suggestion about pointing to {{futures}} perfectly. Thank you for that. \r\n\r\nI missed the other two \"Descritption\" nits - my bad. \r\n\r\nNow that I'm looking at an almost-empty Implementation Experience section, I wonder if you might add one or two points that would help someone else who wants to do their own implementation, that aren't explained in the body of the specification. One item might be to explain that RoQ relies on out-of-band solutions for connection setup, and since there's not a current RoQ SDP specification, you statically configured the connection information to allow testing. \r\n\r\nThat might be useful if we wanted to ask the chairs to Request Publication while we're waiting on RoQ SDP. ",
          "createdAt": "2024-05-31T13:23:52Z",
          "updatedAt": "2024-05-31T13:33:30Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nDescription:\r\n```",
              "createdAt": "2024-05-31T13:23:52Z",
              "updatedAt": "2024-05-31T13:33:30Z"
            },
            {
              "originalPosition": 154,
              "body": "```suggestion\r\nDescription:\r\n```",
              "createdAt": "2024-05-31T13:24:20Z",
              "updatedAt": "2024-05-31T13:33:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 221,
      "id": "PR_kwDOFUmh7s5xine0",
      "title": "Fill out BBC gst-roq implementation section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/221",
      "state": "MERGED",
      "author": "samhurst",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on the AVTcore interim call yesterday, I've tried to fill out the gst-roq part in the Implementation Experience section.",
      "createdAt": "2024-06-05T11:28:24Z",
      "updatedAt": "2024-06-05T14:01:40Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "f411a39b67bbd78ce0abee003633524556894c0b",
      "headRepository": "samhurst/rtp-over-quic-draft",
      "headRefName": "bbc-gst-roq",
      "headRefOid": "54fbcf9a85c84245f569c485c09bb3ba8df40698",
      "closedAt": "2024-06-05T14:01:40Z",
      "mergedAt": "2024-06-05T14:01:40Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "38b4bd9220e5af662ab81c37794e63fa9308c913"
      },
      "comments": [
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thank you @samhurst!",
          "createdAt": "2024-06-05T14:01:36Z",
          "updatedAt": "2024-06-05T14:01:36Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 222,
      "id": "PR_kwDOFUmh7s5xsg2w",
      "title": "Remove signaling dependency",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/222",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "@joerg-ott @SpencerDawkins could you please take a look at this? I tried to capture everything that was discussed in the meeting on Tuesday, but I'm not sure if this really solves all the problem(s) or if it introduces new issues...",
      "createdAt": "2024-06-06T15:19:31Z",
      "updatedAt": "2024-06-21T14:56:43Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "38b4bd9220e5af662ab81c37794e63fa9308c913",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "fix/signaling-dependency-and-buffering",
      "headRefOid": "4e1ae7c04162987f136538ec945864ad79036a85",
      "closedAt": "2024-06-21T14:56:42Z",
      "mergedAt": "2024-06-21T14:56:42Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "f905fdd231c51395cb75e2bd0b41d2f5ac98d6ed"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "@mengelbart, I'd suggest creating a new issue :grinning: with the points you are addressing from discussion at the interim meeting. I'll comment on the comments from @samhurst, but I suspect that this PR has enough interaction with what we're currently calling sdp-roq, based on last week's discussions, that we really do need to up-level ,in order to make the right changes in THIS draft, and my experience with GitHub is that discussing what a PR is trying to do and discussing the changes proposed to do it, isn't as productive as discussing what a PR will be trying to do in an issue. \r\n\r\nI haven't gone through the YouTube recording from the interim meeting carefully (yet)  for our presentations, but I'll be doing that, and updating the minutes for both presentations, today or tomorrow. \r\n\r\n@samhurst, thank you for following our work! You're seeing the current text with newer eyes than mine, @joerg-ott's, and maybe even @mengelbart's, and it's helpful to hear about anything you see that doesn't seem clear, correct, or useful. ",
          "createdAt": "2024-06-10T11:43:24Z",
          "updatedAt": "2024-06-10T11:54:04Z"
        },
        {
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "body": "Thanks, @Spencer! I created Issue #223 with a list of points that came up in the discussion and which I tried to resolve in this PR.",
          "createdAt": "2024-06-10T12:06:11Z",
          "updatedAt": "2024-06-10T12:06:11Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thanks, @spencer! I created Issue #223 with a list of points that came up in the discussion and which I tried to resolve in this PR.\r\n\r\nExcellent! I suggest that we hold off for a day or two while I figure out what REALLY happened during our sessions at the meeting (which includes looking at the YouTube recordings, and at the chat, and updating the minutes), and then refocus later this week. \r\n\r\nDoes that make sense to people? ",
          "createdAt": "2024-06-10T12:14:33Z",
          "updatedAt": "2024-06-10T12:14:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s59T97D",
          "commit": {
            "abbreviatedOid": "e0f2159"
          },
          "author": "samhurst",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for making this CR. Overall this looks fine from what we discussed on Tuesday, but here's a couple of small editorial suggests that I would make.",
          "createdAt": "2024-06-06T15:56:58Z",
          "updatedAt": "2024-06-06T16:00:52Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nof buffered DATAGRAMs exceeds the limit on buffered DATAGRAMs, the endpoint MUST\r\ndrop a DATAGRAM frame. It is an implementation's choice which DATAGRAMs to drop.\r\n```",
              "createdAt": "2024-06-06T15:58:55Z",
              "updatedAt": "2024-06-06T16:00:52Z"
            },
            {
              "originalPosition": 37,
              "body": "I would use the correct RFC 2119 wording here:\r\n\r\n```suggestion\r\nthe stream or DATAGRAM with the corresponding RTP stream. The endpoint MAY\r\nbuffer streams and DATAGRAMs using an unknown flow identifier until they can be\r\n```",
              "createdAt": "2024-06-06T15:59:52Z",
              "updatedAt": "2024-06-06T16:00:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s59ZZFX",
          "commit": {
            "abbreviatedOid": "e0f2159"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-07T07:11:32Z",
          "updatedAt": "2024-06-07T07:11:32Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Uppercase DATAGRAM is defined in the terminology section as referring to a QUIC DATAGRAM frame because we tried to avoid confusion between QUIC *frames* and media *frames*.",
              "createdAt": "2024-06-07T07:11:32Z",
              "updatedAt": "2024-06-07T07:11:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s59ZccL",
          "commit": {
            "abbreviatedOid": "e0f2159"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-07T07:19:24Z",
          "updatedAt": "2024-06-07T07:19:24Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "I used non-RFC 2119 language here because it is nothing that a peer needs to be prepared for. Some time ago, we removed a lot of *SHOULD*s and some *MAY*s so I would like to avoid adding more new ones unless it is necessary. @SpencerDawkins and @joerg-ott, what do you think?",
              "createdAt": "2024-06-07T07:19:24Z",
              "updatedAt": "2024-06-07T07:19:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s59c2xb",
          "commit": {
            "abbreviatedOid": "e0f2159"
          },
          "author": "joerg-ott",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-07T14:20:46Z",
          "updatedAt": "2024-06-07T14:20:46Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Agree with Mathis. This paragraph gives implementation guidance that does not affect normative protocol behavior. The actions are of local significance only.",
              "createdAt": "2024-06-07T14:20:46Z",
              "updatedAt": "2024-06-07T14:20:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s59nxNe",
          "commit": {
            "abbreviatedOid": "e0f2159"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-10T11:52:42Z",
          "updatedAt": "2024-06-10T11:52:42Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Yeah, and it's actually worse than what @mengelbart said. From [the current draft](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-terminology-and-notation):\r\n\r\n>Datagram:\r\nThe term \"datagram\" is ambiguous. Without a qualifier, \"datagram\" could refer to a UDP packet, **or** a QUIC DATAGRAM frame, as defined in QUIC's unreliable DATAGRAM extension [[RFC9221](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#RFC9221)], **or** an RTP packet encapsulated in UDP, **or** an RTP packet capsulated in QUIC DATAGRAM frame. This document uses the uppercase \"DATAGRAM\" to refer to a QUIC DATAGRAM frame and the term RoQ datagram as a short form of \"RTP packet encapsulated in a QUIC DATAGRAM frame\".\r\n\r\nWe might consider adding an issue for \"things that have surprised readers in the past\". \r\n\r\n- There are some terms that we use, that really do require the reader to look them up in the terminology section. This is one of them. And I note that unqualified \"frame\" doesn't appear in the terminology section - maybe it should.",
              "createdAt": "2024-06-10T11:52:42Z",
              "updatedAt": "2024-06-10T11:52:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s59n6zN",
          "commit": {
            "abbreviatedOid": "e0f2159"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-10T12:11:48Z",
          "updatedAt": "2024-06-10T12:11:48Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Warning, I'm a retired AD and still a [BCP14](https://datatracker.ietf.org/doc/bcp14/) pedant ... \r\n\r\nWhat @mengelbart and @joerg-ott  are describing is a bunch of changes that we made based on my previous comments (trying to limit the use of BCP14 language to an absolute minimum), for two reasons. \r\n\r\n- As noted, the point of BCP14 language is to describe what a receiver MUST be prepared to deal with, and that includes when a sender does something besides what it SHOULD do. That's the difference between SHOULD and MAY - we are supposed to analyze the reasons behind a SHOULD, and the actions a receiver ought to take if the sender doesn't do that. \r\n\r\n For some reason, RFC2119 also included MAY/OPTIONAL, which doesn't have much to do with interoperation (I can't remember which AD I'm paraphrasing, but \"an implementation MAY do a LOT of things that a receiver has to deal with, and saying that using BCP14 language isn't helpful\".  \r\n\r\n- In the specific case of this draft, we're targeting Experimental, with a planned advance to Standards Track when we have more implementation (and perhaps even deployment) experience. We tried to minimize the use of normative language, just to focus on the bare minimum that an implementation needs to be prepared to deal with. \r\n\r\nIf a receiver buffers at least some media with surprising flow IDs, but doesn't buffer all media with surprising flow IDs for ever, the *RTP sender* probably can't figure that out. The receiving user can tell that, of course, but that's what we're trying to provide a warning about. \r\n\r\nIf we do create an issue about [surprises for readers](https://github.com/mengelbart/rtp-over-quic-draft/pull/222#discussion_r1633121881), the way we're using BCP14 language should probably be included in that list!",
              "createdAt": "2024-06-10T12:11:48Z",
              "updatedAt": "2024-06-10T12:17:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5_HPfX",
          "commit": {
            "abbreviatedOid": "e0f2159"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-21T13:00:20Z",
          "updatedAt": "2024-06-21T13:00:20Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I note that @samhurst's suggestion also fixed \"a DATAGRAMs\" - we should take care of that as well!",
              "createdAt": "2024-06-21T13:00:20Z",
              "updatedAt": "2024-06-21T13:00:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s5_HXCl",
          "commit": {
            "abbreviatedOid": "e0f2159"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-21T13:15:59Z",
          "updatedAt": "2024-06-21T13:15:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 225,
      "id": "PR_kwDOFUmh7s5zMwmB",
      "title": "Update order and institution",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/225",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-06-21T15:48:46Z",
      "updatedAt": "2024-07-05T09:00:36Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "f905fdd231c51395cb75e2bd0b41d2f5ac98d6ed",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "update-authors",
      "headRefOid": "68fed25066bae74087beb31aa727d4252ba0f8cb",
      "closedAt": "2024-07-05T09:00:35Z",
      "mergedAt": "2024-07-05T09:00:35Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "3f18d8ec7934edbc5dafd022b0fa52dc62908104"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s6AwmPL",
          "commit": {
            "abbreviatedOid": "68fed25"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Mathis, of course switching the author order for you and Joerg will be fine with me! ",
          "createdAt": "2024-07-05T08:25:56Z",
          "updatedAt": "2024-07-05T08:25:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 227,
      "id": "PR_kwDOFUmh7s52hYbd",
      "title": "Add RTCP overhead considerations for streams/datagrams",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/227",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-25T23:16:21Z",
      "updatedAt": "2024-10-20T19:00:07Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3f18d8ec7934edbc5dafd022b0fa52dc62908104",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/rtcp-overhead-considerations",
      "headRefOid": "242d0d811264839ab70fcf78f41257826593b60e",
      "closedAt": "2024-10-20T19:00:05Z",
      "mergedAt": "2024-10-20T19:00:05Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "010cea52fec2edc86943ba7eff644c39c598d047"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "So I think there are a couple of things that needs to be considered here for the RTCP sending.\r\n\r\nWhen it comes to RTCP bandwidth calculations and handling of avg_rtcp_size I think we can start considering [RFC 3890](https://datatracker.ietf.org/doc/rfc3890/) and its statement that RTCP indifference between IPv4 and IPv6 does not matter, a difference in many cases that are between 28 and 48 bytes of overhead per RTCP compound packet. I think removing the overhead completely from avg_rtcp_size will create issues in interworking with session legs that use RTP over IP/UDP etc. I think adding the actual overhead per transmission of RTCP compound packets to avg_rtcp_size will ensure that RoQ endpoints sends within more reasonable bounds when interworking. I think IP+UDP+QUIC packet headers + DATAGRAM header would be a reasonable overhead to add. If not added and RoQ endpoint have 0 overhead their RTCP transmission rate could easily become 50% or more higher. \r\n\r\nWorth noting is that [RFC 5506] (https://datatracker.ietf.org/doc/rfc5506/) for reduced size RTCP, i.e. without SR/RR and SDES items are calculated into avg_rtcp_size. Thus, if one sends significant amount of reduced sized RTCP packets the avg_rtcp_size value can become fairly small. Where regular RTCP packets will have RTCP compound packet sizes of larger than 100 bytes, the reduced size packets can easily be just a few 10 of bytes. \r\n\r\nIf one doesn't have an interop case with non RoQ endpoints this would not be a problem from fairness and possible timeout perspective. The issue is that an RoQ endpoint will not know that this is the case, and explicit signalling would be needed. And that signalling may change mid session when new endpoint joins a multi-party session. So I think it would be better to include some overhead that is the average/common per transmission. \r\n\r\nI will note that the timeout for others parties are mostly a red-herring assuming AVPF with reasonable parameters. If the T-rr-intervall is configured to a non-zero value and which is larger than actual Td with more than a factor two (or rather the unfairness ratio between calculating entities) or so then timeout will not be an issue. For non AVPF sessions the unfairness realtionship in calculated Td must close to a factor of 5 to potentially trigger a erronous timeout of an SSRC. \r\n\r\nNext, I think we need to have a discussion about how one best configure RTCP sending for RoQ. \r\nAssuming AVPF controls I think one can actually run the RTCP transmission with t-rr-interval to how often one want regular reports and maintaing sessions memebership info. Then configure the RTCP bandwidth quite high for the session. The issue remain with dynamic changes of session bandwidth and that RTCP doesn't scale. But as RTCP will be congestion controlled in RoQ case, one at least could add a recommendation to delay scheduling of the next if there is a queue RTCP packets, possible also if there are RTP packets queue, but this I think needs a bit more thought. Depending on ones API to the QUIC stack there would actually be good to rather have an event driven transmission of RTCP so that RTP stack notice need to send RTCP packet, gives stack an size estimate, gets a notification when it can transmit and then generates the packet. This only matters if the delay between requesting transmission and actual transmission is long enough that new RTCP messages or values would make sense. However, I think limiting the RTCP if the QUIC congestion control says no would be good. The problem is that if the actual CC limit is preventing sending RTCP at least each T-rr-interval one gets into timeout country. However, I think that is fairly uncommon if T-rr-interval is 1 or more seconds, and actual RTCP bandwidth gives you a regular Td on ms scale.   \r\n\r\n",
          "createdAt": "2024-08-26T09:16:43Z",
          "updatedAt": "2024-08-26T09:16:43Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s6L9IuO",
          "commit": {
            "abbreviatedOid": "7853d97"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-04T13:23:54Z",
          "updatedAt": "2024-10-04T13:53:30Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nRTCP was originally defined to be used with UDP, which implies (1) \r\nthe only buffering present would be at the IP interface level, so that transmission timing is largely under the control of the application, and (2) that the overhead, *avg_rtcp_size*, used to\r\n```",
              "createdAt": "2024-10-04T13:23:54Z",
              "updatedAt": "2024-10-04T13:59:30Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\npackets and subject to QUIC congestion control. This means that a sending timestamp\r\n```",
              "createdAt": "2024-10-04T13:25:09Z",
              "updatedAt": "2024-10-04T13:53:30Z"
            },
            {
              "originalPosition": 32,
              "body": "I'm not sure how this is different from RT(C)P over UDP. Isn't this last sentence also true for that? I guess the difference is that QUIC can do more violence to the measured network layer RTT than UDP would have done (for both DATAGRAMs and streams, but especially for streams), but I'm not sure how that affects the awareness of what RTCP is actually measuring between the two transports?",
              "createdAt": "2024-10-04T13:27:05Z",
              "updatedAt": "2024-10-10T16:07:27Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nIt is thus suggested that application developers recognize that per-RTCP packet overhead will always be an estimate, and include IP, UDP, QUIC, and DATAGRAM header sizes as a conservative heuristic. While this value may not be precisely accurate, it follows the example of RTP over UDP in {{!RFC3550}}, which includes the RTP and UDP header sizes, and adding the additional QUIC and DATAGRAM header sizes avoids the immediate problem of significantly understating avg_rtcp_size, resulting in an underestimate of the cost of sending additional RTCP reports.  \r\n```\r\nStolen from @gloinul - thank you, Magnus!",
              "createdAt": "2024-10-04T13:32:55Z",
              "updatedAt": "2024-10-10T16:22:52Z"
            },
            {
              "originalPosition": 64,
              "body": "```suggestion\r\nTo keep the complexity under control, it is again suggested that application developers recognize that per-RTCP packet overhead will always be an estimate, and these estimates should include plausible values for IP, UDP, QUIC, and QUIC STREAM frame header sizes. While this value may not be precisely accurate, it follows the example of RoQ over DATAGRAMs in {{rtcp-over-datagrams}}}, and again avoids the immediate problem of significantly understating avg_rtcp_size, resulting in an underestimate of the cost of sending additional RTCP reports.  \r\n```\r\nI'm adapting a @gloinul comment about datagrams - please let me know if I got this wrong. ",
              "createdAt": "2024-10-04T13:41:49Z",
              "updatedAt": "2024-10-10T16:33:14Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\n## RTCP Considerations {#RTCP-considerations}\r\n```",
              "createdAt": "2024-10-04T13:49:52Z",
              "updatedAt": "2024-10-04T13:53:30Z"
            },
            {
              "originalPosition": 78,
              "body": "```suggestion\r\nUsing the same QUIC primitives for both RTP and\r\nRTCP will be safer than mixing QUIC primitives - for example, using QUIC streams to carry RTP media payloads and QUIC DATAGRAMs to carry RTCP, or vice versa. If an application uses both streams and datagrams to selectively obtain\r\nreliable transmission for some RTP media payloads but not for others, it is strongly suggested that the application developer\r\nknowingly choose which RTT observations they are interested in, while remaining aware of the advice included in {{RTCP-considerations}}\r\n```",
              "createdAt": "2024-10-04T13:50:53Z",
              "updatedAt": "2024-10-04T13:53:30Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\n### RTCP over QUIC streams {#rtcp-over-streams}\r\n```",
              "createdAt": "2024-10-04T13:53:11Z",
              "updatedAt": "2024-10-04T13:53:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s6Mt_S3",
          "commit": {
            "abbreviatedOid": "7853d97"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "We definitely should ping @gloinul to see if I understood his comments!",
          "createdAt": "2024-10-10T16:24:17Z",
          "updatedAt": "2024-10-10T16:37:32Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\n\r\n```\r\n(This is just removing the Editor's Note)",
              "createdAt": "2024-10-10T16:24:18Z",
              "updatedAt": "2024-10-10T16:37:32Z"
            },
            {
              "originalPosition": 67,
              "body": "```suggestion\r\n\r\n```\r\nThis is just removing the Editor's note, which refers to a previous Editor's note that no longer exists.",
              "createdAt": "2024-10-10T16:35:57Z",
              "updatedAt": "2024-10-10T16:37:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s6Mzf5A",
          "commit": {
            "abbreviatedOid": "7853d97"
          },
          "author": "gloinul",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-11T08:56:35Z",
          "updatedAt": "2024-10-11T08:56:35Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Well, in most cases when running RTP/RTCP directly over UDP the only extra latency is the time it takes from having entered the application layer timestamp until an IP/UDP packet with the payload can be created. That is normally quite short when one is running directly on UDP sockets.",
              "createdAt": "2024-10-11T08:56:35Z",
              "updatedAt": "2024-10-11T08:56:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s6Nb2ps",
          "commit": {
            "abbreviatedOid": "ed50b53"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T15:33:53Z",
          "updatedAt": "2024-10-16T15:33:53Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I think this should also include QUIC STREAM frames.",
              "createdAt": "2024-10-16T15:33:53Z",
              "updatedAt": "2024-10-16T15:33:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s6Nb3X0",
          "commit": {
            "abbreviatedOid": "ed50b53"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T15:35:05Z",
          "updatedAt": "2024-10-16T15:35:05Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "oh, no, sorry, STREAMs are covered below...",
              "createdAt": "2024-10-16T15:35:05Z",
              "updatedAt": "2024-10-16T15:35:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 228,
      "id": "PR_kwDOFUmh7s5-2f3F",
      "title": "Acknowledge Gurtej",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/228",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-16T15:50:24Z",
      "updatedAt": "2024-10-17T19:30:56Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "3f18d8ec7934edbc5dafd022b0fa52dc62908104",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/ack-gurtej",
      "headRefOid": "96c6d329e2b37d21fd5c88f9b4433b698ea1603a",
      "closedAt": "2024-10-17T19:30:55Z",
      "mergedAt": "2024-10-17T19:30:55Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "cdfe93bd7eb0b8c884aa584f191a1820c778b9fc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s6NoHre",
          "commit": {
            "abbreviatedOid": "96c6d32"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for noticing this!",
          "createdAt": "2024-10-17T19:30:23Z",
          "updatedAt": "2024-10-17T19:30:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 229,
      "id": "PR_kwDOFUmh7s5_POpn",
      "title": "Overhead estimation",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/229",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-10-20T18:53:06Z",
      "updatedAt": "2024-10-21T18:44:45Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "010cea52fec2edc86943ba7eff644c39c598d047",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "feat/overhead-estimation",
      "headRefOid": "15ef07e193f1d11fea0c1515b54d154fa63b3288",
      "closedAt": "2024-10-21T18:44:43Z",
      "mergedAt": "2024-10-21T18:44:43Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "4d30cfce35abb9b60ccc07261260a4d1523d12a4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s6OAxIs",
          "commit": {
            "abbreviatedOid": "66bfbf3"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is useful and well presented - good job! ",
          "createdAt": "2024-10-21T16:02:14Z",
          "updatedAt": "2024-10-21T16:02:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s6OBCc6",
          "commit": {
            "abbreviatedOid": "66bfbf3"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "@mengelbart - I moved a comma, and added a couple of connecting words. I just wanted to make sure you saw that. I'll go ahead and merge (based on my previous Approve. ",
          "createdAt": "2024-10-21T16:32:26Z",
          "updatedAt": "2024-10-21T16:36:26Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nexactly correct, since it does not take into account additional complications such as that RTP packets may be\r\n```",
              "createdAt": "2024-10-21T16:32:26Z",
              "updatedAt": "2024-10-21T16:36:26Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nthan a single FRAME, so that the RTCP overhead could thus be the shared overhead of\r\n```",
              "createdAt": "2024-10-21T16:33:34Z",
              "updatedAt": "2024-10-21T16:36:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 231,
      "id": "PR_kwDOFUmh7s6AH7iW",
      "title": "Update draft-ietf-avtcore-rtp-over-quic.md",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/231",
      "state": "MERGED",
      "author": "SpencerDawkins",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "SpencerDawkins"
      ],
      "labels": [],
      "body": "closes #230 ",
      "createdAt": "2024-10-28T16:08:05Z",
      "updatedAt": "2025-02-06T21:05:04Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "802f3cf400ac312de88361fd43f9ba0f7180d78e",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "disambiguate-packet",
      "headRefOid": "ca01f3bac83c48b861fa1c2155f49fb9d126e7ad",
      "closedAt": "2025-02-06T21:05:03Z",
      "mergedAt": "2025-02-06T21:05:03Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "bf190f17e0378352ca4d801b54126c1da991a081"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s6PasNG",
          "commit": {
            "abbreviatedOid": "01b7cad"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "This looks good to me. Do we need to check if there are any occurrences of \"packet\" that need to be updated?",
          "createdAt": "2024-10-30T19:46:56Z",
          "updatedAt": "2024-10-30T19:46:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s6a9fup",
          "commit": {
            "abbreviatedOid": "cef4813"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "@mengelbart - this PR actually looked pretty good. These were the only unqualified occurrences of \"packet\" in the draft that did not refer to QUIC packets (which is the default qualifier in the draft). I can't approve this, because it's my PR, but I think it's good to go. ",
          "createdAt": "2025-02-06T20:18:47Z",
          "updatedAt": "2025-02-06T20:18:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 232,
      "id": "PR_kwDOFUmh7s6Bkor0",
      "title": "Added a paragraph about RTCP over RoQ",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/232",
      "state": "MERGED",
      "author": "nils-ohlmeier",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "After reading the draft and starting with an implementation I was left wondering how I should transport RTCP over QUIC. This PR adds a paragraph which attempts to clarify the available options.",
      "createdAt": "2024-11-12T01:30:15Z",
      "updatedAt": "2025-02-06T21:05:15Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "4d30cfce35abb9b60ccc07261260a4d1523d12a4",
      "headRepository": "nils-ohlmeier/rtp-over-quic-draft",
      "headRefName": "rtcp",
      "headRefOid": "f5af6318af57cbd41b5d44ffe27a36b79dbccffc",
      "closedAt": "2025-02-06T21:05:15Z",
      "mergedAt": "2025-02-06T21:05:15Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "dac27c6a8187fb06dcef91f5aaaa1f814c278b27"
      },
      "comments": [
        {
          "author": "nils-ohlmeier",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the suggestion. Yes that wording is better.",
          "createdAt": "2024-11-14T19:44:50Z",
          "updatedAt": "2024-11-14T19:44:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s6Q25-D",
          "commit": {
            "abbreviatedOid": "2976957"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "I added one comment/suggestion, but other than that, it looks good to me. Thanks!",
          "createdAt": "2024-11-12T17:48:38Z",
          "updatedAt": "2024-11-12T17:52:44Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nThus it makes more sense if the sender and receiver agree on one or multiple unidirectional streams to transport any RTCP messages.\r\n```",
              "createdAt": "2024-11-12T17:48:38Z",
              "updatedAt": "2024-11-12T17:52:44Z"
            },
            {
              "originalPosition": 10,
              "body": "I think it makes sense to put this more generally since RTCP may go both ways.",
              "createdAt": "2024-11-12T17:51:05Z",
              "updatedAt": "2024-11-12T17:52:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s6Rg3O6",
          "commit": {
            "abbreviatedOid": "68e04d5"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I had a couple of editorial changes, but my most significant comment is about the new text on bidirectional streams. I THINK that's a RoQ protocol error (details in my comments starting on line 748). ",
          "createdAt": "2024-11-18T01:21:02Z",
          "updatedAt": "2024-11-18T01:49:51Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThe same encapsulation as described above for RTP packets can also be used to carry RTCP packets back from the receiver to the sender. Both RTP and RTCP can be transported in either QUIC DATAGRAM frames or QUIC STREAM frames. \r\n```",
              "createdAt": "2024-11-18T01:21:02Z",
              "updatedAt": "2024-11-18T01:49:51Z"
            },
            {
              "originalPosition": 11,
              "body": "I'm not sure whether we need the text about bidirectional streams, using them would be a protocol error.  That's from [Section 5.2](https://mengelbart.github.io/rtp-over-quic-draft/draft-ietf-avtcore-rtp-over-quic.html#name-quic-streams) - bidirectional streams are a ROQ_STREAM_CREATION_ERROR.\r\n\r\nI think we still need the final sentence in the new text. @mengelbart, what do you think?\r\n\r\n```suggestion\r\nIf a receiver sends aggregated RTCP reports for multiple RTP streams, the flow identifier no longer matches the flow identifier for a single RTP stream. Thus the sender always needs to inspect the received RTCP packet independent of the flow identifier used to the RTCP flow to determine to which of the RTP flows the received packets apply.\r\nThis is also the reason why bidirectional streams are not allowed, as the received RTCP packets would not necessarily apply to the same RTP stream being sent on the same flow.\r\nIn addition, allowing a bidirectional stream could result in a situation where the sender has closed its side of the QUIC stream, but the receiver continues to send RTCP in the opposite direction.\r\nThus it makes more sense if the sender and receiver agree on one or multiple unidirectional streams to transport any RTCP messages.\r\n\r\n```",
              "createdAt": "2024-11-18T01:29:26Z",
              "updatedAt": "2024-11-18T01:49:51Z"
            },
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n## Encapsulation Considerations for RTCP\r\n```",
              "createdAt": "2024-11-18T01:42:50Z",
              "updatedAt": "2024-11-18T01:49:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s6Ris1b",
          "commit": {
            "abbreviatedOid": "68e04d5"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-18T08:04:56Z",
          "updatedAt": "2024-11-18T08:04:56Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I agree that it is a protocol violation to use bidirectional streams, but I think it is helpful to have this explanation as to why it doesn't make sense to use bidirectional streams to relate RTCP packets to RTP packets. Maybe change the words `not recommendend` to something else because it is not only not recommend, but forbidden to use bidirectional streams?",
              "createdAt": "2024-11-18T08:04:56Z",
              "updatedAt": "2024-11-18T08:04:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s6RqaSw",
          "commit": {
            "abbreviatedOid": "68e04d5"
          },
          "author": "nils-ohlmeier",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-11-18T21:56:18Z",
          "updatedAt": "2024-11-18T21:56:18Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "@mengelbart Spencer changed the \"not recommended\" already into \"not allowed\". Are we happy with that, or should I try to come up with a better phrasing?",
              "createdAt": "2024-11-18T21:56:18Z",
              "updatedAt": "2024-11-18T21:56:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s6T7rcD",
          "commit": {
            "abbreviatedOid": "68e04d5"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-05T14:36:35Z",
          "updatedAt": "2024-12-05T14:36:35Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Sorry for the slow response. I'm happy with applying Spencer's suggestion and then merging this. ",
              "createdAt": "2024-12-05T14:36:35Z",
              "updatedAt": "2024-12-05T14:36:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s6a9irr",
          "commit": {
            "abbreviatedOid": "21faa07"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I think this is ready to add @nils-ohlmeier to the Acks section. Thank you for sending text! I hope everyone does ... ",
          "createdAt": "2025-02-06T20:25:23Z",
          "updatedAt": "2025-02-06T20:25:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOFUmh7s6a970a",
          "commit": {
            "abbreviatedOid": "f0d264f"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-06T21:04:07Z",
          "updatedAt": "2025-02-06T21:04:08Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThe same encapsulation as described above for RTP packets can also be used to carry RTCP packets back from the receiver to the sender. Both RTP and RTCP can be transported in either QUIC DATAGRAM frames or QUIC STREAM frames.\r\n```\r\nThis may seem nitpicky, but I think it would make the build fail (locally, it does). I can't run actions on the PR, though, because it still has an old version of the Github action, which Github refuses to run... Let's hope the build works correctly when I merge it to the main branch.",
              "createdAt": "2025-02-06T21:04:08Z",
              "updatedAt": "2025-02-06T21:04:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 233,
      "id": "PR_kwDOFUmh7s6G647c",
      "title": "Add meetecho's imquic implementation",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/233",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-07T10:38:52Z",
      "updatedAt": "2025-02-06T21:08:35Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "4d30cfce35abb9b60ccc07261260a4d1523d12a4",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "imquic-implementation",
      "headRefOid": "ba73a1622084c6a0bdbf069d1efdb0b270fcd584",
      "closedAt": "2025-02-06T21:08:33Z",
      "mergedAt": "2025-02-06T21:08:33Z",
      "mergedBy": "mengelbart",
      "mergeCommit": {
        "oid": "2ed179ed49b31151c26ec242182d4e405e7d2588"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s6a9lzg",
          "commit": {
            "abbreviatedOid": "40bd251"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I have one suggestion, and I'm not sure if I understood the original text. Please pushback if \"too\" doesn't mean \"also\".\r\n\r\nNow that we have three implementations, two of which are not from @mengelbart, we could reasonably thank the implementers (we assume the implementation section will be removed by the RFC Editor, but we really appreciate the implementers, and the Acks section would live forever). ",
          "createdAt": "2025-02-06T20:29:42Z",
          "updatedAt": "2025-02-06T20:33:26Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nserver examples are available as a demo, and the library was also used to test\r\ninteroperability with WebRTC via an open source gateway.\r\n```\r\nI thought \"too\" was a typo for \"tool\". Assuming it's not ... also, it would be great to say which open source gateway, because other implementers might want to also test with WebRTC, and that would give them a hint about where to start. ",
              "createdAt": "2025-02-06T20:29:42Z",
              "updatedAt": "2025-02-06T20:33:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOFUmh7s6a997T",
          "commit": {
            "abbreviatedOid": "40bd251"
          },
          "author": "mengelbart",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-02-06T21:08:08Z",
          "updatedAt": "2025-02-06T21:08:09Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "I assume it's Janus, but @lminiero might know better. I'll merge this, we can still add it later.",
              "createdAt": "2025-02-06T21:08:08Z",
              "updatedAt": "2025-02-06T21:08:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 234,
      "id": "PR_kwDOFUmh7s6KViI6",
      "title": "Update acknowledgment section",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/234",
      "state": "MERGED",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Should we add affiliations to the implementer's acknowledgments?",
      "createdAt": "2025-02-06T21:15:16Z",
      "updatedAt": "2025-02-26T16:25:38Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "2ed179ed49b31151c26ec242182d4e405e7d2588",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "update-acks",
      "headRefOid": "4946f5d6635802bc4ef4f1ae25108bce874cfe9c",
      "closedAt": "2025-02-26T16:25:36Z",
      "mergedAt": "2025-02-26T16:25:36Z",
      "mergedBy": "SpencerDawkins",
      "mergeCommit": {
        "oid": "25ce467f23a0c81d9de0aeb0b6272b483a0e0b16"
      },
      "comments": [
        {
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, I can just merge this as the other reviewer. Silly me!",
          "createdAt": "2025-02-26T16:24:27Z",
          "updatedAt": "2025-02-26T16:24:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOFUmh7s6dqRSn",
          "commit": {
            "abbreviatedOid": "4946f5d"
          },
          "author": "SpencerDawkins",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Hi, @mengelbart, this looks fine. Please proceed! \r\n\r\nAnd I thought I had responded to say that we probably don't need to add affiliations in the Acks section. We ask for that on blue sheets, but that's only so we can disambiguate five Fred Smiths who are active at any one time, for purposes of NomCom eligibility and (more rarely) investigations on submarine patents. \r\n\r\nIf we were ever going to start doing that in RFCs, we probably shouldn't do that during a tech industry economic downturn! :unamused:",
          "createdAt": "2025-02-26T16:23:36Z",
          "updatedAt": "2025-02-26T16:23:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 235,
      "id": "PR_kwDOFUmh7s6OdyQ7",
      "title": "Replace \"heading\" with \"registry group\"",
      "url": "https://github.com/mengelbart/rtp-over-quic-draft/pull/235",
      "state": "OPEN",
      "author": "mengelbart",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-03-13T08:25:00Z",
      "updatedAt": "2025-03-13T08:25:01Z",
      "baseRepository": "mengelbart/rtp-over-quic-draft",
      "baseRefName": "main",
      "baseRefOid": "25ce467f23a0c81d9de0aeb0b6272b483a0e0b16",
      "headRepository": "mengelbart/rtp-over-quic-draft",
      "headRefName": "iana-early-review",
      "headRefOid": "461f3101b67717218a192d682b176fa544e51503",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}